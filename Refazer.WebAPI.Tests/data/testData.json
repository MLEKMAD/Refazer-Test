{"submissions":[{"Id":2,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"14","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def helper(j,k):\n        if j==0:\n            return base\n        elif k==j:\n            return combiner(base,term(k))\n        else:\n            return combiner(term(k),helper(j,k+1))\n    return helper(n,1)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    return helper(n, 1) =>           \r\n    return helper(n, 2) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(j, k):\r\n        if j==0:\r\n            return base\r\n        elif k==j:\r\n            return combiner(base, term(k))\r\n        else:\r\n            return combiner(term(k), helper(j, k+1))\r\n    return helper(n, 1)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(j, k):\r\n        if j==0:\r\n            return base\r\n        elif k==j:\r\n            return combiner(base, term(k))\r\n        else:\r\n            return combiner(term(k), helper(j, k+1))\r\n    return helper(n, 1)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,2,1],[2,3,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,4,3,2,1],[2,3,4,5,4,3,2]],"print accumulate(add, 11, 0, identity)":[[1],[2]],"print accumulate(add, 11, 3, square)":[[1,2,3,2,1],[2,3,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,4,3,2,1],[2,3,4,5,4,3,2]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(j, k):\r\n        if j==0:\r\n            return base\r\n        elif k==j:\r\n            return combiner(base, term(k))\r\n        else:\r\n            return combiner(term(k), helper(j, k+1))\r\n    return helper(n, 2)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,2,1],[2,3,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,4,3,2,1],[2,3,4,5,4,3,2]],"print accumulate(add, 11, 0, identity)":[[1],[2]],"print accumulate(add, 11, 3, square)":[[1,2,3,2,1],[2,3,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,4,3,2,1],[2,3,4,5,4,3,2]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"25\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"24\n","print accumulate(add, 0, 5, identity)":"14\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(j, k):\n    \tif j == 0:\n    \t\treturn base\n    \telif k == j:\n    \t\treturn combiner(base, term(k))\n    \telse:\n    \t\treturn combiner(term(k), helper(j, k+1))\n    return helper(n, 1)\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def helper(j,k):\n        if j==0:\n            return base\n        elif k==j:\n            return combiner(base,term(k))\n        else:\n            return combiner(term(k),helper(j,k+1))\n    return helper(n,2)\n"},{"Id":8,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(m), accumulate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(m), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(m), accumulate(combiner, base, n-1, term))","NameError: name 'm' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else: \n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(m),accumulate(combiner,base,n-1,term))\n"},{"Id":10,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":3,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n <= 1: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94,-95,-96,-97,-98,-99,-100,-101,-102,-103,-104,-105,-106,-107,-108,-109,-110,-111,-112,-113,-114,-115,-116,-117,-118,-119,-120,-121,-122,-123,-124,-125,-126,-127,-128,-129,-130,-131,-132,-133,-134,-135,-136,-137,-138,-139,-140,-141,-142,-143,-144,-145,-146,-147,-148,-149,-150,-151,-152,-153,-154,-155,-156,-157,-158,-159,-160,-161,-162]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner, base, n-1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner, base, n-1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner, base, n-1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner, base, n-1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner, base, n-1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner, base, n-1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94,-95,-96,-97,-98,-99,-100,-101,-102,-103,-104,-105,-106,-107,-108,-109,-110,-111,-112,-113,-114,-115,-116,-117,-118,-119,-120,-121,-122,-123,-124,-125,-126,-127,-128,-129,-130,-131,-132,-133,-134,-135,-136,-137,-138,-139,-140,-141,-142,-143,-144,-145,-146,-147,-148,-149,-150,-151,-152,-153,-154,-155,-156,-157,-158,-159,-160,-161,-162]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n <= 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\nfrom operator import add,mul\n"},{"Id":11,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(term(n),base)\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(term(n), base)\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(term(n), base)\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(term(n), base)\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(term(n), base)\n    return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(term(n),base)\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":13,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner (term(n), accumulate(combiner, base, n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner (term(n), accumulate(combiner, base, n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner (term(n), accumulate(combiner, base, n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner (term(n), accumulate(combiner, base, n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner (term(n), accumulate(combiner, base, n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner (term(n), accumulate(combiner, base, n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner (term(n), accumulate(combiner, base, n-1,term))\n#combiner(combiner(base,term(n)), accumulate(combiner,base, n-1,term))\n'''combiner(base, term(n))'''\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":14,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":4,"tests":[{"expected":"15","output":"0","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n        return accumulate(combiner,base,n-1,term)                   <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return accumulate(combiner, base, n-1, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"11\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"11\n","print accumulate(add, 0, 5, identity)":"0\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"total=base\n    counter=1\n    while counter<=n:\n        total=combiner(term(counter),total)\n        counter=counter+1\n    return total\"\"\"\n    if n==0:\n        return base\n    else: \n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return accumulate(combiner,base,n-1,term)\n"},{"Id":15,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":0,"tests":[{"expected":"15","output":"14","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    while n>=1:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while n >= 1: =>           \r\n    while n > 1:  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26],[11,16,20,23,25]],"print accumulate(add, 11, 3, square)":[[11,20,24,25],[11,20,24]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15],[0,5,9,12,14]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0],[3,2,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1]],"print accumulate(add, 11, 3, square)":[[3,2,1,0],[3,2,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\"))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26],[11,16,20,23,25]],"print accumulate(add, 11, 3, square)":[[11,20,24,25],[11,20,24]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15],[0,5,9,12,14]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0],[3,2,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1]],"print accumulate(add, 11, 3, square)":[[3,2,1,0],[3,2,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"25\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"24\n","print accumulate(add, 0, 5, identity)":"14\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total = base\n    while n >= 1:\n        total = combiner(total, term(n))\n        n -= 1\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    while n>1:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n"},{"Id":17,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":5,"tests":[{"expected":"15","output":"TypeError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    i=lambda f:f(x,y)\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    combiner = lambda f: f(x, y) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = lambda f: f(x, y)\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = lambda f: f(x, y)\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    combiner = lambda f: f(x, y)\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","TypeError: <lambda>() takes 1 positional argument but 2 were given","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    combiner=lambda f:f(x,y)\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":23,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":6,"tests":[{"expected":"26","output":"15","input":"accumulate(add, 11, 5, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, k = base, 1 =>           \r\n    total, k = 0, 1    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[0,1,3,6,10,15]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[0,1,5,14]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = 0, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[0,1,3,6,10,15]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[0,1,5,14]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"15\n","print accumulate(add, 11, 0, identity)":"0\n","print accumulate(add, 11, 3, square)":"14\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (total,k)=(0,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n"},{"Id":24,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        total=combiner(base,term(n))\n        return accumulate(combiner,total,n-1,term)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n    if n == 0:      =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        total = combiner(base, term(n))\r\n        return accumulate(combiner, total, n-1, term)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        total = combiner(base, term(n))\r\n        return accumulate(combiner, total, n-1, term)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(add, 11, 0, identity)":[[11],[11,10,8,5,1,-4,-10,-17,-25,-34,-44,-55,-67,-80,-94,-109,-125,-142,-160,-179,-199,-220,-242,-265,-289,-314,-340,-367,-395,-424,-454,-485,-517,-550,-584,-619,-655,-692,-730,-769,-809,-850,-892,-935,-979,-1024,-1070,-1117,-1165,-1214,-1264,-1315,-1367,-1420,-1474,-1529,-1585,-1642,-1700,-1759,-1819,-1880,-1942,-2005,-2069,-2134,-2200,-2267,-2335]]},"total":{},"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        total = combiner(base, term(n))\r\n        return accumulate(combiner, total, n-1, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate","    return accumulate(combiner, total, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate","    return accumulate(combiner, total, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate","    return accumulate(combiner, total, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate","    return accumulate(combiner, total, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate","    return accumulate(combiner, total, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate","    return accumulate(combiner, total, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"base":{"print accumulate(add, 11, 0, identity)":[[11],[11,10,8,5,1,-4,-10,-17,-25,-34,-44,-55,-67,-80,-94,-109,-125,-142,-160,-179,-199,-220,-242,-265,-289,-314,-340,-367,-395,-424,-454,-485,-517,-550,-584,-619,-655,-692,-730,-769,-809,-850,-892,-935,-979,-1024,-1070,-1117,-1165,-1214,-1264,-1315,-1367,-1420,-1474,-1529,-1585,-1642,-1700,-1759,-1819,-1880,-1942,-2005,-2069,-2134,-2200,-2267,-2335]]},"total":{},"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        total = combiner(base, term(n))\n        return accumulate(combiner, total, n-1, term)\n    #def combiner(x, y): # 2 ARGUMENT FUNCTION- WHAT ARE THE TWO ARGUMENTS?\n        #if add(x, y):\n            #return x + y\n        #elif mul(x, y):\n            #return x * y\n    #combiner(1, 2)\n    # mul(1, 2)\n    # add(1, 2)\n\n    #def total_comb(a, total):\n    #    if combiner == add:\n    #        if n == 0:\n    #            return base\n    #        if a == n:\n    #            val = combiner(total, base)\n    #            return val - 1\n    #        else:\n    #            return total_comb(a+1, combiner(total, term(a+1)))\n    #    if n == 0:\n    #        return base\n    #    if a == n:\n    #        return combiner(total, base)\n    #    else:\n    #        return total_comb(a+1, combiner(total, term(a+1)))\n    #return total_comb(0, 1)\n# FIND OUT THE BUGS\n\n# need to find out a way so that your total for add is returned -1 since\n# right now, if the function were add, the final return would have be 1 added\n# to the right answer\n\n# is there an easier way? to do this without having to write so many lines of code\n# is there an easier way to do the recursion\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        total=combiner(base,term(n))\n        return accumulate(combiner,total,n-1,term)\n"},{"Id":25,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def help(base,i):\n        if i==n:\n            return combiner(base,term(i))\n        else:\n            return help(combiner(base,term(i)),i+1)\n    if n==0:\n        return base\n    return help(base,1)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        if i > n:                         =>           \r\n            return base                   =>           \r\n        if i == n:                        <=           \r\n            return combiner(base,term(i)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def help(base, i):\r\n        if i==n:\r\n            return combiner(base, term(i))\r\n        else:\r\n            return help(combiner(base, term(i)), i+1)\r\n    if n==0:\r\n        return base\r\n    return help(base, 1)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def help(base, i):\r\n        if i==n:\r\n            return combiner(base, term(i))\r\n        else:\r\n            return help(combiner(base, term(i)), i+1)\r\n    if n==0:\r\n        return base\r\n    return help(base, 1)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{},"base":{"print accumulate(add, 11, 0, identity)":[[11],[11,12,14,17,21,26,32,39,47,56,66,77,89,102,116,131,147,164,182,201,221,242,264,287,311,336,362,389,417,446,476,507,539,572,606,641,677,714,752,791,831,872,914,957,1001,1046,1092,1139,1187,1236,1286,1337,1389,1442,1496,1551,1607,1664,1722,1781,1841,1902,1964,2027,2091,2156,2222,2289,2357,2426,2496,2567,2639,2712,2786,2861,2937,3014,3092,3171,3251]]},"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def help(base, i):\r\n        if i==n:\r\n            return combiner(base, term(i))\r\n        else:\r\n            return help(combiner(base, term(i)), i+1)\r\n    return help(base, 1)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help","    return help(combiner(base,term(i)),i + 1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help","    return help(combiner(base,term(i)),i + 1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help","    return help(combiner(base,term(i)),i + 1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help","    return help(combiner(base,term(i)),i + 1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help","    return help(combiner(base,term(i)),i + 1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help","    return help(combiner(base,term(i)),i + 1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in help","    if i == n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"i":{},"base":{"print accumulate(add, 11, 0, identity)":[[11],[11,12,14,17,21,26,32,39,47,56,66,77,89,102,116,131,147,164,182,201,221,242,264,287,311,336,362,389,417,446,476,507,539,572,606,641,677,714,752,791,831,872,914,957,1001,1046,1092,1139,1187,1236,1286,1337,1389,1442,1496,1551,1607,1664,1722,1781,1841,1902,1964,2027,2091,2156,2222,2289,2357,2426,2496,2567,2639,2712,2786,2861,2937,3014,3092,3171,3251]]},"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def help(base,i):\n        if i > n:\n            return base\n        else:\n            return help(combiner(base,term(i)),i + 1)\n    return help(base,1)\n\n        \n\n    \n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def help(base,i):\n        if i==n:\n            return combiner(base,term(i))\n        else:\n            return help(combiner(base,term(i)),i+1)\n    return help(base,1)\n"},{"Id":28,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    return combiner(base,accumulate(combiner,term(n),n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    elif n == 0:                =>           \r\n        return combiner(base,0) =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    return combiner(base, accumulate(combiner, term(n), n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    return combiner(base, accumulate(combiner, term(n), n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(add, 11, 0, identity)":[[11],[11,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    return combiner(base, accumulate(combiner, term(n), n-1, term))\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(base, accumulate(combiner, term(n), n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(base, accumulate(combiner, term(n), n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(base, accumulate(combiner, term(n), n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(base, accumulate(combiner, term(n), n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(base, accumulate(combiner, term(n), n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(base, accumulate(combiner, term(n), n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"base":{"print accumulate(add, 11, 0, identity)":[[11],[11,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n\t\"\"\"Return the result of combining the first N terms in a sequence.  The\n\tterms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n\ttwo-argument function.  Treating COMBINER as if it were a binary operator,\n\tthe return value is\n\t\tBASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n\t>>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n\t15\n\t>>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n\t26\n\t>>> accumulate(add, 11, 0, identity) # 11\n\t11\n\t>>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n\t25\n\t>>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n\t72\n\t\"\"\"\n\t\"*** YOUR CODE HERE ***\"\n\tif n == 1:\n\t\treturn combiner(base,term(1)) \n\telif n == 0:\n\t\treturn combiner(base,0)\n\treturn combiner(base, accumulate(combiner, term(n), n-1, term))\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    return combiner(base,accumulate(combiner,term(n),n-1,term))\nfrom operator import add,mul\n"},{"Id":30,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":7,"tests":[{"expected":"11","output":"0","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(1,base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        return combiner(base, 0) =>           \r\n        return 0                 <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(1, base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(1, base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return 0\r\n    if n==1:\r\n        return combiner(1, base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","0","","# Error: expected","#     11","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"0\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return combiner(base, 0)\n    if n == 1:\n        return combiner(1, base)\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return 0\n    if n==1:\n        return combiner(1,base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":31,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":8,"tests":[{"expected":"25","output":"135","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    count=1\n    total=base\n    while count<=n:\n        total=combiner(total,term(count))\n        count=count+1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total = 1          =>           \r\n    total = base       =>           \r\n    total = term(1)    <=           \r\n    total = term(base) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    total = base\r\n    while count<=n:\r\n        total = combiner(total, term(count))\r\n        count = count+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    total = base\r\n    while count<=n:\r\n        total = combiner(total, term(count))\r\n        count = count+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[4,16,144]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[121,122,126,135]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[11,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[11,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    total = term(base)\r\n    while count<=n:\r\n        total = combiner(total, term(count))\r\n        count = count+1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[4,16,144]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[121,122,126,135]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[11,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[11,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"144\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"135\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    count = 1\n    total = base\n    while count <= n:\n        total = combiner(total, term(count))\n        count = count + 1\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    count=1\n    total=term(base)\n    while count<=n:\n        total=combiner(total,term(count))\n        count=count+1\n    return total\n"},{"Id":33,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":9,"tests":[{"expected":"15","output":"UnboundLocalError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if combiner==mul:\n        total=1\n    else:\n        total=0\n    def partial_total(combiner,base,n,term):\n        if n==0:\n            return base\n        else:\n            base=combiner(base,term(n))\n            return partial_total(combiner,base,n-1,term)\n    return partial_total(combiner,base,n,term)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n            return base                     =>           \r\n            base = combiner(base, term(n))  =>           \r\n    if combiner==mul:                       <=           \r\n        total=1                             <=           \r\n        total=0                             <=           \r\n            return total                    <=           \r\n            total = combiner(base, term(n)) <=           \r\n    else:                                   <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if combiner==mul:\r\n        total = 1\r\n    else:\r\n        total = 0\r\n    def partial_total(combiner, base, n, term):\r\n        if n==0:\r\n            return base\r\n        else:\r\n            base = combiner(base, term(n))\r\n            return partial_total(combiner, base, n-1, term)\r\n    return partial_total(combiner, base, n, term)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if combiner==mul:\r\n        total = 1\r\n    else:\r\n        total = 0\r\n    def partial_total(combiner, base, n, term):\r\n        if n==0:\r\n            return base\r\n        else:\r\n            base = combiner(base, term(n))\r\n            return partial_total(combiner, base, n-1, term)\r\n    return partial_total(combiner, base, n, term)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18,2],[2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26,25,23,20,16,11],[11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25,24,20,11],[11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15,14,12,9,5,0],[0]]},"total":{"print accumulate(mul, 2, 3, square)":[[1],[1,18,8,2,8,18,1]],"print accumulate(add, 11, 5, identity)":[[0],[0,16,15,14,13,12,13,14,15,16,0]],"print accumulate(add, 11, 3, square)":[[0],[0,20,15,12,15,20,0]],"print accumulate(add, 0, 5, identity)":[[0],[0,5,4,3,2,1,2,3,4,5,0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if combiner==mul:\r\n        total = 1\r\n    else:\r\n        total = 0\r\n    def partial_total(combiner, base, n, term):\r\n        if n==0:\r\n            return total\r\n        else:\r\n            total = combiner(base, term(n))\r\n            return partial_total(combiner, base, n-1, term)\r\n    return partial_total(combiner, base, n, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in accumulate","    return partial_total(combiner, base, n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in partial_total","    return partial_total(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in partial_total","    return partial_total(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in partial_total","    return partial_total(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in partial_total","    return partial_total(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in partial_total","    return partial_total(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in partial_total","    return total","UnboundLocalError: local variable 'total' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18,2],[2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26,25,23,20,16,11],[11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25,24,20,11],[11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15,14,12,9,5,0],[0]]},"total":{"print accumulate(mul, 2, 3, square)":[[1],[1,18,8,2,8,18,1]],"print accumulate(add, 11, 5, identity)":[[0],[0,16,15,14,13,12,13,14,15,16,0]],"print accumulate(add, 11, 3, square)":[[0],[0,20,15,12,15,20,0]],"print accumulate(add, 0, 5, identity)":[[0],[0,5,4,3,2,1,2,3,4,5,0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def partial_total(combiner, base, n, term):\n        if n==0:\n            return base\n        else:\n            base = combiner(base, term(n))\n            return partial_total(combiner, base, n-1, term)\n    return partial_total(combiner, base, n, term)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if combiner==mul:\n        total=1\n    else:\n        total=0\n    def partial_total(combiner,base,n,term):\n        if n==0:\n            return total\n        else:\n            total=combiner(base,term(n))\n            return partial_total(combiner,base,n-1,term)\n    return partial_total(combiner,base,n,term)\n"},{"Id":34,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":4,"tests":[{"expected":"15","output":"TypeError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n        total, k = combiner(total, term(k)), k + 1  =>           \r\n    return total                                    =>           \r\n        total, k = combiner (total, term(k)), k + 1 <=           \r\n    return combiner(total)                          <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return combiner(total)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 85, in accumulate","    return combiner(total)","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"if combiner == add or combiner == sub:\n        total, k = base, 1\n        while k <= n:\n            total, k = combiner (total, term(k)), k + 1\n        return combiner(total, base)\n    else:\n        total, k = 1, 1\n        while k <= n:\n            total, k = combiner (total, term(k)), k + 1\n        return combiner(total, base)\"\"\"\n\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return combiner(total)\n"},{"Id":35,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"108","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if base==1:\n        return base+term(1)\n    elif n==0:\n        return base+term(0)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n        return combiner(base,term(1)) =>           \r\n        return combiner(base,term(0)) =>           \r\n        return base + term(1)         <=           \r\n        return base + term(0)         <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if base==1:\r\n        return base+term(1)\r\n    elif n==0:\r\n        return base+term(0)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if base==1:\r\n        return base+term(1)\r\n    elif n==0:\r\n        return base+term(0)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0],[3,2,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1]],"print accumulate(add, 11, 3, square)":[[3,2,1,0],[3,2,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return base+term(1)\r\n    elif n==0:\r\n        return base+term(0)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0],[3,2,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1]],"print accumulate(add, 11, 3, square)":[[3,2,1,0],[3,2,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"108\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return combiner(base,term(1))\n    elif n == 0:\n        return combiner(base,term(0))\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return base+term(1)\n    elif n==0:\n        return base+term(0)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":36,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":11,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    x=1\n    if x==mul:\n        total=1\n    else:\n        total=base\n    while x<=n:\n        (total,x)=(combiner(total,term(x)),x+1)\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                          SideIndicator\r\n-----------                                                          -------------\r\n    counter = 1                                                      =>           \r\n    if combiner == mul:                                              =>           \r\n    while counter <= n:                                              =>           \r\n        total, counter = combiner(total, term(counter)), counter + 1 =>           \r\n    x = 1                                                            <=           \r\n    if x == mul:                                                     <=           \r\n    while x <= n:                                                    <=           \r\n        total, x = combiner(total, term(x)), x + 1                   <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = 1\r\n    if x==mul:\r\n        total = 1\r\n    else:\r\n        total = base\r\n    while x<=n:\r\n        total, x = combiner(total, term(x)), x+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = 1\r\n    if x==mul:\r\n        total = 1\r\n    else:\r\n        total = base\r\n    while x<=n:\r\n        total, x = combiner(total, term(x)), x+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[0,1,3,6,10,15]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[0,1,5,14]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = 1\r\n    if x==mul:\r\n        total = 1\r\n    else:\r\n        total = 0\r\n    while x<=n:\r\n        total, x = combiner(total, term(x)), x+1\r\n    return combiner(base, total)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[0,1,3,6,10,15]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[0,1,5,14]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    if combiner == mul:\n        total = 1\n    else:\n        total = 0\n    while counter <= n:\n        total, counter = combiner(total, term(counter)), counter + 1\n    return combiner(base, total)\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    x=1\n    if x==mul:\n        total=1\n    else:\n        total=0\n    while x<=n:\n        (total,x)=(combiner(total,term(x)),x+1)\n    return combiner(base,total)\n"},{"Id":37,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n<1:\n        return combiner(base,n)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        return base              =>           \r\n        return combiner(base, n) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n<1:\r\n        return combiner(base, n)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n<1:\r\n        return combiner(base, n)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<1:\r\n        return combiner(base, n)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n<1:\n        return combiner(base,n)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":41,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":12,"tests":[{"expected":"25","output":"17","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                     SideIndicator\r\n-----------                                                     -------------\r\n    return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n    return combiner(n,accumulate(combiner,base,n-1,term))       <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[1]],"print accumulate(add, 11, 3, square)":[[3,2,1],[1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    from operator import add, mul\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    return combiner(n, accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[1]],"print accumulate(add, 11, 3, square)":[[3,2,1],[1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"12\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"17\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    from operator import add, mul\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    from operator import add,mul\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(n))\n    return combiner(n,accumulate(combiner,base,n-1,term))\n"},{"Id":42,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":8,"tests":[{"expected":"15","output":"UnboundLocalError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (i,total)=(1,base)\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                    SideIndicator\r\n-----------                    -------------\r\n    i, total = 1, base         =>           \r\n    index, total = 1, base     <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    i, total = 1, base\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i, total = 1, base\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    index, total = 1, base\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    while i <= n:","UnboundLocalError: local variable 'i' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i, total = 1, base    \n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (index,total)=(1,base)\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n"},{"Id":44,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":13,"tests":[{"expected":"15","output":"10","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(term(k),total),k+1)\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n        total, k = combiner(term(k), total), k + 1 =>           \r\n        total, k = combiner(term(k), k), k + 1     <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(term(k), total), k+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(term(k), total), k+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,1,8,27]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,2,4,6,8,10]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,2,6,12]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,2,4,6,8,10]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(term(k), k), k+1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,1,8,27]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,2,4,6,8,10]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,2,6,12]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,2,4,6,8,10]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"27\n","print accumulate(add, 11, 5, identity)":"10\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"12\n","print accumulate(add, 0, 5, identity)":"10\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(term(k), total), k + 1\n    return total\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(term(k),k),k+1)\n    return total\n"},{"Id":46,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0 or n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumalate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumalate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumalate(combiner, base, n-1, term))","NameError: name 'accumalate' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-accumulate)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(LeafWildcard(\"ArgNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0 or n == 1:\n        return combiner(base, term(n)) \n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0 or n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumalate(combiner,base,n-1,term))\n"},{"Id":47,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        if term==mul:\n            return combiner(base,term(n+1))\n        return combiner(base,term(n))\n    else:\n        base=combiner(base,term(n))\n        return accumulate(combiner,base,n-1,term)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n        if combiner == mul: =>           \r\n        if term == mul:     <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        if term==mul:\r\n            return combiner(base, term(n+1))\r\n        return combiner(base, term(n))\r\n    else:\r\n        base = combiner(base, term(n))\r\n        return accumulate(combiner, base, n-1, term)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        if term==mul:\r\n            return combiner(base, term(n+1))\r\n        return combiner(base, term(n))\r\n    else:\r\n        base = combiner(base, term(n))\r\n        return accumulate(combiner, base, n-1, term)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        if term==mul:\r\n            return combiner(base, term(n+1))\r\n        return combiner(base, term(n))\r\n    else:\r\n        base = combiner(base, term(n))\r\n        return accumulate(combiner, base, n-1, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        if combiner == mul:\n            return combiner(base, term(n + 1))\n        return combiner(base, term(n))\n    else:\n        base = combiner(base, term(n))\n        return accumulate(combiner, base, n - 1, term)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        if term==mul:\n            return combiner(base,term(n+1))\n        return combiner(base,term(n))\n    else:\n        base=combiner(base,term(n))\n        return accumulate(combiner,base,n-1,term)\n"},{"Id":48,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":14,"tests":[{"expected":"11","output":"12","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    base=combiner(base,term(1))\n    for i in range(2,n+1):\n        base=combiner(base,term(i))\n    return base\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                        SideIndicator\r\n-----------                        -------------\r\n    for i in range(1, n+1):        =>           \r\n    base = combiner(base, term(1)) <=           \r\n    for i in range(2, n+1):        <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    base = combiner(base, term(1))\r\n    for i in range(2, n+1):\r\n        base = combiner(base, term(i))\r\n    return base","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    base = combiner(base, term(1))\r\n    for i in range(2, n+1):\r\n        base = combiner(base, term(i))\r\n    return base","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(add, 11, 0, identity)":[[11],[11,12]]},"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    base = combiner(base, term(1))\r\n    for i in range(2, n+1):\r\n        base = combiner(base, term(i))\r\n    return base","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"base":{"print accumulate(add, 11, 0, identity)":[[11],[11,12]]},"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"12\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    for i in range(1, n+1):\n        base = combiner(base, term(i))\n    return base;\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    base=combiner(base,term(1))\n    for i in range(2,n+1):\n        base=combiner(base,term(i))\n    return base\n"},{"Id":49,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    if n==0:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n==0:        =>           \r\n        return base =>           \r\n    elif n==1:      =>           \r\n    if n==1:        <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    if n==0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    if n==0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    if n==1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base,term(1))\n    return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":50,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":13,"tests":[{"expected":"11","output":"12","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def times(x):\n        if n==0:\n            return 1\n        if x==n:\n            return term(n)\n        else:\n            return combiner(term(x),times(increment(x)))\n    if n==0:\n        return base\n    return combiner(base,times(1))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n            return 0 =>           \r\n            return 1 <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def times(x):\r\n        if n==0:\r\n            return 1\r\n        if x==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(x), times(increment(x)))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, times(1))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def times(x):\r\n        if n==0:\r\n            return 1\r\n        if x==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(x), times(increment(x)))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, times(1))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def times(x):\r\n        if n==0:\r\n            return 1\r\n        if x==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(x), times(increment(x)))\r\n    return combiner(base, times(1))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"12\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def times(x):\n        if n==0:\n            return 0\n        if x==n:\n            return term(n)\n        else:\n            return combiner(term(x),times(increment(x)))\n    return combiner(base,times(1))\n    \n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def times(x):\n        if n==0:\n            return 1\n        if x==n:\n            return term(n)\n        else:\n            return combiner(term(x),times(increment(x)))\n    return combiner(base,times(1))\n"},{"Id":53,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(1,base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n    return\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    elif n == 0:                 =>           \r\n        return combiner(0, base) =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(1, base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    return ","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(1, base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    return ","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(1, base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    return ","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner (1, base)\n    elif n == 0:\n        return combiner(0, base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n    return \n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(1,base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n    return\n"},{"Id":54,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":15,"tests":[{"expected":"15","output":"16","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return combiner(base,term(n+1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        return base                      =>           \r\n        return combiner(base, term(n+1)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(base, term(n+1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(base, term(n+1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return combiner(base, term(n+1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"27\n","print accumulate(add, 11, 0, identity)":"12\n","print accumulate(add, 11, 3, square)":"26\n","print accumulate(add, 0, 5, identity)":"16\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return combiner(base,term(n+1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":55,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":13,"tests":[{"expected":"11","output":"12","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    k=2\n    if n==0:\n        return base\n    total=combiner(base,term(1))\n    while k<=n:\n        total=combiner(total,term(k))\n        k+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n == 0:                         =>           \r\n        return combiner(base, term(0)) =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 2\r\n    if n==0:\r\n        return base\r\n    total = combiner(base, term(1))\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 2\r\n    if n==0:\r\n        return base\r\n    total = combiner(base, term(1))\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{},"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 2\r\n    total = combiner(base, term(1))\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{},"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"12\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return combiner(base, term(0))\n    k = 2\n    total = combiner(base, term(1))\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n\n\n\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    k=2\n    total=combiner(base,term(1))\n    while k<=n:\n        total=combiner(total,term(k))\n        k+=1\n    return total\n"},{"Id":56,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":14,"tests":[{"expected":"15","output":"16","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    value=term(1)\n    if n==0:\n        return base\n    while n>1:\n        value=combiner(value,term(n))\n        n-=1\n    return combiner(value,base)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    while n>1: =>           \r\n    while n>0: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    value = term(1)\r\n    if n==0:\r\n        return base\r\n    while n>1:\r\n        value = combiner(value, term(n))\r\n        n -= 1\r\n    return combiner(value, base)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    value = term(1)\r\n    if n==0:\r\n        return base\r\n    while n>1:\r\n        value = combiner(value, term(n))\r\n        n -= 1\r\n    return combiner(value, base)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"value":{"print accumulate(add, 11, 5, identity)":[[1,6,10,13,15],[1,6,10,13,15,16]],"print accumulate(add, 11, 3, square)":[[1,10,14],[1,10,14,15]],"print accumulate(add, 0, 5, identity)":[[1,6,10,13,15],[1,6,10,13,15,16]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,3,2],[1,3,2,1]],"print accumulate(add, 11, 5, identity)":[[1,5,4,3,2],[1,5,4,3,2,1]],"print accumulate(add, 11, 3, square)":[[1,3,2],[1,3,2,1]],"print accumulate(add, 0, 5, identity)":[[1,5,4,3,2],[1,5,4,3,2,1]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    value = term(1)\r\n    if n==0:\r\n        return base\r\n    while n>0:\r\n        value = combiner(value, term(n))\r\n        n -= 1\r\n    return combiner(value, base)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"value":{"print accumulate(add, 11, 5, identity)":[[1,6,10,13,15],[1,6,10,13,15,16]],"print accumulate(add, 11, 3, square)":[[1,10,14],[1,10,14,15]],"print accumulate(add, 0, 5, identity)":[[1,6,10,13,15],[1,6,10,13,15,16]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,3,2],[1,3,2,1]],"print accumulate(add, 11, 5, identity)":[[1,5,4,3,2],[1,5,4,3,2,1]],"print accumulate(add, 11, 3, square)":[[1,3,2],[1,3,2,1]],"print accumulate(add, 0, 5, identity)":[[1,5,4,3,2],[1,5,4,3,2,1]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"27\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"26\n","print accumulate(add, 0, 5, identity)":"16\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    value=term(1)\n    if n==0:\n        return base\n    while n>1:\n        value=combiner(value,term(n))\n        n-=1\n    return combiner(value, base)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    value=term(1)\n    if n==0:\n        return base\n    while n>0:\n        value=combiner(value,term(n))\n        n-=1\n    return combiner(value,base)\n"},{"Id":58,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":7,"tests":[{"expected":"25","output":"135","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return (combiner(term(n), accumulate(combiner, base, n-1, term)))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return (combiner(term(n), accumulate(combiner, base, n-1, term)))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,11]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,11]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return (combiner(term(n), accumulate(combiner, base, n-1, term)))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,11]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,11]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"144\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"135\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        return (combiner(term(n),accumulate(combiner,base,n-1,term)))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":59,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":16,"tests":[{"expected":"15","output":"21","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    k=0\n    while k+1<=n:\n        k=k+1\n        total=combiner(total,term(k))\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while k < n:  =>           \r\n    while k <= n: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 0\r\n    while k+1<=n:\r\n        k = k+1\r\n        total = combiner(total, term(k))\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 0\r\n    while k+1<=n:\r\n        k = k+1\r\n        total = combiner(total, term(k))\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[0,1,2,3],[0,1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[0,1,2,3,4,5],[0,1,2,3,4,5,6]],"print accumulate(add, 11, 0, identity)":[[0],[0,1]],"print accumulate(add, 11, 3, square)":[[0,1,2,3],[0,1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[0,1,2,3,4,5],[0,1,2,3,4,5,6]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8,72,1152]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,17,21,26,32]],"print accumulate(add, 11, 0, identity)":[[11],[11,12]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,16,25,41]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,6,10,15,21]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,3,4,5,6]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3,4,5,6]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 0\r\n    while k<=n:\r\n        k = k+1\r\n        total = combiner(total, term(k))\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","21","","# Error: expected","#     15","# but got","#     21","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[0,1,2,3],[0,1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[0,1,2,3,4,5],[0,1,2,3,4,5,6]],"print accumulate(add, 11, 0, identity)":[[0],[0,1]],"print accumulate(add, 11, 3, square)":[[0,1,2,3],[0,1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[0,1,2,3,4,5],[0,1,2,3,4,5,6]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8,72,1152]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,17,21,26,32]],"print accumulate(add, 11, 0, identity)":[[11],[11,12]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,16,25,41]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,6,10,15,21]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,3,4,5,6]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3,4,5,6]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"1152\n","print accumulate(add, 11, 5, identity)":"32\n","print accumulate(add, 11, 0, identity)":"12\n","print accumulate(add, 11, 3, square)":"41\n","print accumulate(add, 0, 5, identity)":"21\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #def more_term(combiner, n, term):\n     #   if n == 0:\n      #      return \n       # return combiner(term(n), more_term(combiner, n-1, term))\n    #return combiner(base, more_term(combiner, n, term)) \n    total = base \n    k = 0\n    while k < n:\n        k = k + 1\n        total = combiner(total, term(k))\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    k=0\n    while k<=n:\n        k=k+1\n        total=combiner(total,term(k))\n    return total\n"},{"Id":60,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    k=n\n    if n==0:\n        return base\n    if k>=1:\n        return combiner(term(k),accumulate(combiner,base,k-1,term))\n    else:\n        return combiner(base,term(k))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if k > 1:  =>           \r\n    if k >= 1: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = n\r\n    if n==0:\r\n        return base\r\n    if k>=1:\r\n        return combiner(term(k), accumulate(combiner, base, k-1, term))\r\n    else:\r\n        return combiner(base, term(k))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = n\r\n    if n==0:\r\n        return base\r\n    if k>=1:\r\n        return combiner(term(k), accumulate(combiner, base, k-1, term))\r\n    else:\r\n        return combiner(base, term(k))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = n\r\n    if k>=1:\r\n        return combiner(term(k), accumulate(combiner, base, k-1, term))\r\n    else:\r\n        return combiner(base, term(k))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = n\n    if k > 1:\n        return combiner(term(k), accumulate(combiner, base, k - 1, term))\n    else:\n        return combiner(base, term(k))\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    k=n\n    if k>=1:\n        return combiner(term(k),accumulate(combiner,base,k-1,term))\n    else:\n        return combiner(base,term(k))\n"},{"Id":61,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":0,"tests":[{"expected":"15","output":"14","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if base==1 or n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    if n==0:         =>           \r\n    if n==1 or n==0: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if base==1 or n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if base==1 or n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1 or n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"25\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"24\n","print accumulate(add, 0, 5, identity)":"14\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1 or n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":62,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":17,"tests":[{"expected":"72","output":"63","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n>0:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumulate(add, base, n-1, term))      <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n>0:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n>0:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n>0:\r\n        return combiner(term(n), accumulate(add, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","63","","# Error: expected","#     72","# but got","#     63","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"63\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    if n == 0:\n        return base\n    if n > 0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n>0:\n        return combiner(term(n),accumulate(add,base,n-1,term))\n"},{"Id":64,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    counter=1\n    while counter<=n:\n        num=term(counter)\n        base=combiner(base,num)\n        counter=counter+1\n    return base\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    counter = 1 =>           \r\n    counter = 0 <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    while counter<=n:\r\n        num = term(counter)\r\n        base = combiner(base, num)\r\n        counter = counter+1\r\n    return base","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    while counter<=n:\r\n        num = term(counter)\r\n        base = combiner(base, num)\r\n        counter = counter+1\r\n    return base","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]]},"num":{"print accumulate(mul, 2, 3, square)":[[1,4,9],[0,1,4,9]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,4,9],[0,1,4,9]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]},"counter":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]],"print accumulate(add, 11, 0, identity)":[[1],[0,1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 0\r\n    while counter<=n:\r\n        num = term(counter)\r\n        base = combiner(base, num)\r\n        counter = counter+1\r\n    return base","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]]},"num":{"print accumulate(mul, 2, 3, square)":[[1,4,9],[0,1,4,9]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,4,9],[0,1,4,9]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]},"counter":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]],"print accumulate(add, 11, 0, identity)":[[1],[0,1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    while counter <= n:\n        num = term(counter)\n        base = combiner(base, num)\n        counter = counter + 1\n    return base\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    counter=0\n    while counter<=n:\n        num=term(counter)\n        base=combiner(base,num)\n        counter=counter+1\n    return base\n"},{"Id":67,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":11,"tests":[{"expected":"25","output":"17","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base,n)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(n, accumulate(combiner, base, n-1, term))       <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return combiner(base, n)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return combiner(base, n)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return combiner(base, n)\r\n    else:\r\n        return combiner(n, accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"12\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"17\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, n)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n    # if combiner == add:\n    #     total = 0\n    # else:\n    #     total = 1\n    # if n == 0:\n    #     return combiner(base, 0)\n    # else:\n    #     while n > 0:\n    #         total = combiner(term(n), total)\n    #         n -= 1\n    # return combiner(base, total)\n        \n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base,n)\n    else:\n        return combiner(n,accumulate(combiner,base,n-1,term))\n"},{"Id":68,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return base                    =>           \r\n        return combiner(base, term(n)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\nfrom operator import add,mul\n"},{"Id":69,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":18,"tests":[{"expected":"15","output":"25","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    i=1\n    while i<=n:\n        base=combiner(base,term(i))\n        i+=1\n    return base\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        base = combiner(base, term(i)) =>           \r\n        base = combiner(base, term(n)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    while i<=n:\r\n        base = combiner(base, term(i))\r\n        i += 1\r\n    return base","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    while i<=n:\r\n        base = combiner(base, term(i))\r\n        i += 1\r\n    return base","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,18,162,1458]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,16,21,26,31,36]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,20,29,38]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,5,10,15,20,25]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    while i<=n:\r\n        base = combiner(base, term(n))\r\n        i += 1\r\n    return base","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,18,162,1458]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,16,21,26,31,36]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,20,29,38]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,5,10,15,20,25]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"1458\n","print accumulate(add, 11, 5, identity)":"36\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"38\n","print accumulate(add, 0, 5, identity)":"25\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # y = term(n)\n    # x = n\n    # total = 0 \n    # if base == 0:\n    #     y = 0\n    #     while x > 0:\n    #         temp = combiner(y, term(x)) \n    #         total = total + temp\n    #         x -= 1\n    #     return total \n    # else:\n    #     while x > 0:\n    #         temp = combiner(base, term(x))\n    #         total = total + temp\n    #         x -= 1\n    #     return total \n    i = 1\n    while i <= n:\n        base = combiner(base, term(i))\n        i += 1\n    return base \n\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    i=1\n    while i<=n:\n        base=combiner(base,term(n))\n        i+=1\n    return base\n"},{"Id":71,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n==0:                           =>           \r\n    elif n==1:                         =>           \r\n        return combiner(base, term(n)) =>           \r\n    if n==1:                           <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    if n==1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return combiner(base, term(n))\n    elif n==1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":72,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":9,"tests":[{"expected":"72","output":"108","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<=0:\n        return term(n)+base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(term(n), base) =>           \r\n        return term(n) + base          <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=0:\r\n        return term(n)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=0:\r\n        return term(n)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0],[3,2,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1]],"print accumulate(add, 11, 3, square)":[[3,2,1,0],[3,2,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return term(n)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0],[3,2,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1]],"print accumulate(add, 11, 3, square)":[[3,2,1,0],[3,2,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"108\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 1:\n        return combiner(term(n), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n<=1:\n        return term(n)+base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":73,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    if n==0:                  =>           \r\n        return base           =>           \r\n    if n==1:                  <=           \r\n        return base + term(1) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return base+term(1)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    if n==1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast)))))))","sequence_comparison_diff":{"x":{},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"108\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return base+term(1)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":77,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":13,"tests":[{"expected":"11","output":"12","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    n_counter=1\n    if n==0:\n        return base\n    accum_num=combiner(base,term(n_counter))\n    while n_counter<n:\n        n_counter+=1\n        accum_num=combiner(accum_num,term(n_counter))\n    return accum_num\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    if n == 0:        =>           \r\n        n_counter = 0 =>           \r\n        n_counter = 1 =>           \r\n    else:             =>           \r\n    n_counter = 1     <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    n_counter = 1\r\n    if n==0:\r\n        return base\r\n    accum_num = combiner(base, term(n_counter))\r\n    while n_counter<n:\r\n        n_counter += 1\r\n        accum_num = combiner(accum_num, term(n_counter))\r\n    return accum_num","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    n_counter = 1\r\n    if n==0:\r\n        return base\r\n    accum_num = combiner(base, term(n_counter))\r\n    while n_counter<n:\r\n        n_counter += 1\r\n        accum_num = combiner(accum_num, term(n_counter))\r\n    return accum_num","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"accum_num":{},"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    n_counter = 1\r\n    accum_num = combiner(base, term(n_counter))\r\n    while n_counter<n:\r\n        n_counter += 1\r\n        accum_num = combiner(accum_num, term(n_counter))\r\n    return accum_num","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"accum_num":{},"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"12\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        n_counter = 0\n    else:\n        n_counter = 1\n    accum_num = combiner(base, term(n_counter))\n    while n_counter < n:\n        n_counter += 1\n        accum_num = combiner(accum_num, term(n_counter))\n    return accum_num\n    \n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    n_counter=1\n    accum_num=combiner(base,term(n_counter))\n    while n_counter<n:\n        n_counter+=1\n        accum_num=combiner(accum_num,term(n_counter))\n    return accum_num\n"},{"Id":78,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":19,"tests":[{"expected":"15","output":"20","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    z=base\n    for x in range(1,n+1):\n        z=combiner(z,term(x))\n    return z\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    z=base  =>           \r\n    z=n     <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    z = base\r\n    for x in range(1, n+1):\r\n        z = combiner(z, term(x))\r\n    return z","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    z = base\r\n    for x in range(1, n+1):\r\n        z = combiner(z, term(x))\r\n    return z","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"z":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[3,12,108]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[5,6,8,11,15,20]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[3,4,8,17]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[5,6,8,11,15,20]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    z = n\r\n    for x in range(1, n+1):\r\n        z = combiner(z, term(x))\r\n    return z","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","20","","# Error: expected","#     15","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"z":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[3,12,108]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[5,6,8,11,15,20]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[3,4,8,17]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[5,6,8,11,15,20]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"108\n","print accumulate(add, 11, 5, identity)":"20\n","print accumulate(add, 11, 0, identity)":"0\n","print accumulate(add, 11, 3, square)":"17\n","print accumulate(add, 0, 5, identity)":"20\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    z=base\n    for x in range(1,n+1):\n        z=combiner(z,term(x))\n    return z\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    z=n\n    for x in range(1,n+1):\n        z=combiner(z,term(x))\n    return z\n"},{"Id":79,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":20,"tests":[{"expected":"72","output":"28","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def helper(n,term):\n        if n==0:\n            return 0\n        elif n<=1:\n            return 1\n        else:\n            return combiner(term(n),helper(n-1,term))\n    return combiner(base,helper(n,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                             SideIndicator\r\n-----------                                             -------------\r\n            return combiner(term(n), helper(n-1, term)) =>           \r\n            return term(n)+helper(n-1, term)            <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(n, term):\r\n        if n==0:\r\n            return 0\r\n        elif n<=1:\r\n            return 1\r\n        else:\r\n            return combiner(term(n), helper(n-1, term))\r\n    return combiner(base, helper(n, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(n, term):\r\n        if n==0:\r\n            return 0\r\n        elif n<=1:\r\n            return 1\r\n        else:\r\n            return combiner(term(n), helper(n-1, term))\r\n    return combiner(base, helper(n, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(n, term):\r\n        if n==0:\r\n            return 0\r\n        elif n<=1:\r\n            return 1\r\n        else:\r\n            return term(n)+helper(n-1, term)\r\n    return combiner(base, helper(n, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","28","","# Error: expected","#     72","# but got","#     28","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\"))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"28\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(n, term):\n        if n == 0:\n            return 0\n        elif n <= 1:\n            return 1\n        else:\n            return combiner(term(n), helper(n-1, term))\n    return combiner(base, helper(n, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def helper(n,term):\n        if n==0:\n            return 0\n        elif n<=1:\n            return 1\n        else:\n            return term(n)+helper(n-1,term)\n    return combiner(base,helper(n,term))\n"},{"Id":82,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n==0:        =>           \r\n        return base =>           \r\n    elif n==1:      =>           \r\n    if n==1:        <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    if n==1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":83,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":4,"tests":[{"expected":"15","output":"TypeError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        combiner(term(n), accumulate(combiner, base, n-1, term))        <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    combiner(term(n), accumulate(combiner, base, n-1, term))","TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK)))), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":87,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":5,"tests":[{"expected":"26","output":"15","input":"accumulate(add, 11, 5, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    x=base\n    for i in range(1,n+1):\n        x=combiner(x,term(i))\n    return x\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n    x = base =>           \r\n    x = 0    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = base\r\n    for i in range(1, n+1):\r\n        x = combiner(x, term(i))\r\n    return x","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = base\r\n    for i in range(1, n+1):\r\n        x = combiner(x, term(i))\r\n    return x","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[2,1,2,8,3,72],[0,1,0,2,0,3,0]],"print accumulate(add, 11, 5, identity)":[[11,1,12,2,14,3,17,4,21,5,26],[0,1,2,3,6,4,10,5,15]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,1,12,2,16,3,25],[0,1,2,5,3,14]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = 0\r\n    for i in range(1, n+1):\r\n        x = combiner(x, term(i))\r\n    return x","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[2,1,2,8,3,72],[0,1,0,2,0,3,0]],"print accumulate(add, 11, 5, identity)":[[11,1,12,2,14,3,17,4,21,5,26],[0,1,2,3,6,4,10,5,15]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,1,12,2,16,3,25],[0,1,2,5,3,14]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"15\n","print accumulate(add, 11, 0, identity)":"0\n","print accumulate(add, 11, 3, square)":"14\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = base\n    for i in range (1, n+1):\n        x = combiner(x, term(i))\n    return x\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    x=0\n    for i in range(1,n+1):\n        x=combiner(x,term(i))\n    return x\n"},{"Id":89,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":0,"tests":[{"expected":"15","output":"14","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"25\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"24\n","print accumulate(add, 0, 5, identity)":"14\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":92,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    if n == 1 or n == 0: =>           \r\n    if n == 1:           <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94,-95,-96,-97,-98,-99,-100,-101,-102,-103,-104,-105,-106,-107,-108,-109,-110,-111,-112,-113,-114,-115,-116,-117,-118,-119,-120,-121,-122,-123,-124,-125,-126,-127,-128,-129,-130,-131,-132,-133,-134,-135,-136,-137,-138,-139,-140,-141,-142,-143,-144,-145,-146,-147,-148,-149,-150,-151,-152,-153,-154,-155,-156,-157,-158,-159,-160,-161,-162]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94,-95,-96,-97,-98,-99,-100,-101,-102,-103,-104,-105,-106,-107,-108,-109,-110,-111,-112,-113,-114,-115,-116,-117,-118,-119,-120,-121,-122,-123,-124,-125,-126,-127,-128,-129,-130,-131,-132,-133,-134,-135,-136,-137,-138,-139,-140,-141,-142,-143,-144,-145,-146,-147,-148,-149,-150,-151,-152,-153,-154,-155,-156,-157,-158,-159,-160,-161,-162]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # def helper(i):\n    #     if i == n:\n    #         return \n    #     else:\n    #         return \n    # return helper(1)\n    if n == 1 or n == 0:\n        return combiner(base, term(n))  \n    else:\n        return combiner(accumulate(combiner, base, n - 1, term), term(n))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n"},{"Id":93,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":21,"tests":[{"expected":"15","output":"1","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    while n>0:\n        total=base\n        base=combiner(total,term(n))\n        n=n-1\n    return base\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    total = base     =>           \r\n        total = base <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    while n>0:\r\n        total = base\r\n        base = combiner(total, term(n))\r\n        n = n-1\r\n    return base","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    while n>0:\r\n        total = base\r\n        base = combiner(total, term(n))\r\n        n = n-1\r\n    return base","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26],[11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15],[0]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[2,18,2,8,2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25],[11,16,11,15,11,14,11,13,11,12]],"print accumulate(add, 11, 3, square)":[[11,20,24],[11,20,11,15,11,12]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14],[0,5,0,4,0,3,0,2,0,1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    while n>0:\r\n        total = base\r\n        total = combiner(total, term(n))\r\n        n = n-1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26],[11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15],[0]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[2,18,2,8,2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25],[11,16,11,15,11,14,11,13,11,12]],"print accumulate(add, 11, 3, square)":[[11,20,24],[11,20,11,15,11,12]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14],[0,5,0,4,0,3,0,2,0,1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"12\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"12\n","print accumulate(add, 0, 5, identity)":"1\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    if n == 0:\n        return base\n    total = base    \n    while n > 0:\n        \n        total = combiner(total ,term(n))\n        n =  n-1\n    return total\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    while n>0:\n        total=base\n        total=combiner(total,term(n))\n        n=n-1\n    return total\n"},{"Id":94,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":17,"tests":[{"expected":"15","output":"25","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    i=0\n    while i<n:\n        i+=1\n        total=combiner(total,term(i))\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n        total=combiner(total,term(i)) =>           \r\n        total=combiner(total,term(n)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 0\r\n    while i<n:\r\n        i += 1\r\n        total = combiner(total, term(i))\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 0\r\n    while i<n:\r\n        i += 1\r\n        total = combiner(total, term(i))\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,18,162,1458]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,16,21,26,31,36]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,20,29,38]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,5,10,15,20,25]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 0\r\n    while i<n:\r\n        i += 1\r\n        total = combiner(total, term(n))\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,18,162,1458]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,16,21,26,31,36]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,20,29,38]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,5,10,15,20,25]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"1458\n","print accumulate(add, 11, 5, identity)":"36\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"38\n","print accumulate(add, 0, 5, identity)":"25\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=base\n    i=0\n    while i<n:\n        i+=1\n        total=combiner(total,term(i))\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    i=0\n    while i<n:\n        i+=1\n        total=combiner(total,term(n))\n    return total\n"},{"Id":95,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":0,"tests":[{"expected":"15","output":"14","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    for x in range(1,n+1):\n        base=combiner(base,term(x))\n    return base\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    for x in range(1, n + 1):          =>           \r\n    return accumulate(add, 0, n, term) =>           \r\n    return accumulate(mul, 1, n, term) =>           \r\n    for x in range(2, n + 1):          <=           \r\n    return _______                     <=           \r\n    return _______                     <=           \r\n    \"*** YOUR CODE HERE ***\"           <=           \r\n    \"*** YOUR CODE HERE ***\"           <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    for x in range(1, n+1):\r\n        base = combiner(base, term(x))\r\n    return base","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    for x in range(1, n+1):\r\n        base = combiner(base, term(x))\r\n    return base","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,13,16,20,25]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,15,24]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,2,5,9,14]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    for x in range(2, n+1):\r\n        base = combiner(base, term(x))\r\n    return base","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"base":{"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,13,16,20,25]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,15,24]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,2,5,9,14]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"25\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"24\n","print accumulate(add, 0, 5, identity)":"14\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    for x in range(1, n + 1):\n        base = combiner(base, term(x))\n    return base\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    for x in range(2,n+1):\n        base=combiner(base,term(x))\n    return base\n"},{"Id":96,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":0,"tests":[{"expected":"15","output":"14","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"25\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"24\n","print accumulate(add, 0, 5, identity)":"14\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"if combiner == mul:\n        return base * product(n, term)\n    elif combiner == add:\n        return base + summation(n, term)\"\"\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n    \n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":97,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":22,"tests":[{"expected":"15","output":"9","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), term(n-1))                             <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), term(n-1))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","9","","# Error: expected","#     15","# but got","#     9","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"36\n","print accumulate(add, 11, 5, identity)":"9\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"13\n","print accumulate(add, 0, 5, identity)":"9\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),term(n-1))\n"},{"Id":104,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def f(x):\n        if x==0:\n            return base\n        else:\n            return combiner(f(x-1),term(x))\n    return f(n)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                                                SideIndicator\r\n-----------                                                                                -------------\r\n    \"\"\"def f(x):                                                                           =>           \r\n    return f(n)\"\"\"                                                                         =>           \r\n    s=base                                                                                 =>           \r\n    return s                                                                               =>           \r\n    return accumulate(lambda combiner:combiner if pred else lambda x,y,:x , base, n, term) =>           \r\n    def f(x):                                                                              <=           \r\n    return f(n)                                                                            <=           \r\n    \"\"\"\"s=base                                                                             <=           \r\n    return s\"\"\"                                                                            <=           \r\n    return _______                                                                         <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def f(x):\r\n        if x==0:\r\n            return base\r\n        else:\r\n            return combiner(f(x-1), term(x))\r\n    return f(n)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def f(x):\r\n        if x==0:\r\n            return base\r\n        else:\r\n            return combiner(f(x-1), term(x))\r\n    return f(n)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94,-95,-96,-97,-98,-99,-100,-101,-102,-103,-104,-105,-106,-107,-108,-109,-110,-111,-112,-113,-114,-115,-116,-117,-118,-119,-120,-121,-122,-123,-124,-125,-126,-127,-128,-129,-130,-131,-132,-133,-134,-135,-136,-137,-138,-139,-140,-141,-142,-143,-144,-145,-146,-147,-148,-149,-150,-151,-152,-153,-154,-155,-156,-157,-158,-159,-160,-161]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def f(x):\r\n        if x==1:\r\n            return base+term(1)\r\n        else:\r\n            return combiner(f(x-1), term(x))\r\n    return f(n)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f","    return combiner(f(x-1),term(x))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f","    return combiner(f(x-1),term(x))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f","    return combiner(f(x-1),term(x))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f","    return combiner(f(x-1),term(x))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f","    return combiner(f(x-1),term(x))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f","    return combiner(f(x-1),term(x))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 79, in f","    if x==1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast)))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94,-95,-96,-97,-98,-99,-100,-101,-102,-103,-104,-105,-106,-107,-108,-109,-110,-111,-112,-113,-114,-115,-116,-117,-118,-119,-120,-121,-122,-123,-124,-125,-126,-127,-128,-129,-130,-131,-132,-133,-134,-135,-136,-137,-138,-139,-140,-141,-142,-143,-144,-145,-146,-147,-148,-149,-150,-151,-152,-153,-154,-155,-156,-157,-158,-159,-160,-161]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"108\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"def f(x):\n        if x==1:\n            return base+term(1)\n        else: \n            return combiner(f(x-1),term(x))\n    return f(n)\"\"\"\n    s=base\n    for i in range(1,n+1):\n        s=combiner(s,term(i))\n    return s\n    \n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def f(x):\n        if x==1:\n            return base+term(1)\n        else:\n            return combiner(f(x-1),term(x))\n    return f(n)\n"},{"Id":105,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":23,"tests":[{"expected":"72","output":"36","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    i=1\n    if combiner==add:\n        total=base\n        while i<=n:\n            x=combiner(total,term(i))\n            total=x\n            i+=1\n    else:\n        total=base\n        while i<=n:\n            x=combiner(total,term(i))\n            total=x\n            i+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        total = base =>           \r\n        total = 1    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    if combiner==add:\r\n        total = base\r\n        while i<=n:\r\n            x = combiner(total, term(i))\r\n            total = x\r\n            i += 1\r\n    else:\r\n        total = base\r\n        while i<=n:\r\n            x = combiner(total, term(i))\r\n            total = x\r\n            i += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    if combiner==add:\r\n        total = base\r\n        while i<=n:\r\n            x = combiner(total, term(i))\r\n            total = x\r\n            i += 1\r\n    else:\r\n        total = base\r\n        while i<=n:\r\n            x = combiner(total, term(i))\r\n            total = x\r\n            i += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[1,4,36]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,8,3,72],[1,2,4,3,36]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    if combiner==add:\r\n        total = base\r\n        while i<=n:\r\n            x = combiner(total, term(i))\r\n            total = x\r\n            i += 1\r\n    else:\r\n        total = 1\r\n        while i<=n:\r\n            x = combiner(total, term(i))\r\n            total = x\r\n            i += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","36","","# Error: expected","#     72","# but got","#     36","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[1,4,36]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,8,3,72],[1,2,4,3,36]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"36\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    if combiner ==add:\n        total = base\n        while i <= n:\n            x = combiner(total,term(i))\n            total = x\n            i+=1\n    else:\n        total = base\n        while i <= n:\n            x = combiner(total,term(i))\n            total = x\n            i+=1\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    i=1\n    if combiner==add:\n        total=base\n        while i<=n:\n            x=combiner(total,term(i))\n            total=x\n            i+=1\n    else:\n        total=1\n        while i<=n:\n            x=combiner(total,term(i))\n            total=x\n            i+=1\n    return total\n"},{"Id":106,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                                       SideIndicator\r\n-----------                                                                       -------------\r\n    if n == 0:                                                                    =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))           =>           \r\n        \"\"\"                                                                       =>           \r\n    total, k = base, 1                                                            =>           \r\n    return total\"\"\"                                                               =>           \r\n    return accumulate(lambda b,a: combiner(b,a) if pred(a) else b, base, n, term) =>           \r\n    \"\"\"if n == 0:                                                                 <=           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\"\"\"        <=           \r\n    total, k = start, 1                                                           <=           \r\n    return total                                                                  <=           \r\n    return accumulate(lambda b,a: combiner(b,a) if pred(b) else b, base, n, term) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = start, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    total, k = start, 1","NameError: name 'start' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n        \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k+1\n    return total\"\"\"  \n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (total,k)=(start,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n"},{"Id":109,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":24,"tests":[{"expected":"15","output":"7","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        total=combiner(total,term(k))\n        k+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n        k += 1 =>           \r\n        k +=k  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1,2,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1,2,4,8]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1,2,4]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1,2,4,8]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,18]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,16]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,7]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,4]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,4]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += k\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","7","","# Error: expected","#     15","# but got","#     7","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1,2,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1,2,4,8]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1,2,4]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1,2,4,8]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,18]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,16]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,7]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,4]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,4]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"8\n","print accumulate(add, 11, 5, identity)":"18\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"16\n","print accumulate(add, 0, 5, identity)":"7\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        total=combiner(total,term(k))\n        k+=k\n    return total\n"},{"Id":110,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def combine(i):\n        if i==0:\n            return combiner(base,combine(i+1))\n        elif i==n:\n            return term(i)\n        else:\n            return combiner(term(i),combine(i+1))\n    if n==0:\n        return base\n    return combine(0)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n        if n == 0:      =>           \r\n            return base =>           \r\n        elif i == 0:    =>           \r\n        elif i >= n:    =>           \r\n        if i == 0:      <=           \r\n        elif i == n:    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def combine(i):\r\n        if i==0:\r\n            return combiner(base, combine(i+1))\r\n        elif i==n:\r\n            return term(i)\r\n        else:\r\n            return combiner(term(i), combine(i+1))\r\n    if n==0:\r\n        return base\r\n    return combine(0)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def combine(i):\r\n        if i==0:\r\n            return combiner(base, combine(i+1))\r\n        elif i==n:\r\n            return term(i)\r\n        else:\r\n            return combiner(term(i), combine(i+1))\r\n    if n==0:\r\n        return base\r\n    return combine(0)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{},"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def combine(i):\r\n        if i==0:\r\n            return combiner(base, combine(i+1))\r\n        elif i==n:\r\n            return term(i)\r\n        else:\r\n            return combiner(term(i), combine(i+1))\r\n    return combine(0)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine","    return combiner(term(i), combine(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine","    return combiner(term(i), combine(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine","    return combiner(term(i), combine(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine","    return combiner(term(i), combine(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine","    return combiner(term(i), combine(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine","    return combiner(term(i), combine(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in combine","    if i == 0:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"i":{},"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def combine(i):\n        if n == 0:\n            return base\n        elif i == 0:\n            return combiner(base, combine(i+1))\n        elif i >= n:\n            return term(i)\n        else:\n            return combiner(term(i), combine(i+1))\n    return combine(0)\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def combine(i):\n        if i==0:\n            return combiner(base,combine(i+1))\n        elif i==n:\n            return term(i)\n        else:\n            return combiner(term(i),combine(i+1))\n    return combine(0)\n"},{"Id":113,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":0,"tests":[{"expected":"15","output":"14","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"25\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"24\n","print accumulate(add, 0, 5, identity)":"14\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #result = base\n    #for x in range(1, n+1):\n    #    result = combiner(result, term(x))\n    #return result\n\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\nfrom operator import add,mul\n"},{"Id":114,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":25,"tests":[{"expected":"72","output":"16","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                      SideIndicator\r\n-----------                                                      -------------\r\n    f = combiner                                                 =>           \r\n        return f(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return term(n) + accumulate(combiner, base, n-1, term)   <=           \r\n                                                                 <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return term(n)+accumulate(combiner, base, n-1, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","16","","# Error: expected","#     72","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\"))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"16\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    f = combiner\n    if n == 0:\n        return base\n    else: \n        return f(term(n), accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return term(n)+accumulate(combiner,base,n-1,term)\n"},{"Id":117,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":13,"tests":[{"expected":"11","output":"12","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (k,final_value)=(2,term(1))\n    if n==0:\n        return base\n    while k<=n:\n        final_value=combiner(final_value,term(k))\n        k+=1\n    return combiner(base,final_value)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    k, final_value = 2, term(1)\r\n    if n==0:\r\n        return base\r\n    while k<=n:\r\n        final_value = combiner(final_value, term(k))\r\n        k += 1\r\n    return combiner(base, final_value)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k, final_value = 2, term(1)\r\n    if n==0:\r\n        return base\r\n    while k<=n:\r\n        final_value = combiner(final_value, term(k))\r\n        k += 1\r\n    return combiner(base, final_value)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    k, final_value = 2, term(1)\r\n    while k<=n:\r\n        final_value = combiner(final_value, term(k))\r\n        k += 1\r\n    return combiner(base, final_value)\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"12\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    k, final_value = 2, term(1)\n    while k <= n:\n        final_value = combiner(final_value, term(k))\n        k += 1\n    return combiner(base, final_value)\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (k,final_value)=(2,term(1))\n    while k<=n:\n        final_value=combiner(final_value,term(k))\n        k+=1\n    return combiner(base,final_value)\nfrom operator import add,mul\n"},{"Id":118,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (t,i)=(base,1)\n    while i<=n:\n        t=combiner(t,term(i))\n        i+=1\n    return t\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    t, i = base, 1  =>           \r\n    t, i = start, 1 <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    t, i = base, 1\r\n    while i<=n:\r\n        t = combiner(t, term(i))\r\n        i += 1\r\n    return t","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    t, i = base, 1\r\n    while i<=n:\r\n        t = combiner(t, term(i))\r\n        i += 1\r\n    return t","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    t, i = start, 1\r\n    while i<=n:\r\n        t = combiner(t, term(i))\r\n        i += 1\r\n    return t","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    t, i = start, 1","NameError: name 'start' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    t, i = base, 1\n    while i <= n:\n            t = combiner(t, term(i))\n            i += 1\n    return t\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (t,i)=(start,1)\n    while i<=n:\n        t=combiner(t,term(i))\n        i+=1\n    return t\n"},{"Id":120,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":4,"tests":[{"expected":"15","output":"TypeError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term,pred=True):\n    if n==0:\n        return base\n    elif term(n)==False:\n        return accumulate(combiner,base,n-1,term)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                            SideIndicator\r\n-----------                                            -------------\r\ndef accumulate(combiner, base, n, term):               =>           \r\ndef accumulate(combiner, base, n, term, pred=True):    <=           \r\n    elif pred(n) == False:                             <=           \r\n        return accumulate(combiner, base, n - 1, term) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term, pred = True):\r\n    if n==0:\r\n        return base\r\n    elif term(n)==False:\r\n        return accumulate(combiner, base, n-1, term)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term, pred = True):\r\n    if n==0:\r\n        return base\r\n    elif term(n)==False:\r\n        return accumulate(combiner, base, n-1, term)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term, pred = True):\r\n    if n==0:\r\n        return base\r\n    elif pred(n)==False:\r\n        return accumulate(combiner, base, n-1, term)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    elif pred(n) == False:","TypeError: 'bool' object is not callable","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term,pred=True):\n    if n==0:\n        return base\n    elif pred(n)==False:\n        return accumulate(combiner,base,n-1,term)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":121,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":11,"tests":[{"expected":"25","output":"17","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n    if (n < 1):                                                         =>           \r\n        return accumulate(combiner, combiner(base, term(n)), n-1, term) =>           \r\n    if (n == 0):                                                        <=           \r\n        return combiner(n, accumulate(combiner, base, n-1, term))       <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    else:\r\n        return combiner(n, accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"12\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"17\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if (n < 1):\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(n,accumulate(combiner,base,n-1,term))\n"},{"Id":123,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n <= 1: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 1:\n        return combiner(term(n), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":125,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        next_acc=combiner(term(n),base)\n        return accumulate(combiner,next_acc,n-1,term)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                 SideIndicator\r\n-----------                                                 -------------\r\n        return base                                         =>           \r\n        next_base = combiner(term(n), base)                 =>           \r\n        return accumulate(combiner, next_base, n - 1, term) =>           \r\n        return acc                                          <=           \r\n        next_acc = combiner(term(n), acc)                   <=           \r\n        return accumulate(combiner, next_acc, n - 1, term)  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        next_acc = combiner(term(n), base)\r\n        return accumulate(combiner, next_acc, n-1, term)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        next_acc = combiner(term(n), base)\r\n        return accumulate(combiner, next_acc, n-1, term)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18,2],[2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26,25,23,20,16,11],[11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25,24,20,11],[11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15,14,12,9,5,0],[0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return acc\r\n    else:\r\n        next_acc = combiner(term(n), acc)\r\n        return accumulate(combiner, next_acc, n-1, term)\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    next_acc = combiner(term(n), acc)","NameError: name 'acc' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18,2],[2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26,25,23,20,16,11],[11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25,24,20,11],[11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15,14,12,9,5,0],[0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        next_base = combiner(term(n), base)\n        return accumulate(combiner, next_base, n - 1, term)\n\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return acc\n    else:\n        next_acc=combiner(term(n),acc)\n        return accumulate(combiner,next_acc,n-1,term)\nfrom operator import add,mul\n"},{"Id":127,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner((accumulate(combiner, base, n-1, term)), term(n))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner((accumulate(combiner, base, n-1, term)), term(n))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94,-95,-96,-97,-98,-99,-100,-101,-102,-103,-104,-105,-106,-107,-108,-109,-110,-111,-112,-113,-114,-115,-116,-117,-118,-119,-120,-121,-122,-123,-124,-125,-126,-127,-128,-129,-130,-131,-132,-133,-134,-135,-136,-137,-138,-139,-140,-141,-142,-143,-144,-145,-146,-147,-148,-149,-150,-151,-152,-153,-154,-155,-156,-157,-158,-159,-160,-161,-162]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner((accumulate(combiner, base, n-1, term)), term(n))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner((accumulate(combiner, base, n - 1, term)),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner((accumulate(combiner, base, n - 1, term)),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner((accumulate(combiner, base, n - 1, term)),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner((accumulate(combiner, base, n - 1, term)),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner((accumulate(combiner, base, n - 1, term)),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner((accumulate(combiner, base, n - 1, term)),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94,-95,-96,-97,-98,-99,-100,-101,-102,-103,-104,-105,-106,-107,-108,-109,-110,-111,-112,-113,-114,-115,-116,-117,-118,-119,-120,-121,-122,-123,-124,-125,-126,-127,-128,-129,-130,-131,-132,-133,-134,-135,-136,-137,-138,-139,-140,-141,-142,-143,-144,-145,-146,-147,-148,-149,-150,-151,-152,-153,-154,-155,-156,-157,-158,-159,-160,-161,-162]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1: \n        return combiner(base, term(n)) \n    else: \n        return combiner((accumulate(combiner, base, n - 1, term)),term(n))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n"},{"Id":129,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":3,"tests":[{"expected":"15","output":"0","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n                                                                        =>           \r\n                                                                        =>           \r\n        return accumulate(combiner, base, n-1, term)                    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return accumulate(combiner, base, n-1, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"11\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"11\n","print accumulate(add, 0, 5, identity)":"0\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return accumulate(combiner,base,n-1,term)\n"},{"Id":130,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":0,"tests":[{"expected":"15","output":"14","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"25\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"24\n","print accumulate(add, 0, 5, identity)":"14\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":134,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":26,"tests":[{"expected":"72","output":"18","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    accum=base\n    if base>n:\n        accum=base\n        base=0\n    for i in range(base>=1,n+1):\n        accum=combiner(accum,term(i))\n    return accum\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    for i in range(1, n+1):      =>           \r\n    for i in range(base+1, n+1): <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    accum = base\r\n    if (base>n):\r\n        accum = base\r\n        base = 0\r\n    for i in range(base>=1, n+1):\r\n        accum = combiner(accum, term(i))\r\n    return accum","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    accum = base\r\n    if (base>n):\r\n        accum = base\r\n        base = 0\r\n    for i in range(base>=1, n+1):\r\n        accum = combiner(accum, term(i))\r\n    return accum","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[0,1,2,3,4,5],[1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[0,1,2,3],[1,2,3]],"print accumulate(add, 0, 5, identity)":[[0,1,2,3,4,5],[1,2,3,4,5]]},"accum":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,18]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[0,1,2,3,4,5],[1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[0,1,2,3],[1,2,3]],"print accumulate(add, 0, 5, identity)":[[0,1,2,3,4,5],[1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    accum = base\r\n    if (base>n):\r\n        accum = base\r\n        base = 0\r\n    for i in range(base+1, n+1):\r\n        accum = combiner(accum, term(i))\r\n    return accum","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","18","","# Error: expected","#     72","# but got","#     18","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\"))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[0,1,2,3,4,5],[1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[0,1,2,3],[1,2,3]],"print accumulate(add, 0, 5, identity)":[[0,1,2,3,4,5],[1,2,3,4,5]]},"accum":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,18]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[0,1,2,3,4,5],[1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[0,1,2,3],[1,2,3]],"print accumulate(add, 0, 5, identity)":[[0,1,2,3,4,5],[1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"18\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    accum = base\n    if (base > n):\n        accum = base\n        base = 0\n    for i in range(1, n+1):\n        accum = combiner(accum,term(i))\n    return accum\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    accum=base\n    if base>n:\n        accum=base\n        base=0\n    for i in range(base+1,n+1):\n        accum=combiner(accum,term(i))\n    return accum\n"},{"Id":135,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":5,"tests":[{"expected":"26","output":"15","input":"accumulate(add, 11, 5, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        total=combiner(term(k),total)\n        k+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, k = base, 1 =>           \r\n    total, k = 0, 1    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total = combiner(term(k), total)\r\n        k += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total = combiner(term(k), total)\r\n        k += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[0,1,3,6,10,15]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[0,1,5,14]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = 0, 1\r\n    while k<=n:\r\n        total = combiner(term(k), total)\r\n        k += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[0,1,3,6,10,15]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[0,1,5,14]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"15\n","print accumulate(add, 11, 0, identity)":"0\n","print accumulate(add, 11, 3, square)":"14\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = base, 1\n    while k <= n:\n        total = combiner(term (k), total)\n        k += 1\n    return total\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (total,k)=(0,1)\n    while k<=n:\n        total=combiner(term(k),total)\n        k+=1\n    return total\n"},{"Id":136,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n == 1:      <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":137,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":12,"tests":[{"expected":"15","output":"10","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    def accu_helper(i):\n        if i==1:\n            return term(1)\n        else:\n            return combiner(term(i),accu_helper(i-1))\n    return combiner(base,accu_helper(n-0))\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                               SideIndicator\r\n-----------                                               -------------\r\n#    if n == 0:                                           =>           \r\n#        return base                                      =>           \r\n#    def accu_helper(i):                                  =>           \r\n#        if i == 1:                                       =>           \r\n#            return term(1)                               =>           \r\n#        else:                                            =>           \r\n#            return combiner(term(i), accu_helper(i - 1)) =>           \r\n#    return combiner(base, accu_helper(n - 1))            =>           \r\n    if n == 0:                                            <=           \r\n        return base                                       <=           \r\n    def accu_helper(i):                                   <=           \r\n        if i == 1:                                        <=           \r\n            return term(1)                                <=           \r\n        else:                                             <=           \r\n            return combiner(term(i), accu_helper(i - 1))  <=           \r\n    return combiner(base, accu_helper(n - 1))             <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def accu_helper(i):\r\n        if i==1:\r\n            return term(1)\r\n        else:\r\n            return combiner(term(i), accu_helper(i-1))\r\n    return combiner(base, accu_helper(n-0))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def accu_helper(i):\r\n        if i==1:\r\n            return term(1)\r\n        else:\r\n            return combiner(term(i), accu_helper(i-1))\r\n    return combiner(base, accu_helper(n-0))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[3,2,1,2,3],[2,1,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,2,3,4,5],[4,3,2,1,2,3,4]],"print accumulate(add, 11, 3, square)":[[3,2,1,2,3],[2,1,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,2,3,4,5],[4,3,2,1,2,3,4]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[2,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[4,3,2,1]],"print accumulate(add, 11, 3, square)":[[3,2,1],[2,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[4,3,2,1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def accu_helper(i):\r\n        if i==1:\r\n            return term(1)\r\n        else:\r\n            return combiner(term(i), accu_helper(i-1))\r\n    return combiner(base, accu_helper(n-1))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[3,2,1,2,3],[2,1,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,2,3,4,5],[4,3,2,1,2,3,4]],"print accumulate(add, 11, 3, square)":[[3,2,1,2,3],[2,1,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,2,3,4,5],[4,3,2,1,2,3,4]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[2,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[4,3,2,1]],"print accumulate(add, 11, 3, square)":[[3,2,1],[2,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[4,3,2,1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"8\n","print accumulate(add, 11, 5, identity)":"21\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"16\n","print accumulate(add, 0, 5, identity)":"10\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n#    if n == 0:\n#        return base\n#    def accu_helper(i):\n#        if i == 1:\n#            return term(1)\n#        else:\n#            return combiner(term(i), accu_helper(i - 1))\n#    return combiner(base, accu_helper(n - 1))\n\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    def accu_helper(i):\n        if i==1:\n            return term(1)\n        else:\n            return combiner(term(i),accu_helper(i-1))\n    return combiner(base,accu_helper(n-1))\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":139,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def after_base(combiner,n,term,i):\n        if i==n:\n            return term(n)\n        return combiner(term(i),after_base(combiner,n,term,i+1))\n    if n==0:\n        return base\n    return combiner(base,after_base(combiner,n,term,1))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        if n==0:     =>           \r\n            return 0 =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def after_base(combiner, n, term, i):\r\n        if i==n:\r\n            return term(n)\r\n        return combiner(term(i), after_base(combiner, n, term, i+1))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, after_base(combiner, n, term, 1))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def after_base(combiner, n, term, i):\r\n        if i==n:\r\n            return term(n)\r\n        return combiner(term(i), after_base(combiner, n, term, i+1))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, after_base(combiner, n, term, 1))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{},"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def after_base(combiner, n, term, i):\r\n        if i==n:\r\n            return term(n)\r\n        return combiner(term(i), after_base(combiner, n, term, i+1))\r\n    return combiner(base, after_base(combiner, n, term, 1))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base","    return combiner(term(i), after_base(combiner, n, term, i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base","    return combiner(term(i), after_base(combiner, n, term, i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base","    return combiner(term(i), after_base(combiner, n, term, i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base","    return combiner(term(i), after_base(combiner, n, term, i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base","    return combiner(term(i), after_base(combiner, n, term, i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base","    return combiner(term(i), after_base(combiner, n, term, i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in after_base","    if i==n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"i":{},"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def after_base(combiner, n, term, i):\n        if n==0:\n            return 0\n        if i==n:\n            return term(n)\n        return combiner(term(i), after_base(combiner, n, term, i+1))\n    return combiner(base, after_base(combiner, n, term, 1))\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def after_base(combiner,n,term,i):\n        if i==n:\n            return term(n)\n        return combiner(term(i),after_base(combiner,n,term,i+1))\n    return combiner(base,after_base(combiner,n,term,1))\n"},{"Id":140,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":27,"tests":[{"expected":"15","output":"5","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    k=1\n    while k<=n:\n        base=combiner(base,term(k))\n        k+=1\n    return base\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(k)) =>           \r\n        total = combiner(base, term(k))  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        base = combiner(base, term(k))\r\n        k += 1\r\n    return base","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        base = combiner(base, term(k))\r\n        k += 1\r\n    return base","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]},"total":{"print accumulate(mul, 2, 3, square)":[[2],[2,8,18]],"print accumulate(add, 11, 5, identity)":[[11],[11,12,13,14,15,16]],"print accumulate(add, 11, 3, square)":[[11],[11,12,15,20]],"print accumulate(add, 0, 5, identity)":[[0],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        total = combiner(base, term(k))\r\n        k += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]},"total":{"print accumulate(mul, 2, 3, square)":[[2],[2,8,18]],"print accumulate(add, 11, 5, identity)":[[11],[11,12,13,14,15,16]],"print accumulate(add, 11, 3, square)":[[11],[11,12,15,20]],"print accumulate(add, 0, 5, identity)":[[0],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"18\n","print accumulate(add, 11, 5, identity)":"16\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"20\n","print accumulate(add, 0, 5, identity)":"5\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k <=n:\n        total = combiner(total, term(k))\n        k+= 1\n    return total\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    k=1\n    while k<=n:\n        total=combiner(base,term(k))\n        k+=1\n    return total\n"},{"Id":142,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n8\n72\n72\n","print accumulate(add, 11, 5, identity)":"12\n14\n17\n21\n26\n26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"12\n16\n25\n25\n","print accumulate(add, 0, 5, identity)":"1\n3\n6\n10\n15\n15\n"},"group_id":20,"tests":[{"expected":"15","output":"1","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    i=0\n    while i<n:\n        total=combiner(total,term(i+1))\n        print total\n        i+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n        #print (total)               =>           \r\n    return total                     =>           \r\n        print (total)                <=           \r\n    return combiner(total, term(n))  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 0\r\n    while i<n:\r\n        total = combiner(total, term(i+1))\r\n        print(total)\r\n        i += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 0\r\n    while i<n:\r\n        total = combiner(total, term(i+1))\r\n        print(total)\r\n        i += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 0\r\n    while i<n:\r\n        total = combiner(total, term(i+1))\r\n        print(total)\r\n        i += 1\r\n    return combiner(total, term(n))\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","3","6","10","15","20","","# Error: expected","#     15","# but got","#     1","#     3","#     6","#     10","#     15","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n8\n72\n648\n","print accumulate(add, 11, 5, identity)":"12\n14\n17\n21\n26\n31\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"12\n16\n25\n34\n","print accumulate(add, 0, 5, identity)":"1\n3\n6\n10\n15\n20\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 0\n    while i < n:\n        total = combiner(total, term(i+1))\n        #term(i) = total\n        #print (total)\n        i += 1\n    return total \n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    i=0\n    while i<n:\n        total=combiner(total,term(i+1))\n        print total\n        i+=1\n    return combiner(total,term(n))\nfrom operator import add,mul\n"},{"Id":143,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n        return combiner( term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return cominer( term(n), accumulate(combiner, base, n-1, term))  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return cominer(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return cominer( term(n), accumulate(combiner, base, n-1, term))","NameError: name 'cominer' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner( term(n), accumulate(combiner, base, n-1, term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return cominer(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":144,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":5,"tests":[{"expected":"26","output":"15","input":"accumulate(add, 11, 5, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return 0    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return 0\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"15\n","print accumulate(add, 11, 0, identity)":"0\n","print accumulate(add, 11, 3, square)":"14\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else: \n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return 0\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":147,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n        return combine(accumulate(combiner, base, n-1, term), term(n))  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combine(accumulate(combiner, base, n-1, term), term(n))\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combine(accumulate(combiner, base, n-1, term), term(n))","NameError: name 'combine' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n        \nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combine(accumulate(combiner,base,n-1,term),term(n))\nfrom operator import add,mul\n"},{"Id":148,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":14,"tests":[{"expected":"15","output":"16","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    def term_recursion(n):\n        if n==1:\n            return 1\n        else:\n            return combiner(term(n),term_recursion(n-1))\n    return combiner(base,term_recursion(n))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        if n == 1:         =>           \r\n            return term(1) =>           \r\n        if n == 0:         <=           \r\n            return 1       <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def term_recursion(n):\r\n        if n==1:\r\n            return 1\r\n        else:\r\n            return combiner(term(n), term_recursion(n-1))\r\n    return combiner(base, term_recursion(n))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def term_recursion(n):\r\n        if n==1:\r\n            return 1\r\n        else:\r\n            return combiner(term(n), term_recursion(n-1))\r\n    return combiner(base, term_recursion(n))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2],[3,2,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2],[5,4,3,2,1]],"print accumulate(add, 11, 3, square)":[[3,2],[3,2,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2],[5,4,3,2,1]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,2,3],[3,2,1,0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5,4,3,2,1,0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,2,3],[3,2,1,0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5,4,3,2,1,0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def term_recursion(n):\r\n        if n==0:\r\n            return 1\r\n        else:\r\n            return combiner(term(n), term_recursion(n-1))\r\n    return combiner(base, term_recursion(n))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2],[3,2,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2],[5,4,3,2,1]],"print accumulate(add, 11, 3, square)":[[3,2],[3,2,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2],[5,4,3,2,1]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,2,3],[3,2,1,0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5,4,3,2,1,0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,2,3],[3,2,1,0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5,4,3,2,1,0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"27\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"26\n","print accumulate(add, 0, 5, identity)":"16\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    def term_recursion(n):\n        if n == 1:\n            return term(1)\n        else:\n            return combiner(term(n), term_recursion(n - 1))\n    return combiner(base, term_recursion(n))\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    def term_recursion(n):\n        if n==0:\n            return 1\n        else:\n            return combiner(term(n),term_recursion(n-1))\n    return combiner(base,term_recursion(n))\n"},{"Id":150,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":14,"tests":[{"expected":"15","output":"16","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    i=1\n    total=base\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    total = base =>           \r\n    total = 1    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    total = base\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    total = base\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[1,4,36]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[1,2,4,7,11,16]],"print accumulate(add, 11, 0, identity)":[[11],[1]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[1,2,6,15]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[1,2,4,7,11,16]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    total = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[1,4,36]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[1,2,4,7,11,16]],"print accumulate(add, 11, 0, identity)":[[11],[1]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[1,2,6,15]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[1,2,4,7,11,16]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"36\n","print accumulate(add, 11, 5, identity)":"16\n","print accumulate(add, 11, 0, identity)":"1\n","print accumulate(add, 11, 3, square)":"15\n","print accumulate(add, 0, 5, identity)":"16\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = base\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total \n   \n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    i=1\n    total=1\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n"},{"Id":152,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    base=combiner(base,term(n))\n    return accumulate(combiner,base,n-1,term)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n                    =>           \r\n                    =>           \r\n        return base =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    base = combiner(base, term(n))\r\n    return accumulate(combiner, base, n-1, term)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    base = combiner(base, term(n))\r\n    return accumulate(combiner, base, n-1, term)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(add, 11, 0, identity)":[[11],[11,10,8,5,1,-4,-10,-17,-25,-34,-44,-55,-67,-80,-94,-109,-125,-142,-160,-179,-199,-220,-242,-265,-289,-314,-340,-367,-395,-424,-454,-485,-517,-550,-584,-619,-655,-692,-730,-769,-809,-850,-892,-935,-979,-1024,-1070,-1117,-1165,-1214,-1264,-1315,-1367,-1420,-1474,-1529,-1585,-1642,-1700,-1759,-1819,-1880,-1942,-2005,-2069,-2134,-2200,-2267,-2335]]},"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    base = combiner(base, term(n))\r\n    return accumulate(combiner, base, n-1, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"base":{"print accumulate(add, 11, 0, identity)":[[11],[11,10,8,5,1,-4,-10,-17,-25,-34,-44,-55,-67,-80,-94,-109,-125,-142,-160,-179,-199,-220,-242,-265,-289,-314,-340,-367,-395,-424,-454,-485,-517,-550,-584,-619,-655,-692,-730,-769,-809,-850,-892,-935,-979,-1024,-1070,-1117,-1165,-1214,-1264,-1315,-1367,-1420,-1474,-1529,-1585,-1642,-1700,-1759,-1819,-1880,-1942,-2005,-2069,-2134,-2200,-2267,-2335]]},"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    \n    if n == 1:\n        return combiner(base, term(1))\n    \n    base = combiner(base, term(n))\n    \n    return accumulate(combiner, base, n-1, term)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    base=combiner(base,term(n))\n    return accumulate(combiner,base,n-1,term)\n"},{"Id":156,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":28,"tests":[{"expected":"72","output":"44","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def helper(func,x,combiner):\n        if n==0:\n            return base\n        elif x==n:\n            return combiner(base,func(x))\n        else:\n            return combiner(func(x),helper(term,x+1,combiner))\n    return helper(term,1,combiner)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n            return combiner(base, func(x)) =>           \r\n            return base + func(x)          <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(func, x, combiner):\r\n        if n==0:\r\n            return base\r\n        elif x==n:\r\n            return combiner(base, func(x))\r\n        else:\r\n            return combiner(func(x), helper(term, x+1, combiner))\r\n    return helper(term, 1, combiner)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(func, x, combiner):\r\n        if n==0:\r\n            return base\r\n        elif x==n:\r\n            return combiner(base, func(x))\r\n        else:\r\n            return combiner(func(x), helper(term, x+1, combiner))\r\n    return helper(term, 1, combiner)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(func, x, combiner):\r\n        if n==0:\r\n            return base\r\n        elif x==n:\r\n            return base+func(x)\r\n        else:\r\n            return combiner(func(x), helper(term, x+1, combiner))\r\n    return helper(term, 1, combiner)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","44","","# Error: expected","#     72","# but got","#     44","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\"))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"44\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    def helper(func, x, combiner):\n        if n == 0:\n            return base\n        elif x == n:\n            return combiner(base, func(x))\n        else:\n            return combiner(func(x), helper(term, x + 1, combiner)) \n    return helper(term, 1, combiner) \n   \n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def helper(func,x,combiner):\n        if n==0:\n            return base\n        elif x==n:\n            return base+func(x)\n        else:\n            return combiner(func(x),helper(term,x+1,combiner))\n    return helper(term,1,combiner)\n"},{"Id":159,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":6,"tests":[{"expected":"11","output":"0","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return base                    =>           \r\n        return 0                       <=           \r\n    if n == 1:                         <=           \r\n        return combiner(base, term(n)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return 0\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","0","","# Error: expected","#     11","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"0\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return 0\n    if n==1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":161,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":25,"tests":[{"expected":"72","output":"18","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if combiner==base or n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    if n==0:            =>           \r\n    if n==base or n==0: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if combiner==base or n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if combiner==base or n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,3]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==base or n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","18","","# Error: expected","#     72","# but got","#     18","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,3]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"18\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==base or n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":163,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n == 1:      <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":164,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    while n>=1:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    while n>=1: =>           \r\n    while n>=0: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[2,18,72,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0],[3,2,1,0,-1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1,0,-1]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1]],"print accumulate(add, 11, 3, square)":[[3,2,1,0],[3,2,1,0,-1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1,0,-1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=0:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[2,18,72,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0],[3,2,1,0,-1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1,0,-1]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1]],"print accumulate(add, 11, 3, square)":[[3,2,1,0],[3,2,1,0,-1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1,0,-1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total = base\n    while n>=1:\n        total = combiner(total,term(n))\n        n-=1\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    while n>=0:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n"},{"Id":166,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":0,"tests":[{"expected":"15","output":"14","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0 or base==1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    if n ==0:         =>           \r\n    if n ==0 or n==1: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or base==1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or base==1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or n==1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"25\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"24\n","print accumulate(add, 0, 5, identity)":"14\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n ==0:\n        return base             \n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0 or n==1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":167,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":29,"tests":[{"expected":"15","output":"13","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n==base:\n        return 1\n    else:\n        return combiner(base,accumulate(combiner,term(n),n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    elif n == 1: <=           \r\n        return 1 <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==base:\r\n        return 1\r\n    else:\r\n        return combiner(base, accumulate(combiner, term(n), n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==base:\r\n        return 1\r\n    else:\r\n        return combiner(base, accumulate(combiner, term(n), n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,9,4,1,4,9,2],[2,9,4,9,2]],"print accumulate(add, 11, 5, identity)":[[11,5,4,3,2,1,2,3,4,5,11],[11,5,4,3,2,3,4,5,11]],"print accumulate(add, 11, 3, square)":[[11,9,4,1,4,9,11],[11,9,4,9,11]],"print accumulate(add, 0, 5, identity)":[[0,5,4,3,2,1,2,3,4,5,0],[0,5,4,3,2,3,4,5,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return 1\r\n    else:\r\n        return combiner(base, accumulate(combiner, term(n), n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","13","","# Error: expected","#     15","# but got","#     13","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,9,4,1,4,9,2],[2,9,4,9,2]],"print accumulate(add, 11, 5, identity)":[[11,5,4,3,2,1,2,3,4,5,11],[11,5,4,3,2,3,4,5,11]],"print accumulate(add, 11, 3, square)":[[11,9,4,1,4,9,11],[11,9,4,9,11]],"print accumulate(add, 0, 5, identity)":[[0,5,4,3,2,1,2,3,4,5,0],[0,5,4,3,2,3,4,5,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"18\n","print accumulate(add, 11, 5, identity)":"24\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"21\n","print accumulate(add, 0, 5, identity)":"13\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    else:\n    \treturn combiner(base, accumulate(combiner, term(n), n - 1, term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n==1:\n        return 1\n    else:\n        return combiner(base,accumulate(combiner,term(n),n-1,term))\n"},{"Id":168,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":5,"tests":[{"expected":"26","output":"15","input":"accumulate(add, 11, 5, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (k,total)=(1,base)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    k, total = 1, base =>           \r\n    k, total = 1, 0    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    k, total = 1, base\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k, total = 1, base\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[0,1,3,6,10,15]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[0,1,5,14]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    k, total = 1, 0\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[0,1,3,6,10,15]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[0,1,5,14]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"15\n","print accumulate(add, 11, 0, identity)":"0\n","print accumulate(add, 11, 3, square)":"14\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k, total = 1, base\n    while k<=n:\n        total, k = combiner(total, term(k)), k+1\n    return total\n\n\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (k,total)=(1,0)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n"},{"Id":171,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":24,"tests":[{"expected":"72","output":"16","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def helper(i):\n        if n==0:\n            return base\n        else:\n            return combiner(term(i),accumulate(combiner,base,n-1,term))\n    return helper(n)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                                 SideIndicator\r\n-----------                                                                 -------------\r\n            return combiner(term(i), accumulate(combiner, base, n-1, term)) =>           \r\n            return term(i) + accumulate(combiner, base, n-1, term)          <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i):\r\n        if n==0:\r\n            return base\r\n        else:\r\n            return combiner(term(i), accumulate(combiner, base, n-1, term))\r\n    return helper(n)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i):\r\n        if n==0:\r\n            return base\r\n        else:\r\n            return combiner(term(i), accumulate(combiner, base, n-1, term))\r\n    return helper(n)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i):\r\n        if n==0:\r\n            return base\r\n        else:\r\n            return term(i)+accumulate(combiner, base, n-1, term)\r\n    return helper(n)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","16","","# Error: expected","#     72","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\"))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"16\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i):\n        if n==0:\n            return base\n        else:\n            return combiner(term(i), accumulate(combiner, base, n-1, term))\n    return helper(n)\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def helper(i):\n        if n==0:\n            return base\n        else:\n            return term(i)+accumulate(combiner,base,n-1,term)\n    return helper(n)\n"},{"Id":174,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif base==base:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n    else:\n        return combiner(base,accumulate(combiner,0,n,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    elif base==0 and n==1: =>           \r\n        return term(1)     =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif base==base:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    else:\r\n        return combiner(base, accumulate(combiner, 0, n, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif base==base:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    else:\r\n        return combiner(base, accumulate(combiner, 0, n, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2],[2,0,2]],"print accumulate(add, 11, 5, identity)":[[11],[11,0,11]],"print accumulate(add, 11, 3, square)":[[11],[11,0,11]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif base==0:\r\n        return combiner(term(n), accumulate(combiner, 0, n-1, term))\r\n    else:\r\n        return combiner(base, accumulate(combiner, 0, n, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2],[2,0,2]],"print accumulate(add, 11, 5, identity)":[[11],[11,0,11]],"print accumulate(add, 11, 3, square)":[[11],[11,0,11]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    if n==0:\n    \treturn base\n    elif base==0 and n==1:\n    \treturn term(1)\n    elif base==0:\n    \treturn combiner(term(n),accumulate(combiner,0,n-1,term))\n    else:\n    \treturn combiner(base,accumulate(combiner,0,n,term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif base==0:\n        return combiner(term(n),accumulate(combiner,0,n-1,term))\n    else:\n        return combiner(base,accumulate(combiner,0,n,term))\n"},{"Id":175,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":3,"tests":[{"expected":"15","output":"0","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return base + accumulate(combiner, base, n - 1, term)             <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return base+accumulate(combiner, base, n-1, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"8\n","print accumulate(add, 11, 5, identity)":"66\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"44\n","print accumulate(add, 0, 5, identity)":"0\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    else:\n    \treturn combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return base+accumulate(combiner,base,n-1,term)\n"},{"Id":176,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    i=1\n    while i<=n:\n        total=combiner(total,term(i))\n        i=i+1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total = combiner(c, term(i))     <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i = i+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i = i+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<=n:\r\n        total = combiner(c, term(i))\r\n        i = i+1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    total = combiner(c, term(i))","NameError: name 'c' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i =1\n    while i<=n:\n        total = combiner(total, term(i))\n        i=i+1\n    return total \n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    i=1\n    while i<=n:\n        total=combiner(c,term(i))\n        i=i+1\n    return total\n"},{"Id":178,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":26,"tests":[{"expected":"15","output":"5","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    k=1\n    while k<=n:\n        if n==0:\n            return base\n        else:\n            total=combiner(total,term(k))\n            k=k+1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n            total = combiner(total, term(k)) =>           \r\n            total = combiner(base, term(k))  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        if n==0:\r\n            return base\r\n        else:\r\n            total = combiner(total, term(k))\r\n            k = k+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        if n==0:\r\n            return base\r\n        else:\r\n            total = combiner(total, term(k))\r\n            k = k+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8,18]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,13,14,15,16]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,15,20]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        if n==0:\r\n            return base\r\n        else:\r\n            total = combiner(base, term(k))\r\n            k = k+1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8,18]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,13,14,15,16]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,15,20]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"18\n","print accumulate(add, 11, 5, identity)":"16\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"20\n","print accumulate(add, 0, 5, identity)":"5\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k <= n:\n        if n == 0:\n            return base\n        else:\n            total = combiner(total, term(k))\n            k = k + 1\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    k=1\n    while k<=n:\n        if n==0:\n            return base\n        else:\n            total=combiner(base,term(k))\n            k=k+1\n    return total\n"},{"Id":179,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":20,"tests":[{"expected":"15","output":"1","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    if n==0:\n        return base\n    else:\n        total=combiner(term(n),total)\n        return accumulate(combiner,total,n-1,term)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    total = base                          =>           \r\n        return total                      =>           \r\n    total = 0                             <=           \r\n        return base                       <=           \r\n    \"\"\"while i <= n:                      <=           \r\n        total == combiner(total, term(i)) <=           \r\n        i += 1                            <=           \r\n    return total\"\"\"                       <=           \r\n                                          <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total = combiner(term(n), total)\r\n        return accumulate(combiner, total, n-1, term)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total = combiner(term(n), total)\r\n        return accumulate(combiner, total, n-1, term)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18,2],[2,0,2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26,25,23,20,16,11],[11,5,4,3,2,1,2,3,4,5,11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25,24,20,11],[11,9,4,1,4,9,11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15,14,12,9,5,0],[0,5,4,3,2,1,2,3,4,5,0]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18],[0]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26,25,23,20,16],[0,5,0,4,0,3,0,2,0,1,0,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,20,24,25,24,20],[0,9,0,4,0,1,0,1,4,9]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15,14,12,9,5],[0,5,0,4,0,3,0,2,0,1,0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    from operator import add, mul\r\n    total = 0\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total = combiner(term(n), total)\r\n        return accumulate(combiner, total, n-1, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18,2],[2,0,2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26,25,23,20,16,11],[11,5,4,3,2,1,2,3,4,5,11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25,24,20,11],[11,9,4,1,4,9,11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15,14,12,9,5,0],[0,5,4,3,2,1,2,3,4,5,0]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18],[0]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26,25,23,20,16],[0,5,0,4,0,3,0,2,0,1,0,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,20,24,25,24,20],[0,9,0,4,0,1,0,1,4,9]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15,14,12,9,5],[0,5,0,4,0,3,0,2,0,1,0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"1\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"1\n","print accumulate(add, 0, 5, identity)":"1\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    from operator import add, mul\n    total = base\n    if n == 0:\n        return total\n    else:\n        total = combiner(term(n), total)\n        return accumulate(combiner, total, n-1, term)\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    from operator import add,mul\n    total=0\n    if n==0:\n        return base\n    else:\n        total=combiner(term(n),total)\n        return accumulate(combiner,total,n-1,term)\n"},{"Id":182,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":30,"tests":[{"expected":"73","output":"72","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def accumulater(i):\n        if n==0:\n            return base\n        if i<n:\n            return combiner(term(i),accumulater(i+1))\n        elif i==n:\n            return combiner(term(i),base)\n        return n\n    return accumulater(1)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    72      =>           \r\n    73      <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulater(i):\r\n        if n==0:\r\n            return base\r\n        if i<n:\r\n            return combiner(term(i), accumulater(i+1))\r\n        elif i==n:\r\n            return combiner(term(i), base)\r\n        return n\r\n    return accumulater(1)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulater(i):\r\n        if n==0:\r\n            return base\r\n        if i<n:\r\n            return combiner(term(i), accumulater(i+1))\r\n        elif i==n:\r\n            return combiner(term(i), base)\r\n        return n\r\n    return accumulater(1)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulater(i):\r\n        if n==0:\r\n            return base\r\n        if i<n:\r\n            return combiner(term(i), accumulater(i+1))\r\n        elif i==n:\r\n            return combiner(term(i), base)\r\n        return n\r\n    return accumulater(1)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","72","","# Error: expected","#     73","# but got","#     72","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulater(i):\n        if n == 0:\n            return base\n        if i < n:\n            return combiner(term(i), accumulater(i+1))\n        elif i == n:\n            return combiner(term(i), base)\n        return n\n    return accumulater(1)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def accumulater(i):\n        if n==0:\n            return base\n        if i<n:\n            return combiner(term(i),accumulater(i+1))\n        elif i==n:\n            return combiner(term(i),base)\n        return n\n    return accumulater(1)\n"},{"Id":183,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":12,"tests":[{"expected":"15","output":"10","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    (i,total)=(1,base)\n    while i!=n+1:\n        total=combiner(term(i),total)\n        i+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    while i != n + 1: =>           \r\n    while i != n:     <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    i, total = 1, base\r\n    while i!=n+1:\r\n        total = combiner(term(i), total)\r\n        i += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    i, total = 1, base\r\n    while i!=n+1:\r\n        total = combiner(term(i), total)\r\n        i += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,17,21]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,16]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,6,10]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,3,4]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3,4]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    i, total = 1, base\r\n    while i!=n:\r\n        total = combiner(term(i), total)\r\n        i += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,17,21]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,16]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,6,10]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,3,4]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3,4]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"8\n","print accumulate(add, 11, 5, identity)":"21\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"16\n","print accumulate(add, 0, 5, identity)":"10\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    i, total = 1, base\n    while i != n + 1:\n        total = combiner(term(i), total)\n        i+=1\n    return total\n\n\n    '''def helper(combiner, n, term):\n        if n == 2:\n            return combiner(term(2), term(1))\n        else:\n            value = helper(combiner, n - 1, term)\n            return combiner(term(n), value)\n    return combiner(helper(combiner, n, term), base)'''\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    (i,total)=(1,base)\n    while i!=n:\n        total=combiner(term(i),total)\n        i+=1\n    return total\n"},{"Id":186,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def combine(combiner,n,term):\n        if n<=1:\n            return combiner(base,term(n))\n        else:\n            return combiner(term(n),combine(combiner,n-1,term))\n    return combine(combiner,n,term)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n        if n == 0:      =>           \r\n            return base =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def combine(combiner, n, term):\r\n        if n<=1:\r\n            return combiner(base, term(n))\r\n        else:\r\n            return combiner(term(n), combine(combiner, n-1, term))\r\n    return combine(combiner, n, term)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def combine(combiner, n, term):\r\n        if n<=1:\r\n            return combiner(base, term(n))\r\n        else:\r\n            return combiner(term(n), combine(combiner, n-1, term))\r\n    return combine(combiner, n, term)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def combine(combiner, n, term):\r\n        if n==1:\r\n            return combiner(base, term(n))\r\n        else:\r\n            return combiner(term(n), combine(combiner, n-1, term))\r\n    return combine(combiner, n, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine","    return combiner(term(n), combine(combiner, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine","    return combiner(term(n), combine(combiner, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine","    return combiner(term(n), combine(combiner, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine","    return combiner(term(n), combine(combiner, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine","    return combiner(term(n), combine(combiner, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine","    return combiner(term(n), combine(combiner, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in combine","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def combine(combiner, n, term):\n        if n == 1:\n            return combiner(base, term(n))\n        if n == 0:\n            return base\n        else:\n            return combiner(term(n), combine(combiner, n-1, term))\n        \n    return combine(combiner, n, term)\n    \n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def combine(combiner,n,term):\n        if n==1:\n            return combiner(base,term(n))\n        else:\n            return combiner(term(n),combine(combiner,n-1,term))\n    return combine(combiner,n,term)\n"},{"Id":188,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":0,"tests":[{"expected":"15","output":"14","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"25\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"24\n","print accumulate(add, 0, 5, identity)":"14\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) \n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":190,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":26,"tests":[{"expected":"15","output":"5","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (k,b)=(1,base)\n    while k<=n:\n        (base,k)=(combiner(base,term(k)),k+1)\n    return base\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        b,k = combiner(b,term(k)), k+1    =>           \r\n        b,k = combiner(base,term(k)), k+1 <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    k, b = 1, base\r\n    while k<=n:\r\n        base, k = combiner(base, term(k)), k+1\r\n    return base","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k, b = 1, base\r\n    while k<=n:\r\n        base, k = combiner(base, term(k)), k+1\r\n    return base","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"b":{"print accumulate(mul, 2, 3, square)":[[2],[2,8,18]],"print accumulate(add, 11, 5, identity)":[[11],[11,12,13,14,15,16]],"print accumulate(add, 11, 3, square)":[[11],[11,12,15,20]],"print accumulate(add, 0, 5, identity)":[[0],[0,1,2,3,4,5]]},"base":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    k, b = 1, base\r\n    while k<=n:\r\n        b, k = combiner(base, term(k)), k+1\r\n    return b","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"b":{"print accumulate(mul, 2, 3, square)":[[2],[2,8,18]],"print accumulate(add, 11, 5, identity)":[[11],[11,12,13,14,15,16]],"print accumulate(add, 11, 3, square)":[[11],[11,12,15,20]],"print accumulate(add, 0, 5, identity)":[[0],[0,1,2,3,4,5]]},"base":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"18\n","print accumulate(add, 11, 5, identity)":"16\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"20\n","print accumulate(add, 0, 5, identity)":"5\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k,b = 1, base\n    while k <= n:\n        b,k = combiner(b,term(k)), k+1\n    return b\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (k,b)=(1,base)\n    while k<=n:\n        (b,k)=(combiner(base,term(k)),k+1)\n    return b\n"},{"Id":191,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    i=1\n    while i<=n:\n        total=combiner(total,term(i))\n        i=i+1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total = combiner(total, f(i))    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i = i+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i = i+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<=n:\r\n        total = combiner(total, f(i))\r\n        i = i+1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    total = combiner(total, f(i))","NameError: name 'f' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = base         \n    i = 1                  \n    while i <= n:\n        total = combiner(total, term(i))\n        i = i + 1\n    return total\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    i=1\n    while i<=n:\n        total=combiner(total,f(i))\n        i=i+1\n    return total\n"},{"Id":192,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":6,"tests":[{"expected":"11","output":"0","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    a=0\n    if n==0:\n        return base\n    while n>1:\n        b=combiner(term(n),term(n-1))\n        a+=b\n        n-=2\n    if n==1:\n        a=combiner(a,combiner(base,term(1)))\n    if n==0:\n        return a\n    return a\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        return combiner(a,base) =>           \r\n        return a                <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    a = 0\r\n    if n==0:\r\n        return base\r\n    while n>1:\r\n        b = combiner(term(n), term(n-1))\r\n        a += b\r\n        n -= 2\r\n    if n==1:\r\n        a = combiner(a, combiner(base, term(1)))\r\n    if n==0:\r\n        return a\r\n    return a","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    a = 0\r\n    if n==0:\r\n        return base\r\n    while n>1:\r\n        b = combiner(term(n), term(n-1))\r\n        a += b\r\n        n -= 2\r\n    if n==1:\r\n        a = combiner(a, combiner(base, term(1)))\r\n    if n==0:\r\n        return a\r\n    return a","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    a = 0\r\n    while n>1:\r\n        b = combiner(term(n), term(n-1))\r\n        a += b\r\n        n -= 2\r\n    if n==1:\r\n        a = combiner(a, combiner(base, term(1)))\r\n    if n==0:\r\n        return a\r\n    return a","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","0","","# Error: expected","#     11","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"0\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    a = 0\n    while n > 1:\n        b = combiner(term(n),term(n-1))\n        a += b\n        n -= 2\n    if n == 1 : \n        a = combiner(a,combiner(base, term(1)))\n    if n == 0:\n        return combiner(a,base)\n    return a\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    a=0\n    while n>1:\n        b=combiner(term(n),term(n-1))\n        a+=b\n        n-=2\n    if n==1:\n        a=combiner(a,combiner(base,term(1)))\n    if n==0:\n        return a\n    return a\n"},{"Id":195,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":26,"tests":[{"expected":"15","output":"5","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=0\n    for i in range(1,n+1):\n        base=combiner(base,term(i))\n    return base\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    total = base                         =>           \r\n        total = combiner(total, term(i)) =>           \r\n    total = 0                            <=           \r\n        total = combiner(base, term(i))  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    for i in range(1, n+1):\r\n        base = combiner(base, term(i))\r\n    return base","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    for i in range(1, n+1):\r\n        base = combiner(base, term(i))\r\n    return base","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]},"total":{"print accumulate(mul, 2, 3, square)":[[0],[0,2,8,18]],"print accumulate(add, 11, 5, identity)":[[0],[0,12,13,14,15,16]],"print accumulate(add, 11, 3, square)":[[0],[0,12,15,20]],"print accumulate(add, 0, 5, identity)":[[0],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    for i in range(1, n+1):\r\n        total = combiner(base, term(i))\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]},"total":{"print accumulate(mul, 2, 3, square)":[[0],[0,2,8,18]],"print accumulate(add, 11, 5, identity)":[[0],[0,12,13,14,15,16]],"print accumulate(add, 11, 3, square)":[[0],[0,12,15,20]],"print accumulate(add, 0, 5, identity)":[[0],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"18\n","print accumulate(add, 11, 5, identity)":"16\n","print accumulate(add, 11, 0, identity)":"0\n","print accumulate(add, 11, 3, square)":"20\n","print accumulate(add, 0, 5, identity)":"5\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n + 1):\n        total = combiner(total, term(i))\n    return total\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=0\n    for i in range(1,n+1):\n        total=combiner(base,term(i))\n    return total\n"},{"Id":197,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":17,"tests":[{"expected":"15","output":"25","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (k,total)=(1,base)\n    while n+1>k:\n        total=combiner(total,term(k))\n        k+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        total = combiner (total, term(k)) =>           \r\n                                          =>           \r\n        total = combiner (total, term(n)) <=           \r\n                                          <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    k, total = 1, base\r\n    while n+1>k:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k, total = 1, base\r\n    while n+1>k:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,18,162,1458]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,16,21,26,31,36]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,20,29,38]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,5,10,15,20,25]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    k, total = 1, base\r\n    while n+1>k:\r\n        total = combiner(total, term(n))\r\n        k += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,18,162,1458]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,16,21,26,31,36]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,20,29,38]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,5,10,15,20,25]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"1458\n","print accumulate(add, 11, 5, identity)":"36\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"38\n","print accumulate(add, 0, 5, identity)":"25\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k , total = 1 , base \n    while n + 1 > k:\n        total = combiner (total, term(k))\n        k += 1\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (k,total)=(1,base)\n    while n+1>k:\n        total=combiner(total,term(n))\n        k+=1\n    return total\n"},{"Id":198,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (t,i)=(base,1)\n    while i<=n:\n        t=combiner(t,term(i))\n        i+=1\n    return t\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    t, i = base, 1  =>           \r\n    t, i = start, 1 <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    t, i = base, 1\r\n    while i<=n:\r\n        t = combiner(t, term(i))\r\n        i += 1\r\n    return t","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    t, i = base, 1\r\n    while i<=n:\r\n        t = combiner(t, term(i))\r\n        i += 1\r\n    return t","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    t, i = start, 1\r\n    while i<=n:\r\n        t = combiner(t, term(i))\r\n        i += 1\r\n    return t","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    t, i = start, 1","NameError: name 'start' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    t, i = base, 1\n    while i <= n:\n        t = combiner(t, term(i))\n        i += 1\n    return t\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (t,i)=(start,1)\n    while i<=n:\n        t=combiner(t,term(i))\n        i+=1\n    return t\n"},{"Id":199,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n                    =>           \r\n    if n == 1:      <=           \r\n                    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":201,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":4,"tests":[{"expected":"15","output":"TypeError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    k=1\n    while k<=n:\n        total=combiner(total,term(k))\n        k+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        total = combiner(total, term(k))  =>           \r\n        total = combiner(total + term(k)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        total = combiner(total+term(k))\r\n        k += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    total = combiner(total + term(k))","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"any\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\")))))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    k=1\n    while k<=n:\n        total=combiner(total+term(k))\n        k+=1\n    return total\n"},{"Id":202,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n8\n72\n72\n","print accumulate(add, 11, 5, identity)":"12\n14\n17\n21\n26\n26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"12\n16\n25\n25\n","print accumulate(add, 0, 5, identity)":"1\n3\n6\n10\n15\n15\n"},"group_id":20,"tests":[{"expected":"15","output":"1","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        total=combiner(total,term(k))\n        k=increment(k)\n        print total\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n                     =>           \r\n        print(total) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k = increment(k)\r\n        print(total)\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k = increment(k)\r\n        print(total)\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k = increment(k)\r\n        print(total)\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","3","6","10","15","15","","# Error: expected","#     15","# but got","#     1","#     3","#     6","#     10","#     15","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n8\n72\n72\n","print accumulate(add, 11, 5, identity)":"12\n14\n17\n21\n26\n26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"12\n16\n25\n25\n","print accumulate(add, 0, 5, identity)":"1\n3\n6\n10\n15\n15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    total, k = base, 1\n\n    while k <= n:\n        total = combiner(total,term(k))\n        k = increment(k)\n        \n\n\n    return total\n\n\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        total=combiner(total,term(k))\n        k=increment(k)\n        print total\n    return total\n"},{"Id":203,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":20,"tests":[{"expected":"15","output":"1","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def total(m):\n        if m==0:\n            return base\n        else:\n            return combiner(term(m),total(m-1))\n    return total(n)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    return total(n) =>           \r\n    return total(1) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def total(m):\r\n        if m==0:\r\n            return base\r\n        else:\r\n            return combiner(term(m), total(m-1))\r\n    return total(n)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def total(m):\r\n        if m==0:\r\n            return base\r\n        else:\r\n            return combiner(term(m), total(m-1))\r\n    return total(n)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"m":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[1,0,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[1,0,1]],"print accumulate(add, 11, 0, identity)":[[0],[1,0,1]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[1,0,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[1,0,1]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[1]],"print accumulate(add, 11, 3, square)":[[3,2,1],[1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def total(m):\r\n        if m==0:\r\n            return base\r\n        else:\r\n            return combiner(term(m), total(m-1))\r\n    return total(1)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"m":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[1,0,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[1,0,1]],"print accumulate(add, 11, 0, identity)":[[0],[1,0,1]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[1,0,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[1,0,1]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[1]],"print accumulate(add, 11, 3, square)":[[3,2,1],[1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"12\n","print accumulate(add, 11, 0, identity)":"12\n","print accumulate(add, 11, 3, square)":"12\n","print accumulate(add, 0, 5, identity)":"1\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def total(m):\n        if m==0:\n            return base \n        else:\n            return combiner(term(m), total(m-1))\n    return total(n)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def total(m):\n        if m==0:\n            return base\n        else:\n            return combiner(term(m),total(m-1))\n    return total(1)\n"},{"Id":205,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":11,"tests":[{"expected":"25","output":"17","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        accumulation=accumulate(combiner,base,n-1,term)\n        if 1==1:\n            n=term(n)\n        return combiner(n,accumulation)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n        if n >= 1: =>           \r\n        if n == 1: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        accumulation = accumulate(combiner, base, n-1, term)\r\n        if 1==1:\r\n            n = term(n)\r\n        return combiner(n, accumulation)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        accumulation = accumulate(combiner, base, n-1, term)\r\n        if 1==1:\r\n            n = term(n)\r\n        return combiner(n, accumulation)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,4,3,9],[3,2,1,0,1,2,3]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,4,3,9],[3,2,1,0,1,2,3]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1]]},"accumulation":{"print accumulate(mul, 2, 3, square)":[[2,8],[2,4]],"print accumulate(add, 11, 3, square)":[[11,12,16],[11,12,14]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        accumulation = accumulate(combiner, base, n-1, term)\r\n        if n==1:\r\n            n = term(n)\r\n        return combiner(n, accumulation)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,4,3,9],[3,2,1,0,1,2,3]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,4,3,9],[3,2,1,0,1,2,3]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1]]},"accumulation":{"print accumulate(mul, 2, 3, square)":[[2,8],[2,4]],"print accumulate(add, 11, 3, square)":[[11,12,16],[11,12,14]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"12\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"17\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        accumulation = accumulate(combiner, base, n-1, term)\n        if n >= 1:\n            n = term(n)\n        return combiner(n, accumulation)\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        accumulation=accumulate(combiner,base,n-1,term)\n        if n==1:\n            n=term(n)\n        return combiner(n,accumulation)\n"},{"Id":206,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (total,x)=(base,1)\n    while x<=n:\n        (total,x)=(combiner(total,term(x)),x+1)\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, x = base, 1 =>           \r\n                       =>           \r\n    total, x = base, 0 <=           \r\n                       <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, x = base, 1\r\n    while x<=n:\r\n        total, x = combiner(total, term(x)), x+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, x = base, 1\r\n    while x<=n:\r\n        total, x = combiner(total, term(x)), x+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]],"print accumulate(add, 11, 0, identity)":[[1],[0,1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, x = base, 0\r\n    while x<=n:\r\n        total, x = combiner(total, term(x)), x+1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]],"print accumulate(add, 11, 0, identity)":[[1],[0,1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, x = base, 1\n    while x <= n:\n        total, x = combiner(total, term(x)),x+1\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (total,x)=(base,0)\n    while x<=n:\n        (total,x)=(combiner(total,term(x)),x+1)\n    return total\n"},{"Id":207,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def counter(i):\n        if i==n:\n            return term(i)\n        else:\n            return combiner(term(i),counter(i+1))\n    if n==0:\n        return base\n    return combiner(base,counter(1))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n            return combiner(term(i), counter(i+1))  =>           \r\n    if n == 0:                                      =>           \r\n        return base                                 =>           \r\n    else:                                           =>           \r\n        return combiner(base, counter(1))           =>           \r\n            return combiner(term(i), counter(i+1))  <=           \r\n    return combiner(base, counter(1))               <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def counter(i):\r\n        if i==n:\r\n            return term(i)\r\n        else:\r\n            return combiner(term(i), counter(i+1))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, counter(1))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def counter(i):\r\n        if i==n:\r\n            return term(i)\r\n        else:\r\n            return combiner(term(i), counter(i+1))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, counter(1))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{},"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def counter(i):\r\n        if i==n:\r\n            return term(i)\r\n        else:\r\n            return combiner(term(i), counter(i+1))\r\n    return combiner(base, counter(1))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter","    return combiner(term(i), counter(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter","    return combiner(term(i), counter(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter","    return combiner(term(i), counter(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter","    return combiner(term(i), counter(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter","    return combiner(term(i), counter(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter","    return combiner(term(i), counter(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in counter","    if i == n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"i":{},"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def counter(i):\n        \n        if i == n:\n            return term(i)\n        else:\n            return combiner(term(i), counter(i+1))\n    if n == 0:\n        return base\n    else:         \n        return combiner(base, counter(1))   \n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def counter(i):\n        if i==n:\n            return term(i)\n        else:\n            return combiner(term(i),counter(i+1))\n    return combiner(base,counter(1))\n"},{"Id":208,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n == 1:      <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":211,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        (total,i)=(base,1)\n        while i<=n:\n            total=combiner(term(i),total)\n            i+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n                                    =>           \r\n        total, i = base, 1          =>           \r\n        while i < n:                =>           \r\n    return combiner(term(n), total) =>           \r\n                                    <=           \r\n        total, i = 0, 1             <=           \r\n        while i <= n:               <=           \r\n    return combiner(base, total)    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total, i = base, 1\r\n        while i<=n:\r\n            total = combiner(term(i), total)\r\n            i += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total, i = base, 1\r\n        while i<=n:\r\n            total = combiner(term(i), total)\r\n            i += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[0,1,3,6,10,15]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[0,1,5,14]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total, i = 0, 1\r\n        while i<=n:\r\n            total = combiner(term(i), total)\r\n            i += 1\r\n    return combiner(base, total)\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[0,1,3,6,10,15]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[0,1,5,14]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n == 0: \n        return base\n    else: \n        total, i = base, 1\n        while i < n: \n            total = combiner(term(i), total)\n            i += 1\n    return combiner(term(n), total)\n\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        (total,i)=(0,1)\n        while i<=n:\n            total=combiner(term(i),total)\n            i+=1\n    return combiner(base,total)\nfrom operator import add,mul\n"},{"Id":212,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":5,"tests":[{"expected":"26","output":"15","input":"accumulate(add, 11, 5, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        if combiner==add:\n            return 0\n        return 0\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n            return base =>           \r\n        return base     =>           \r\n            return 0    <=           \r\n        return 0        <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        if combiner==add:\r\n            return 0\r\n        return 0\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        if combiner==add:\r\n            return 0\r\n        return 0\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        if combiner==add:\r\n            return 0\r\n        return 0\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"15\n","print accumulate(add, 11, 0, identity)":"0\n","print accumulate(add, 11, 3, square)":"14\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        if combiner == add:\n            return base\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner,base,n-1,term))\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        if combiner==add:\n            return 0\n        return 0\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":213,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":3,"tests":[{"expected":"15","output":"0","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<=0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n      return combiner (accumulate(combiner, base, n-1, term), term(n))  =>           \r\n      return accumulate(combiner, base, n-1, term)                      <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=0:\r\n        return base\r\n    else:\r\n        return accumulate(combiner, base, n-1, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"11\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"11\n","print accumulate(add, 0, 5, identity)":"0\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #create a list that has all the values until n (including n)\n    \n    if n <= 0:\n      return base\n    else:\n      return combiner (accumulate(combiner, base, n-1, term), term(n)) \n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n<=0:\n        return base\n    else:\n        return accumulate(combiner,base,n-1,term)\n"},{"Id":214,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":31,"tests":[{"expected":"72","output":"38","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def together(i):\n        if i<n:\n            return combiner(term(i),together(i+1))\n        else:\n            return term(n)\n    return combiner(together(1),base)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return combiner(together(1) , base) =>           \r\n    return together(1) + base           <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def together(i):\r\n        if i<n:\r\n            return combiner(term(i), together(i+1))\r\n        else:\r\n            return term(n)\r\n    return combiner(together(1), base)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def together(i):\r\n        if i<n:\r\n            return combiner(term(i), together(i+1))\r\n        else:\r\n            return term(n)\r\n    return combiner(together(1), base)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def together(i):\r\n        if i<n:\r\n            return combiner(term(i), together(i+1))\r\n        else:\r\n            return term(n)\r\n    return together(1)+base","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"38\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def together (i):\n        if i < n:\n            return combiner(term(i) , together (i + 1))\n        else:\n            return term(n)\n\n    return combiner(together(1) , base)\n\n\n    \n   \n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def together(i):\n        if i<n:\n            return combiner(term(i),together(i+1))\n        else:\n            return term(n)\n    return together(1)+base\n"},{"Id":215,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":26,"tests":[{"expected":"15","output":"5","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(1), accumulate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[1]],"print accumulate(add, 11, 3, square)":[[3,2,1],[1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(1), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[1]],"print accumulate(add, 11, 3, square)":[[3,2,1],[1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"16\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"14\n","print accumulate(add, 0, 5, identity)":"5\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n    \n \n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(1),accumulate(combiner,base,n-1,term))\n"},{"Id":216,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":5,"tests":[{"expected":"26","output":"15","input":"accumulate(add, 11, 5, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    i=1\n    if combiner==mul:\n        answer=base\n    else:\n        answer=base\n    while i<n+1:\n        answer=combiner(answer,term(i))\n        i+=1\n    return answer\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    answer = base       =>           \r\n    if combiner == mul: <=           \r\n        answer = 1      <=           \r\n        answer = 0      <=           \r\n    else:               <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    if combiner==mul:\r\n        answer = base\r\n    else:\r\n        answer = base\r\n    while i<(n+1):\r\n        answer = combiner(answer, term(i))\r\n        i += 1\r\n    return answer","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    if combiner==mul:\r\n        answer = base\r\n    else:\r\n        answer = base\r\n    while i<(n+1):\r\n        answer = combiner(answer, term(i))\r\n        i += 1\r\n    return answer","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"answer":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[1,4,36]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[0,1,3,6,10,15]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[0,1,5,14]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    if combiner==mul:\r\n        answer = 1\r\n    else:\r\n        answer = 0\r\n    while i<(n+1):\r\n        answer = combiner(answer, term(i))\r\n        i += 1\r\n    return answer\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"answer":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[1,4,36]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[0,1,3,6,10,15]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[0,1,5,14]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"36\n","print accumulate(add, 11, 5, identity)":"15\n","print accumulate(add, 11, 0, identity)":"0\n","print accumulate(add, 11, 3, square)":"14\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i=1\n    answer = base\n    while i < (n+1):\n        answer = combiner(answer,term(i))\n        i+=1\n    return answer\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    i=1\n    if combiner==mul:\n        answer=1\n    else:\n        answer=0\n    while i<n+1:\n        answer=combiner(answer,term(i))\n        i+=1\n    return answer\nfrom operator import add,mul\n"},{"Id":217,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":0,"tests":[{"expected":"15","output":"14","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0 or base==1:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n    total=base\n    x=1\n    if n==0:\n        return identity(base)\n    while x<=n:\n        total=combiner(total,term(x))\n        x+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    if n == 0:           =>           \r\n    if n == 0 or n == 1: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or base==1:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    total = base\r\n    x = 1\r\n    if (n==0):\r\n        return identity(base)\r\n    while x<=n:\r\n        total = combiner(total, term(x))\r\n        x += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or base==1:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    total = base\r\n    x = 1\r\n    if (n==0):\r\n        return identity(base)\r\n    while x<=n:\r\n        total = combiner(total, term(x))\r\n        x += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or n==1:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    total = base\r\n    x = 1\r\n    if (n==0):\r\n        return identity(base)\r\n    while x<=n:\r\n        total = combiner(total, term(x))\r\n        x += 1\r\n    return total\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"25\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"24\n","print accumulate(add, 0, 5, identity)":"14\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n    total = base\n    x = 1 #start at 1 to deal with the edge case when you square 0\n    if(n == 0):\n        return identity(base)\n    while x <= n: #<= because first one is adding base\n        total = combiner(total, term(x)) \n        x += 1\n    return total\n\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0 or n==1:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n    total=base\n    x=1\n    if n==0:\n        return identity(base)\n    while x<=n:\n        total=combiner(total,term(x))\n        x+=1\n    return total\nfrom operator import add,mul\n"},{"Id":218,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    k=1\n    while k<=n:\n        (base,k)=(combiner(base,term(k)),k+1)\n    return base\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n    return base    =>           \r\n    return counter <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    while k<=n:\r\n        base, k = combiner(base, term(k)), k+1\r\n    return base","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    while k<=n:\r\n        base, k = combiner(base, term(k)), k+1\r\n    return base","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    while k<=n:\r\n        base, k = combiner(base, term(k)), k+1\r\n    return counter","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate","    return counter","NameError: name 'counter' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    k = 1\n\n    while k<=n:\n\n        base, k = combiner(base,term(k)), k +1\n\n    return base\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    k=1\n    while k<=n:\n        (base,k)=(combiner(base,term(k)),k+1)\n    return counter\n"},{"Id":219,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":32,"tests":[{"expected":"","output":"72","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    for num in range(1,n+1):\n        total=combiner(total,term(num))\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    72      =>           \r\n            <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for num in range(1, n+1):\r\n        total = combiner(total, term(num))\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for num in range(1, n+1):\r\n        total = combiner(total, term(num))\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for num in range(1, n+1):\r\n        total = combiner(total, term(num))\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","72","","# Error: expected","#     ","# but got","#     72","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = base\n    for num in range(1, n + 1):\n        total = combiner(total, term(num))\n    return total\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    for num in range(1,n+1):\n        total=combiner(total,term(num))\n    return total\n"},{"Id":220,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":14,"tests":[{"expected":"15","output":"16","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1,term)) =>           \r\n        return combiner(term(n), accumulate(combiner, n, n-1,term))    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2],[2,3,2,1,2,3,2]],"print accumulate(add, 11, 5, identity)":[[11],[11,5,4,3,2,1,2,3,4,5,11]],"print accumulate(add, 11, 3, square)":[[11],[11,3,2,1,2,3,11]],"print accumulate(add, 0, 5, identity)":[[0],[0,5,4,3,2,1,2,3,4,5,0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, n, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2],[2,3,2,1,2,3,2]],"print accumulate(add, 11, 5, identity)":[[11],[11,5,4,3,2,1,2,3,4,5,11]],"print accumulate(add, 11, 3, square)":[[11],[11,3,2,1,2,3,11]],"print accumulate(add, 0, 5, identity)":[[0],[0,5,4,3,2,1,2,3,4,5,0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"36\n","print accumulate(add, 11, 5, identity)":"16\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"15\n","print accumulate(add, 0, 5, identity)":"16\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1,term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,n,n-1,term))\n"},{"Id":222,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":33,"tests":[{"expected":"11","output":"1","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return combiner(term(0),term(1))\n    else:\n        return combiner(base,accumulate(combiner,term(n),n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        return base                       =>           \r\n        return combiner(term(0), term(1)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(term(0), term(1))\r\n    else:\r\n        return combiner(base, accumulate(combiner, term(n), n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(term(0), term(1))\r\n    else:\r\n        return combiner(base, accumulate(combiner, term(n), n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0,1]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0,1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return combiner(term(0), term(1))\r\n    else:\r\n        return combiner(base, accumulate(combiner, term(n), n-1, term))\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","1","","# Error: expected","#     11","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0,1]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0,1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"1\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    \"\"\"if n<0:\n        return term(0)\n    else:\n        return combiner(base, accumulate(combiner,term(n),term(n-1),term))\"\"\"\n\n    if n == 0:\n        return base\n    else:\n        return combiner(base, accumulate(combiner, term(n), n-1, term))\n\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return combiner(term(0),term(1))\n    else:\n        return combiner(base,accumulate(combiner,term(n),n-1,term))\nfrom operator import add,mul\n"},{"Id":223,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    i=1\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total = combiner(total, f(i))    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<=n:\r\n        total = combiner(total, f(i))\r\n        i += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    total = combiner(total, f(i))","NameError: name 'f' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    i=1\n    while i<=n:\n        total=combiner(total,f(i))\n        i+=1\n    return total\n"},{"Id":225,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":9,"tests":[{"expected":"72","output":"108","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if base==1:\n        return base+term(n)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(base, term(n)) =>           \r\n        return base + term(n)          <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if base==1:\r\n        return base+term(n)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if base==1:\r\n        return base+term(n)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return base+term(n)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"108\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return base+term(n)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":227,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    counter=1\n    result=base\n    while n>0:\n        result=combiner(result,term(counter))\n        n-=1\n        counter+=1\n    return result\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    result = base   =>           \r\n    result = start  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    result = base\r\n    while n>0:\r\n        result = combiner(result, term(counter))\r\n        n -= 1\r\n        counter += 1\r\n    return result","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    result = base\r\n    while n>0:\r\n        result = combiner(result, term(counter))\r\n        n -= 1\r\n        counter += 1\r\n    return result","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"counter":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    result = start\r\n    while n>0:\r\n        result = combiner(result, term(counter))\r\n        n -= 1\r\n        counter += 1\r\n    return result","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    result = start","NameError: name 'start' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"counter":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    result = base \n    while n > 0:\n            result = combiner(result, term(counter))\n            n -= 1\n            counter += 1\n    return result \n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    counter=1\n    result=start\n    while n>0:\n        result=combiner(result,term(counter))\n        n-=1\n        counter+=1\n    return result\n"},{"Id":228,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":4,"tests":[{"expected":"15","output":"TypeError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n        return combiner(term(n),accumulate(n-1))                    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(n-1))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n),accumulate(n-1))","TypeError: accumulate() missing 3 required positional arguments: 'base', 'n', and 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(n-1))\n"},{"Id":229,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":7,"tests":[{"expected":"25","output":"135","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    for i in range(1,n+1):\n        total=combiner(total,term(i))\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total = base       =>           \r\n    total = term(base) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1):\r\n        total = combiner(total, term(i))\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1):\r\n        total = combiner(total, term(i))\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[4,16,144]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[121,122,126,135]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[11,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[11,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = term(base)\r\n    for i in range(1, n+1):\r\n        total = combiner(total, term(i))\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[4,16,144]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[121,122,126,135]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[11,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[11,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"144\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"135\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        total = combiner(total, term(i))\n    return total\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=term(base)\n    for i in range(1,n+1):\n        total=combiner(total,term(i))\n    return total\n"},{"Id":230,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":7,"tests":[{"expected":"25","output":"135","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    for i in range(1,n+1):\n        total=combiner(total,term(i))\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total = base       =>           \r\n    total = term(base) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1):\r\n        total = combiner(total, term(i))\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1):\r\n        total = combiner(total, term(i))\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[4,16,144]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[121,122,126,135]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[11,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[11,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = term(base)\r\n    for i in range(1, n+1):\r\n        total = combiner(total, term(i))\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[4,16,144]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[121,122,126,135]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[11,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[11,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"144\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"135\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        total = combiner(total, term(i))\n    return total\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=term(base)\n    for i in range(1,n+1):\n        total=combiner(total,term(i))\n    return total\n"},{"Id":231,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":34,"tests":[{"expected":"15","output":"6","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    for i in range(1,n+1):\n        total=combiner(total,term(i))\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    for i in range(1,n+1): =>           \r\n    for i in range(1,n-1): <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1):\r\n        total = combiner(total, term(i))\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1):\r\n        total = combiner(total, term(i))\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,3]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,17]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,6]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,3]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n-1):\r\n        total = combiner(total, term(i))\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","6","","# Error: expected","#     15","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,3]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,17]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,6]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,3]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"17\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"12\n","print accumulate(add, 0, 5, identity)":"6\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"def prtii(combiner,n,term):\n        if n <= 1:\n            return term(n)\n        return combiner(term(n), prtii(combiner, n-1, term))\n    return combiner(base, prtii(combiner,n,term))\"\"\"\n    total=base\n    for i in range(1,n+1):\n        total=combiner(total, term(i))\n    return total\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    for i in range(1,n-1):\n        total=combiner(total,term(i))\n    return total\n"},{"Id":236,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"1\n4\n9\n72\n","print accumulate(add, 11, 5, identity)":"1\n2\n3\n4\n5\n26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"1\n4\n9\n25\n","print accumulate(add, 0, 5, identity)":"1\n2\n3\n4\n5\n15\n"},"group_id":20,"tests":[{"expected":"15","output":"1","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    accumulate_sum=base\n    counter=1\n    while counter<=n:\n        print term(counter)\n        accumulate_sum=combiner(accumulate_sum,term(counter))\n        counter+=1\n    return accumulate_sum\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n        print (term(counter)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    accumulate_sum = base\r\n    counter = 1\r\n    while counter<=n:\r\n        print(term(counter))\r\n        accumulate_sum = combiner(accumulate_sum, term(counter))\r\n        counter += 1\r\n    return accumulate_sum","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    accumulate_sum = base\r\n    counter = 1\r\n    while counter<=n:\r\n        print(term(counter))\r\n        accumulate_sum = combiner(accumulate_sum, term(counter))\r\n        counter += 1\r\n    return accumulate_sum","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    accumulate_sum = base\r\n    counter = 1\r\n    while counter<=n:\r\n        print(term(counter))\r\n        accumulate_sum = combiner(accumulate_sum, term(counter))\r\n        counter += 1\r\n    return accumulate_sum\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","2","3","4","5","15","","# Error: expected","#     15","# but got","#     1","#     2","#     3","#     4","#     5","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"1\n4\n9\n72\n","print accumulate(add, 11, 5, identity)":"1\n2\n3\n4\n5\n26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"1\n4\n9\n25\n","print accumulate(add, 0, 5, identity)":"1\n2\n3\n4\n5\n15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n        \"\"\"\n   \n    accumulate_sum = base\n    counter = 1\n    while counter <= n:\n        accumulate_sum = combiner(accumulate_sum, term(counter))\n        counter += 1\n    return accumulate_sum\n\n  \nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    accumulate_sum=base\n    counter=1\n    while counter<=n:\n        print term(counter)\n        accumulate_sum=combiner(accumulate_sum,term(counter))\n        counter+=1\n    return accumulate_sum\nfrom operator import add,mul\n"},{"Id":237,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":6,"tests":[{"expected":"11","output":"0","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return 0    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner((accumulate(combiner, base, n-1, term)), term(n))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner((accumulate(combiner, base, n-1, term)), term(n))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return 0\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner((accumulate(combiner, base, n-1, term)), term(n))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","0","","# Error: expected","#     11","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"0\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner((accumulate(combiner, base, n-1, term)), term(n))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return 0\n    elif n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n"},{"Id":238,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":7,"tests":[{"expected":"25","output":"135","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    elif n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        return combiner(base, term(1))       =>           \r\n        return combiner(term(base), term(1)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    elif n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    elif n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[11,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[11,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    elif n==1:\r\n        return combiner(term(base), term(1))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[11,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[11,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"144\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"135\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return term(base)\n    elif n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    elif n==1:\n        return combiner(term(base),term(1))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n"},{"Id":239,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n>0:\n        if term(n):\n            return combiner(term(n),accumulate(combiner,base,n-1,term))\n    else:\n        return base\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                                 SideIndicator\r\n-----------                                                                 -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))     =>           \r\n    return _______                                                          =>           \r\n        if pred(n):                                                         <=           \r\n            return combiner(term(n), accumulate(combiner, base, n-1, term)) <=           \r\n    if not pred(n):                                                         <=           \r\n        return base                                                         <=           \r\n        return accumulate(combiner, base, n, term)                          <=           \r\n    else:                                                                   <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n>0:\r\n        if term(n):\r\n            return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    else:\r\n        return base","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n>0:\r\n        if term(n):\r\n            return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    else:\r\n        return base","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n>0:\r\n        if pred(n):\r\n            return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    else:\r\n        return base","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if pred(n):","NameError: name 'pred' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n>0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    else:\n        return base\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n>0:\n        if pred(n):\n            return combiner(term(n),accumulate(combiner,base,n-1,term))\n    else:\n        return base\n"},{"Id":240,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":0,"tests":[{"expected":"15","output":"14","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def counter(n):\n        if n==0:\n            return base\n        else:\n            return combiner(term(n),counter(n-1))\n    return counter(n)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n        if n == 0:            =>           \r\n    return counter(n)         =>           \r\n        if n == 1:            <=           \r\n    return counter(n)         <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def counter(n):\r\n        if n==0:\r\n            return base\r\n        else:\r\n            return combiner(term(n), counter(n-1))\r\n    return counter(n)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def counter(n):\r\n        if n==0:\r\n            return base\r\n        else:\r\n            return combiner(term(n), counter(n-1))\r\n    return counter(n)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def counter(n):\r\n        if n==1:\r\n            return base\r\n        else:\r\n            return combiner(term(n), counter(n-1))\r\n    return counter(n)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"25\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"24\n","print accumulate(add, 0, 5, identity)":"14\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def counter(n):\n        if n == 0:\n            return base\n        else:\n            return combiner(term(n), counter(n-1))\n    return counter(n)\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def counter(n):\n        if n==1:\n            return base\n        else:\n            return combiner(term(n),counter(n-1))\n    return counter(n)\n"},{"Id":242,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":3,"tests":[{"expected":"15","output":"0","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    k=1\n    result=base\n    while k<=n:\n        if n==n:\n            result=combiner(result,term(k))\n        k+=1\n    return result\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n        if n >= 1 :   =>           \r\n        if n == True: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    result = base\r\n    while k<=n:\r\n        if n==n:\r\n            result = combiner(result, term(k))\r\n        k += 1\r\n    return result","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    result = base\r\n    while k<=n:\r\n        if n==n:\r\n            result = combiner(result, term(k))\r\n        k += 1\r\n    return result","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"result":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    result = base\r\n    while k<=n:\r\n        if n==True:\r\n            result = combiner(result, term(k))\r\n        k += 1\r\n    return result","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"result":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"11\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"11\n","print accumulate(add, 0, 5, identity)":"0\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    result = base\n    while k <= n:\n        if n >= 1 :\n            result = combiner(result, term(k))\n        k += 1\n    return result\n\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    k=1\n    result=base\n    while k<=n:\n        if n==True:\n            result=combiner(result,term(k))\n        k+=1\n    return result\n"},{"Id":243,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":35,"tests":[{"expected":"72","output":"70","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (total,a)=(base,1)\n    while a<=n:\n        (total,a)=(combiner(total,term(a)),a+1)\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    total, a = base, 1            =>           \r\n    return total                  =>           \r\n    total, a = 1, 1               <=           \r\n    return combiner(base,total-1) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, a = base, 1\r\n    while a<=n:\r\n        total, a = combiner(total, term(a)), a+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, a = base, 1\r\n    while a<=n:\r\n        total, a = combiner(total, term(a)), a+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[1,4,36]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[1,2,4,7,11,16]],"print accumulate(add, 11, 0, identity)":[[11],[1]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[1,2,6,15]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[1,2,4,7,11,16]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, a = 1, 1\r\n    while a<=n:\r\n        total, a = combiner(total, term(a)), a+1\r\n    return combiner(base, total-1)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","70","","# Error: expected","#     72","# but got","#     70","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[1,4,36]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[1,2,4,7,11,16]],"print accumulate(add, 11, 0, identity)":[[11],[1]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[1,2,6,15]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[1,2,4,7,11,16]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"70\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, a = base, 1\n    while a <= n:\n        total, a = combiner(total,term(a)), a+1\n    return total\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (total,a)=(1,1)\n    while a<=n:\n        (total,a)=(combiner(total,term(a)),a+1)\n    return combiner(base,total-1)\n"},{"Id":244,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif base==n:\n        return term(base)\n    elif combiner==mul:\n        return combiner(base,combiner(term(n),accumulate(combiner,1,n-1,term)))\n    else:\n        return combiner(base,combiner(term(n),accumulate(combiner,0,n-1,term)))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    elif(n == 0):      =>           \r\n        return term(n) =>           \r\n    elif(i == n):      <=           \r\n        return term(i) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    elif (base==n):\r\n        return term(base)\r\n    elif (combiner==mul):\r\n        return combiner(base, combiner(term(n), accumulate(combiner, 1, n-1, term)))\r\n    else:\r\n        return combiner(base, combiner(term(n), accumulate(combiner, 0, n-1, term)))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    elif (base==n):\r\n        return term(base)\r\n    elif (combiner==mul):\r\n        return combiner(base, combiner(term(n), accumulate(combiner, 1, n-1, term)))\r\n    else:\r\n        return combiner(base, combiner(term(n), accumulate(combiner, 0, n-1, term)))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,1,2],[2]],"print accumulate(add, 11, 5, identity)":[[11,0,11],[11]],"print accumulate(add, 11, 3, square)":[[11,0,11],[11]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    elif (i==n):\r\n        return term(i)\r\n    elif (combiner==mul):\r\n        return combiner(base, combiner(term(n), accumulate(combiner, 1, n-1, term)))\r\n    else:\r\n        return combiner(base, combiner(term(n), accumulate(combiner, 0, n-1, term)))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    elif(i == n):","NameError: name 'i' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,1,2],[2]],"print accumulate(add, 11, 5, identity)":[[11,0,11],[11]],"print accumulate(add, 11, 3, square)":[[11,0,11],[11]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if(n == 0):\n        return base\n    elif(n == 0):\n        return term(n)\n    elif(combiner == mul):\n        return combiner(base, combiner(term(n), accumulate(combiner, 1, n - 1, term)))\n    else:\n        return combiner(base, combiner(term(n), accumulate(combiner, 0, n - 1, term)))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif i==n:\n        return term(i)\n    elif combiner==mul:\n        return combiner(base,combiner(term(n),accumulate(combiner,1,n-1,term)))\n    else:\n        return combiner(base,combiner(term(n),accumulate(combiner,0,n-1,term)))\n"},{"Id":245,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":26,"tests":[{"expected":"15","output":"5","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    count=1\n    final=base\n    while count<n+1:\n        base=final=combiner(base,term(count))\n        count+=1\n    return final\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        base=combiner(base,term(count))  =>           \r\n    return base                          =>           \r\n        final=combiner(base,term(count)) <=           \r\n    return final                         <=           \r\n    final=base                           <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    final = base\r\n    while count<n+1:\r\n        base = final = combiner(base, term(count))\r\n        count += 1\r\n    return final","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    final = base\r\n    while count<n+1:\r\n        base = final = combiner(base, term(count))\r\n        count += 1\r\n    return final","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]},"final":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8,18]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,13,14,15,16]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,15,20]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    final = base\r\n    while count<n+1:\r\n        final = combiner(base, term(count))\r\n        count += 1\r\n    return final","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]},"final":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8,18]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,13,14,15,16]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,15,20]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"18\n","print accumulate(add, 11, 5, identity)":"16\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"20\n","print accumulate(add, 0, 5, identity)":"5\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"count=1\n    final=base\n    if n==0:\n        return base\n    while count< n+1:\n        if combiner==add:\n            final+=term(count)\n            count+=1\n        elif combiner==mul:\n            final*=term(count)\n            count+=1\n    return final\"\"\"\n\n    count=1\n    while count< n+1:\n        base=combiner(base,term(count))\n        count+=1\n    return base \n\n    \n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    count=1\n    final=base\n    while count<n+1:\n        final=combiner(base,term(count))\n        count+=1\n    return final\n"},{"Id":246,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":3,"tests":[{"expected":"15","output":"0","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    i=n\n    if combiner==mul:\n        finalResult=1\n    elif combiner==add:\n        finalResult=0\n    while i!=0:\n        finalResult=finalProduct=combiner(finalResult,term(i))\n        i-=1\n    return combiner(finalResult,base)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        finalResult = combiner(finalResult,term(i))  =>           \r\n        finalProduct = combiner(finalResult,term(i)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = n\r\n    if combiner==mul:\r\n        finalResult = 1\r\n    elif combiner==add:\r\n        finalResult = 0\r\n    while i!=0:\r\n        finalResult = finalProduct = combiner(finalResult, term(i))\r\n        i -= 1\r\n    return combiner(finalResult, base)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = n\r\n    if combiner==mul:\r\n        finalResult = 1\r\n    elif combiner==add:\r\n        finalResult = 0\r\n    while i!=0:\r\n        finalResult = finalProduct = combiner(finalResult, term(i))\r\n        i -= 1\r\n    return combiner(finalResult, base)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"finalProduct":{"print accumulate(mul, 2, 3, square)":[[9,36],[9,4,1]],"print accumulate(add, 11, 5, identity)":[[5,9,12,14,15],[5,4,3,2,1]],"print accumulate(add, 11, 3, square)":[[9,13,14],[9,4,1]],"print accumulate(add, 0, 5, identity)":[[5,9,12,14,15],[5,4,3,2,1]]},"finalResult":{"print accumulate(mul, 2, 3, square)":[[1,9,36],[1]],"print accumulate(add, 11, 5, identity)":[[0,5,9,12,14,15],[0]],"print accumulate(add, 11, 3, square)":[[0,9,13,14],[0]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15],[0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = n\r\n    if combiner==mul:\r\n        finalResult = 1\r\n    elif combiner==add:\r\n        finalResult = 0\r\n    while i!=0:\r\n        finalProduct = combiner(finalResult, term(i))\r\n        i -= 1\r\n    return combiner(finalResult, base)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"finalProduct":{"print accumulate(mul, 2, 3, square)":[[9,36],[9,4,1]],"print accumulate(add, 11, 5, identity)":[[5,9,12,14,15],[5,4,3,2,1]],"print accumulate(add, 11, 3, square)":[[9,13,14],[9,4,1]],"print accumulate(add, 0, 5, identity)":[[5,9,12,14,15],[5,4,3,2,1]]},"finalResult":{"print accumulate(mul, 2, 3, square)":[[1,9,36],[1]],"print accumulate(add, 11, 5, identity)":[[0,5,9,12,14,15],[0]],"print accumulate(add, 11, 3, square)":[[0,9,13,14],[0]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15],[0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"11\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"11\n","print accumulate(add, 0, 5, identity)":"0\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = n\n    if combiner == mul:\n        finalResult = 1\n    elif combiner == add:\n        finalResult = 0\n    \n    while i != 0:\n        finalResult = combiner(finalResult,term(i))\n        i -= 1\n    return combiner(finalResult, base)\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    i=n\n    if combiner==mul:\n        finalResult=1\n    elif combiner==add:\n        finalResult=0\n    while i!=0:\n        finalProduct=combiner(finalResult,term(i))\n        i-=1\n    return combiner(finalResult,base)\n"},{"Id":247,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def count_comber(x,b):\n        if x==n+1:\n            return b\n        else:\n            return combiner(term(x),count_comber(x+1,b))\n    return count_comber(1,base)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                SideIndicator\r\n-----------                                                -------------\r\n    def count_comber(x):                                   =>           \r\n            return base                                    =>           \r\n            return combiner(term(x), count_comber(x+1))    =>           \r\n    return count_comber(1)                                 =>           \r\n    def count_comber(x, b):                                <=           \r\n            return combiner(base, b)                       <=           \r\n            return combiner(term(x), count_comber(x+1, b)) <=           \r\n    return count_comber(1, 0)                              <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def count_comber(x, b):\r\n        if x==n+1:\r\n            return b\r\n        else:\r\n            return combiner(term(x), count_comber(x+1, b))\r\n    return count_comber(1, base)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def count_comber(x, b):\r\n        if x==n+1:\r\n            return b\r\n        else:\r\n            return combiner(term(x), count_comber(x+1, b))\r\n    return count_comber(1, base)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"b":{"print accumulate(mul, 2, 3, square)":[[2],[0]],"print accumulate(add, 11, 5, identity)":[[11],[0]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11],[0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def count_comber(x, b):\r\n        if x==n+1:\r\n            return combiner(base, b)\r\n        else:\r\n            return combiner(term(x), count_comber(x+1, b))\r\n    return count_comber(1, 0)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))","sequence_comparison_diff":{"b":{"print accumulate(mul, 2, 3, square)":[[2],[0]],"print accumulate(add, 11, 5, identity)":[[11],[0]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11],[0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def count_comber(x):\n        if x == n+1:\n            return base\n        else:\n            return combiner(term(x), count_comber(x+1))\n    return count_comber(1)\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def count_comber(x,b):\n        if x==n+1:\n            return combiner(base,b)\n        else:\n            return combiner(term(x),count_comber(x+1,b))\n    return count_comber(1,0)\n"},{"Id":249,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":36,"tests":[{"expected":"225","output":"25","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    if n==0:\n        return base\n    while n>=1:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    25      =>           \r\n    225     <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    if n==0:\r\n        return base\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    if n==0:\r\n        return base\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    if n==0:\r\n        return base\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25","","# Error: expected","#     225","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\" \n    total = base\n    if n == 0: \n            return base  \n    while n >= 1:\n            total = combiner(total,term(n))\n            n -= 1\n    return total  \n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    if n==0:\n        return base\n    while n>=1:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n"},{"Id":251,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def first_sequence(i):\n        if i==n:\n            return term(i)\n        else:\n            return combiner(term(i),first_sequence(i+1))\n    if n==0:\n        return base\n    else:\n        return combiner(base,first_sequence(1))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                     SideIndicator\r\n-----------                                     -------------\r\n        return combiner(base,first_sequence(1)) =>           \r\n        return combiner(base,first_sequence(0)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def first_sequence(i):\r\n        if i==n:\r\n            return term(i)\r\n        else:\r\n            return combiner(term(i), first_sequence(i+1))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(base, first_sequence(1))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def first_sequence(i):\r\n        if i==n:\r\n            return term(i)\r\n        else:\r\n            return combiner(term(i), first_sequence(i+1))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(base, first_sequence(1))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3,2,1],[0,1,2,3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,4,3,2,1],[0,1,2,3,4,5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[1,2,3,2,1],[0,1,2,3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,4,3,2,1],[0,1,2,3,4,5,4,3,2,1,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def first_sequence(i):\r\n        if i==n:\r\n            return term(i)\r\n        else:\r\n            return combiner(term(i), first_sequence(i+1))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(base, first_sequence(0))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3,2,1],[0,1,2,3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,4,3,2,1],[0,1,2,3,4,5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[1,2,3,2,1],[0,1,2,3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,4,3,2,1],[0,1,2,3,4,5,4,3,2,1,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def first_sequence(i):\n        if i==n: \n            return term(i)\n        else:\n            return combiner(term(i), first_sequence(i+1))\n    if n==0:\n        return base\n    else:\n        return combiner(base,first_sequence(1))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def first_sequence(i):\n        if i==n:\n            return term(i)\n        else:\n            return combiner(term(i),first_sequence(i+1))\n    if n==0:\n        return base\n    else:\n        return combiner(base,first_sequence(0))\n"},{"Id":253,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":11,"tests":[{"expected":"25","output":"17","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        if combiner==add:\n            return term(n)+accumulate(combiner,base,n-1,term)\n        else:\n            return term(n)*accumulate(combiner,base,n-1,term)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                       SideIndicator\r\n-----------                                                       -------------\r\n            return term(n)+ accumulate(combiner, base, n-1, term) =>           \r\n            return term(n)* accumulate(combiner, base, n-1, term) =>           \r\n            return n+ accumulate(combiner, base, n-1, term)       <=           \r\n            return n* accumulate(combiner, base, n-1, term)       <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        if combiner==add:\r\n            return term(n)+accumulate(combiner, base, n-1, term)\r\n        else:\r\n            return term(n)*accumulate(combiner, base, n-1, term)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        if combiner==add:\r\n            return term(n)+accumulate(combiner, base, n-1, term)\r\n        else:\r\n            return term(n)*accumulate(combiner, base, n-1, term)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        if combiner==add:\r\n            return n+accumulate(combiner, base, n-1, term)\r\n        else:\r\n            return n*accumulate(combiner, base, n-1, term)\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"12\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"17\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0: \n        return base\n    else: \n        if combiner == add:\n            return term(n)+ accumulate(combiner, base, n-1, term)\n        else: \n            return term(n)* accumulate(combiner, base, n-1, term)\n\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        if combiner==add:\n            return n+accumulate(combiner,base,n-1,term)\n        else:\n            return n*accumulate(combiner,base,n-1,term)\nfrom operator import add,mul\n"},{"Id":256,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":11,"tests":[{"expected":"25","output":"17","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        if combiner==add:\n            return term(n)+accumulate(combiner,base,n-1,term)\n        else:\n            return term(n)*accumulate(combiner,base,n-1,term)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                        SideIndicator\r\n-----------                                                        -------------\r\n            return term(n) + accumulate(combiner, base, n-1, term) =>           \r\n            return term(n) * accumulate(combiner, base, n-1, term) =>           \r\n            return n + accumulate(combiner, base, n-1, term)       <=           \r\n            return n * accumulate(combiner, base, n-1, term)       <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        if combiner==add:\r\n            return term(n)+accumulate(combiner, base, n-1, term)\r\n        else:\r\n            return term(n)*accumulate(combiner, base, n-1, term)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        if combiner==add:\r\n            return term(n)+accumulate(combiner, base, n-1, term)\r\n        else:\r\n            return term(n)*accumulate(combiner, base, n-1, term)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        if combiner==add:\r\n            return n+accumulate(combiner, base, n-1, term)\r\n        else:\r\n            return n*accumulate(combiner, base, n-1, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"12\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"17\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        if combiner == add:\n            return term(n) + accumulate(combiner, base, n-1, term)\n        else:\n            return term(n) * accumulate(combiner, base, n-1, term)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        if combiner==add:\n            return n+accumulate(combiner,base,n-1,term)\n        else:\n            return n*accumulate(combiner,base,n-1,term)\n"},{"Id":258,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":3,"tests":[{"expected":"15","output":"0","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n        return combiner(term(n), accumulate(combiner,base, n - 1, term)) =>           \r\n        return accumulate(combiner, base, n - 1, term)                   <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return accumulate(combiner, base, n-1, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"11\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"11\n","print accumulate(add, 0, 5, identity)":"0\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner,base, n - 1, term))\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return accumulate(combiner,base,n-1,term)\n"},{"Id":260,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":3,"tests":[{"expected":"15","output":"0","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(base, accumulate(combiner, base, n-1, term))    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(base, accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-base), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(LeafWildcard(\"ReturnStatementNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"16\n","print accumulate(add, 11, 5, identity)":"66\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"44\n","print accumulate(add, 0, 5, identity)":"0\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(base,accumulate(combiner,base,n-1,term))\n"},{"Id":261,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":37,"tests":[{"expected":"15","output":"41","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        new_base=combiner(base,term(n))\n        return accumulate(combiner,new_base,n-1,term)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))  =>           \r\n        new_base = combiner(base, term(n))                               <=           \r\n        return combiner(base, accumulate(combiner, new_base, n-1, term)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        new_base = combiner(base, term(n))\r\n        return accumulate(combiner, new_base, n-1, term)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        new_base = combiner(base, term(n))\r\n        return accumulate(combiner, new_base, n-1, term)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        new_base = combiner(base, term(n))\r\n        return combiner(base, accumulate(combiner, new_base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","41","","# Error: expected","#     15","# but got","#     41","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))), InOrderSort(ast)))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2592\n","print accumulate(add, 11, 5, identity)":"96\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"56\n","print accumulate(add, 0, 5, identity)":"41\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        new_base=combiner(base,term(n))\n        return combiner(base,accumulate(combiner,new_base,n-1,term))\n"},{"Id":262,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n!=1:\n        output=accumulate(combiner,base,n-1,term)\n        return combiner(output,term(n))\n    else:\n        return combiner(base,term(1))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    if n > 1:        =>           \r\n    elif n == 1:     =>           \r\n        return base  =>           \r\n    if n != 1:       <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n!=1:\r\n        output = accumulate(combiner, base, n-1, term)\r\n        return combiner(output, term(n))\r\n    else:\r\n        return combiner(base, term(1))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n!=1:\r\n        output = accumulate(combiner, base, n-1, term)\r\n        return combiner(output, term(n))\r\n    else:\r\n        return combiner(base, term(1))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94,-95,-96,-97,-98,-99,-100,-101,-102,-103,-104,-105,-106,-107,-108,-109,-110,-111,-112,-113,-114,-115,-116,-117,-118,-119,-120,-121,-122,-123,-124,-125,-126,-127,-128,-129,-130,-131,-132,-133,-134,-135,-136,-137,-138,-139,-140,-141,-142,-143,-144,-145,-146,-147,-148,-149,-150,-151,-152,-153,-154,-155,-156,-157,-158,-159,-160,-161,-162]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n!=1:\r\n        output = accumulate(combiner, base, n-1, term)\r\n        return combiner(output, term(n))\r\n    else:\r\n        return combiner(base, term(1))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    output = accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    output = accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    output = accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    output = accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    output = accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    output = accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    if n != 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94,-95,-96,-97,-98,-99,-100,-101,-102,-103,-104,-105,-106,-107,-108,-109,-110,-111,-112,-113,-114,-115,-116,-117,-118,-119,-120,-121,-122,-123,-124,-125,-126,-127,-128,-129,-130,-131,-132,-133,-134,-135,-136,-137,-138,-139,-140,-141,-142,-143,-144,-145,-146,-147,-148,-149,-150,-151,-152,-153,-154,-155,-156,-157,-158,-159,-160,-161,-162]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n > 1:\n        output = accumulate(combiner, base, n-1, term)\n        return combiner(output, term(n))\n    elif n == 1:\n        return combiner(base, term(1))\n    else:\n        return base \n\n    \"\"\"\n    if n == 1:\n        return term(1)\n    elif n \n    else: \n        output = combiner(output, term(n))\n        return combiner(output, accumulate(combiner, base, n-1, term))\n    \"\"\"\n\n\n\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n!=1:\n        output=accumulate(combiner,base,n-1,term)\n        return combiner(output,term(n))\n    else:\n        return combiner(base,term(1))\n"},{"Id":263,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":30,"tests":[{"expected":"72","output":"38","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        result=0\n    else:\n        counter=2\n        result=term(1)\n        while counter<=n:\n            result=combiner(result,term(counter))\n            counter+=1\n    return combiner(result,base)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    return combiner(result, base) =>           \r\n    return result + base          <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        result = 0\r\n    else:\r\n        counter = 2\r\n        result = term(1)\r\n        while counter<=n:\r\n            result = combiner(result, term(counter))\r\n            counter += 1\r\n    return combiner(result, base)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        result = 0\r\n    else:\r\n        counter = 2\r\n        result = term(1)\r\n        while counter<=n:\r\n            result = combiner(result, term(counter))\r\n            counter += 1\r\n    return combiner(result, base)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        result = 0\r\n    else:\r\n        counter = 2\r\n        result = term(1)\r\n        while counter<=n:\r\n            result = combiner(result, term(counter))\r\n            counter += 1\r\n    return result+base","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"38\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        result = 0\n    else:\n        counter = 2\n        result = term(1)\n        while counter <= n:\n            result = combiner(result, term(counter))\n            counter += 1\n    return combiner(result, base)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        result=0\n    else:\n        counter=2\n        result=term(1)\n        while counter<=n:\n            result=combiner(result,term(counter))\n            counter+=1\n    return result+base\n"},{"Id":264,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":20,"tests":[{"expected":"15","output":"1","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def helper(combiner,base,n,term):\n        if n==0:\n            return base\n        elif n==1:\n            return combiner(base,term(n))\n        else:\n            return combiner(term(n),helper(combiner,base,n-1,term))\n    return helper(combiner,base,n,term)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                            SideIndicator\r\n-----------                                            -------------\r\n    if n == 0:                                         =>           \r\n        return base                                    =>           \r\n    elif n == 1:                                       =>           \r\n        return combiner(base, term(n))                 =>           \r\n        base = combiner(base, term(n))                 =>           \r\n        return accumulate(combiner, base, n - 1, term) =>           \r\n    else:                                              =>           \r\n                                                       =>           \r\n    def helper(combiner, base, n, term):               <=           \r\n        if n == 0:                                     <=           \r\n            return base                                <=           \r\n        elif n == 1:                                   <=           \r\n            return combiner(base, term(n))             <=           \r\n        else:                                          <=           \r\n            return helper(combiner, base, n - 1, term) <=           \r\n    return helper(combiner, base, n, term)             <=           \r\n                                                       <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(combiner, base, n, term):\r\n        if n==0:\r\n            return base\r\n        elif n==1:\r\n            return combiner(base, term(n))\r\n        else:\r\n            return combiner(term(n), helper(combiner, base, n-1, term))\r\n    return helper(combiner, base, n, term)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(combiner, base, n, term):\r\n        if n==0:\r\n            return base\r\n        elif n==1:\r\n            return combiner(base, term(n))\r\n        else:\r\n            return combiner(term(n), helper(combiner, base, n-1, term))\r\n    return helper(combiner, base, n, term)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[1]],"print accumulate(add, 11, 3, square)":[[3,2,1],[1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(combiner, base, n, term):\r\n        if n==0:\r\n            return base\r\n        elif n==1:\r\n            return combiner(base, term(n))\r\n        else:\r\n            return helper(combiner, base, n-1, term)\r\n    return helper(combiner, base, n, term)\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[1]],"print accumulate(add, 11, 3, square)":[[3,2,1],[1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"12\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"12\n","print accumulate(add, 0, 5, identity)":"1\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        base = combiner(base, term(n))\n        return accumulate(combiner, base, n - 1, term)\n\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def helper(combiner,base,n,term):\n        if n==0:\n            return base\n        elif n==1:\n            return combiner(base,term(n))\n        else:\n            return helper(combiner,base,n-1,term)\n    return helper(combiner,base,n,term)\nfrom operator import add,mul\n"},{"Id":268,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    def helper(combiner,n,i,term):\n        if n==1:\n            return term(1)\n        if i==n:\n            return term(n)\n        else:\n            return combiner(term(i),helper(combiner,n,i+1,term))\n    return combiner(base,helper(combiner,n,1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        elif n == 0:       =>           \r\n            return term(0) =>           \r\n        elif i == n:       =>           \r\n        if i == n:         <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def helper(combiner, n, i, term):\r\n        if n==1:\r\n            return term(1)\r\n        if i==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(i), helper(combiner, n, i+1, term))\r\n    return combiner(base, helper(combiner, n, 1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def helper(combiner, n, i, term):\r\n        if n==1:\r\n            return term(1)\r\n        if i==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(i), helper(combiner, n, i+1, term))\r\n    return combiner(base, helper(combiner, n, 1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{},"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(combiner, n, i, term):\r\n        if n==1:\r\n            return term(1)\r\n        if i==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(i), helper(combiner, n, i+1, term))\r\n    return combiner(base, helper(combiner, n, 1, term))\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(i), helper(combiner, n, i + 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(i), helper(combiner, n, i + 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(i), helper(combiner, n, i + 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(i), helper(combiner, n, i + 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(i), helper(combiner, n, i + 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(i), helper(combiner, n, i + 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in helper","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"i":{},"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(combiner, n, i, term):\n        if n == 1:\n            return term(1)\n        elif n == 0:\n            return term(0)\n        elif i == n:\n            return term(n)\n        else:\n            return combiner(term(i), helper(combiner, n, i + 1, term))\n    return combiner(base, helper(combiner, n, 1, term))\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def helper(combiner,n,i,term):\n        if n==1:\n            return term(1)\n        if i==n:\n            return term(n)\n        else:\n            return combiner(term(i),helper(combiner,n,i+1,term))\n    return combiner(base,helper(combiner,n,1,term))\nfrom operator import add,mul\n"},{"Id":269,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":38,"tests":[{"expected":"25","output":"135","input":"accumulate(add, 11, 3, square)\t "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,11]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,11]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)\t # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)\t # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,11]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,11]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"144\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"135\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n\t\"\"\"Return the result of combining the first N terms in a sequence.\tThe\n\tterms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n\ttwo-argument function.\tTreating COMBINER as if it were a binary operator,\n\tthe return value is\n\t\tBASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n\t>>> accumulate(add, 0, 5, identity)\t # 0 + 1 + 2 + 3 + 4 + 5\n\t15\n\t>>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n\t26\n\t>>> accumulate(add, 11, 0, identity) # 11\n\t11\n\t>>> accumulate(add, 11, 3, square)\t # 11 + 1^2 + 2^2 + 3^2\n\t25\n\t>>> accumulate(mul, 2, 3, square)\t# 2 * 1^2 * 2^2 * 3^2\n\t72\n\t\"\"\"\n\tif n == 0:\n\t\treturn base\n\telse:\n\t\treturn combiner(term(n), accumulate(combiner, base, n-1, term))\n\t\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":270,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":7,"tests":[{"expected":"25","output":"135","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return term(base)\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,11]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,11]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,11]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,11]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"144\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"135\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    return combiner(term(n),accumulate(combiner, base, n-1, term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":273,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(term(1),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n == 0:                         =>           \r\n        return combiner(term(0), base) =>           \r\n    elif n == 1:                       =>           \r\n    if n == 1:                         <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return combiner(term(0), base)\n    elif n == 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(term(1),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":274,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":9,"tests":[{"expected":"72","output":"108","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif base==1:\n        return term(1)+base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(term(1), base) =>           \r\n        return term(1) + base          <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif base==1:\r\n        return term(1)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif base==1:\r\n        return term(1)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return term(1)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"108\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n==1:\n        return term(1)+base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":276,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":12,"tests":[{"expected":"15","output":"10","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def helper(k,total=base):\n        if n==1:\n            return base+1\n        if k>n:\n            return total\n        if k>=1:\n            total=combiner(total,term(k))\n            return helper(k+1,total)\n    return helper(1,base)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        if k == n+1: =>           \r\n        if k == n:   <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(k, total = base):\r\n        if n==1:\r\n            return base+1\r\n        if k>n:\r\n            return total\r\n        if k>=1:\r\n            total = combiner(total, term(k))\r\n            return helper(k+1, total)\r\n    return helper(1, base)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(k, total = base):\r\n        if n==1:\r\n            return base+1\r\n        if k>n:\r\n            return total\r\n        if k>=1:\r\n            total = combiner(total, term(k))\r\n            return helper(k+1, total)\r\n    return helper(1, base)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4,3,2,1],[1,2,3,2,1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6,5,4,3,2,1],[1,2,3,4,5,4,3,2,1]],"print accumulate(add, 11, 0, identity)":[[1],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54]],"print accumulate(add, 11, 3, square)":[[1,2,3,4,3,2,1],[1,2,3,2,1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6,5,4,3,2,1],[1,2,3,4,5,4,3,2,1]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72,8,2],[2,8,2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26,21,17,14,12],[11,12,14,17,21,17,14,12]],"print accumulate(add, 11, 0, identity)":[[11],[11,12,14,17,21,26,32,39,47,56,66,77,89,102,116,131,147,164,182,201,221,242,264,287,311,336,362,389,417,446,476,507,539,572,606,641,677,714,752,791,831,872,914,957,1001,1046,1092,1139,1187,1236,1286,1337,1389,1442,1496]],"print accumulate(add, 11, 3, square)":[[11,12,16,25,16,12],[11,12,16,12]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15,10,6,3,1],[0,1,3,6,10,6,3,1]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,3,4]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3,4]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(k, total = base):\r\n        if n==1:\r\n            return base+1\r\n        if k==n:\r\n            return total\r\n        if k>=1:\r\n            total = combiner(total, term(k))\r\n            return helper(k+1, total)\r\n    return helper(1, base)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThan, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4,3,2,1],[1,2,3,2,1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6,5,4,3,2,1],[1,2,3,4,5,4,3,2,1]],"print accumulate(add, 11, 0, identity)":[[1],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54]],"print accumulate(add, 11, 3, square)":[[1,2,3,4,3,2,1],[1,2,3,2,1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6,5,4,3,2,1],[1,2,3,4,5,4,3,2,1]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72,8,2],[2,8,2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26,21,17,14,12],[11,12,14,17,21,17,14,12]],"print accumulate(add, 11, 0, identity)":[[11],[11,12,14,17,21,26,32,39,47,56,66,77,89,102,116,131,147,164,182,201,221,242,264,287,311,336,362,389,417,446,476,507,539,572,606,641,677,714,752,791,831,872,914,957,1001,1046,1092,1139,1187,1236,1286,1337,1389,1442,1496]],"print accumulate(add, 11, 3, square)":[[11,12,16,25,16,12],[11,12,16,12]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15,10,6,3,1],[0,1,3,6,10,6,3,1]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,3,4]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3,4]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"8\n","print accumulate(add, 11, 5, identity)":"21\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"16\n","print accumulate(add, 0, 5, identity)":"10\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(k,total=base):\n        if n==1:\n            return base + 1\n        if k == n+1:\n            return total\n        if k >= 1: \n            total = combiner(total,term(k))\n            return helper(k+1,total)\n    return helper(1,base)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def helper(k,total=base):\n        if n==1:\n            return base+1\n        if k==n:\n            return total\n        if k>=1:\n            total=combiner(total,term(k))\n            return helper(k+1,total)\n    return helper(1,base)\n"},{"Id":279,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":11,"tests":[{"expected":"25","output":"17","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return combiner(n, accumulate(combiner, base, n - 1, term))       <=           \r\n    \"*** YOUR CODE HERE ***\"                                              <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(n, accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"12\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"17\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(n,accumulate(combiner,base,n-1,term))\n"},{"Id":281,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":7,"tests":[{"expected":"25","output":"135","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    while n>=1:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total = base       =>           \r\n    return total       =>           \r\n    total = term(base) <=           \r\n    return total       <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[4,36,144]],"print accumulate(add, 11, 3, square)":[[11,20,24,25],[121,130,134,135]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[2,3,2,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[11,5,4,3,2,1]],"print accumulate(add, 11, 3, square)":[[3,2,1],[11,3,2,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[0,5,4,3,2,1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = term(base)\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[4,36,144]],"print accumulate(add, 11, 3, square)":[[11,20,24,25],[121,130,134,135]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[2,3,2,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[11,5,4,3,2,1]],"print accumulate(add, 11, 3, square)":[[3,2,1],[11,3,2,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[0,5,4,3,2,1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"144\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"135\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    while n >= 1:\n        total = combiner(total, term(n))\n        n-=1\n    return total\n\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=term(base)\n    while n>=1:\n        total=combiner(total,term(n))\n        n-=1\n    return total\nfrom operator import add,mul\n"},{"Id":282,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":3,"tests":[{"expected":"15","output":"0","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        base=combiner(term(n),base)\n        return accumulate(combiner,base,n-1,term)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n        base = combiner(term(n), base)  =>           \r\n    assert n>=0                         =>           \r\n    assert n>0                          =>           \r\n        start = combiner(term(n), base) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        base = combiner(term(n), base)\r\n        return accumulate(combiner, base, n-1, term)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        base = combiner(term(n), base)\r\n        return accumulate(combiner, base, n-1, term)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18],[2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26,25,23,20,16],[11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25,24,20],[11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15,14,12,9,5],[0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        start = combiner(term(n), base)\r\n        return accumulate(combiner, base, n-1, term)\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18],[2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26,25,23,20,16],[11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25,24,20],[11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15,14,12,9,5],[0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"11\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"11\n","print accumulate(add, 0, 5, identity)":"0\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        base = combiner(term(n), base)\n        return accumulate(combiner, base, n-1, term)\n\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        start=combiner(term(n),base)\n        return accumulate(combiner,base,n-1,term)\nfrom operator import add,mul\n"},{"Id":283,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=combiner(base,term(n))\n    k=1\n    while n>=k+1:\n        total=combiner(total,term(n-1))\n        n-=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    while n>k:  =>           \r\n    while n>=k: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = combiner(base, term(n))\r\n    k = 1\r\n    while n>=k+1:\r\n        total = combiner(total, term(n-1))\r\n        n -= 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = combiner(base, term(n))\r\n    k = 1\r\n    while n>=k+1:\r\n        total = combiner(total, term(n-1))\r\n        n -= 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[18,72],[18,72,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = combiner(base, term(n))\r\n    k = 1\r\n    while n>=k:\r\n        total = combiner(total, term(n-1))\r\n        n -= 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[18,72],[18,72,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total=combiner(base,term(n))\n    k=1\n    while n>k:\n        total=combiner(total, term(n-1))\n        n-=1\n    return total\n    \"\"\"if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(base,accumulate(combiner,base,n-1,term))\n    k=1\n    total=base+term(k)\n    if n==0:\n        return base\n    while k<n:\n        total=combiner(total, term(k+1))\n        k+=1\n    return total\"\"\"    \n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=combiner(base,term(n))\n    k=1\n    while n>=k:\n        total=combiner(total,term(n-1))\n        n-=1\n    return total\n"},{"Id":284,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":11,"tests":[{"expected":"25","output":"17","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(n, accumulate(combiner, base, n-1, term))       <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(n, accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"12\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"17\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(n,accumulate(combiner,base,n-1,term))\n"},{"Id":286,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":17,"tests":[{"expected":"15","output":"25","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    answer=base\n    for n in range(1,n+1):\n        answer=combiner(answer,term(n))\n    return answer\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        answer = combiner(answer,term(i)) =>           \r\n        answer = combiner(answer,term(n)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    answer = base\r\n    for n in range(1, n+1):\r\n        answer = combiner(answer, term(n))\r\n    return answer","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    answer = base\r\n    for n in range(1, n+1):\r\n        answer = combiner(answer, term(n))\r\n    return answer","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"answer":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,18,162,1458]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,16,21,26,31,36]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,20,29,38]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,5,10,15,20,25]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    answer = base\r\n    for i in range(1, n+1):\r\n        answer = combiner(answer, term(n))\r\n    return answer","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"answer":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,18,162,1458]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,16,21,26,31,36]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,20,29,38]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,5,10,15,20,25]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"1458\n","print accumulate(add, 11, 5, identity)":"36\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"38\n","print accumulate(add, 0, 5, identity)":"25\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    answer = base\n    for i in range(1,n+1):\n        answer = combiner(answer,term(i))\n    return answer\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    answer=base\n    for i in range(1,n+1):\n        answer=combiner(answer,term(n))\n    return answer\n"},{"Id":287,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":9,"tests":[{"expected":"72","output":"108","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if base==1:\n        return term(n)+base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    if n==1:                  <=           \r\n        return term(n) + base <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if base==1:\r\n        return term(n)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if base==1:\r\n        return term(n)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return term(n)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"108\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return term(n)+base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":289,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":14,"tests":[{"expected":"15","output":"16","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    ret=base\n    for i in range(1,n+1,1):\n        ret=combiner(ret,term(i))\n    return ret\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                                   SideIndicator\r\n-----------                                                                   -------------\r\ndef accumulate(combiner, base, n, term):###############                       =>           \r\n    total, i = base, 1                                                        =>           \r\n    while i <= n:                                                             =>           \r\n        total, i = combiner(total, term(i)) , i+1                             =>           \r\n    return total                                                              =>           \r\ndef summation_using_accumulate(n, term):##############                        =>           \r\ndef filtered_accumulate(combiner, base, pred, n, term):###################### =>           \r\ndef accumulate(combiner, base, n, term):                                      <=           \r\n    ret = 1                                                                   <=           \r\n    for i in range(1, n + 1, 1):                                              <=           \r\n        ret = combiner(ret, term(i))                                          <=           \r\n    return ret                                                                <=           \r\ndef summation_using_accumulate(n, term):                                      <=           \r\ndef filtered_accumulate(combiner, base, pred, n, term):                       <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    ret = base\r\n    for i in range(1, n+1, 1):\r\n        ret = combiner(ret, term(i))\r\n    return ret","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    ret = base\r\n    for i in range(1, n+1, 1):\r\n        ret = combiner(ret, term(i))\r\n    return ret","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"ret":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[1,4,36]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[1,2,4,7,11,16]],"print accumulate(add, 11, 0, identity)":[[11],[1]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[1,2,6,15]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[1,2,4,7,11,16]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    ret = 1\r\n    for i in range(1, n+1, 1):\r\n        ret = combiner(ret, term(i))\r\n    return ret","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"ret":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[1,4,36]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[1,2,4,7,11,16]],"print accumulate(add, 11, 0, identity)":[[11],[1]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[1,2,6,15]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[1,2,4,7,11,16]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"36\n","print accumulate(add, 11, 5, identity)":"16\n","print accumulate(add, 11, 0, identity)":"1\n","print accumulate(add, 11, 3, square)":"15\n","print accumulate(add, 0, 5, identity)":"16\n"},"after":"def accumulate(combiner, base, n, term):###############\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, i = base, 1\n    while i <= n:\n        total, i = combiner(total, term(i)) , i+1\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    ret=1\n    for i in range(1,n+1,1):\n        ret=combiner(ret,term(i))\n    return ret\n"},{"Id":292,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":20,"tests":[{"expected":"15","output":"1","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    while n>=1:\n        base=combiner(base,term(n))\n        n-=1\n    return base\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        base = combiner(base, term(n)) =>           \r\n    return base                        =>           \r\n        num = combiner(base, term(n))  <=           \r\n    return num                         <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    while n>=1:\r\n        base = combiner(base, term(n))\r\n        n -= 1\r\n    return base","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    while n>=1:\r\n        base = combiner(base, term(n))\r\n        n -= 1\r\n    return base","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26],[11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15],[0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    while n>=1:\r\n        num = combiner(base, term(n))\r\n        n -= 1\r\n    return num","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26],[11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15],[0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"12\n","print accumulate(add, 11, 0, identity)":"","print accumulate(add, 11, 3, square)":"12\n","print accumulate(add, 0, 5, identity)":"1\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while n >= 1:\n        base = combiner(base, term(n))\n        n -= 1\n    return base\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    while n>=1:\n        num=combiner(base,term(n))\n        n-=1\n    return num\n"},{"Id":295,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":39,"tests":[{"expected":"26","output":"81","input":"accumulate(add, 11, 5, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    result=combiner(base,term(n))\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n                                                                    =>           \r\n        return base                                                 =>           \r\n        return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n    result = combiner(base,term(n))                                 <=           \r\n        return result                                               <=           \r\n        return combiner(result,accumulate(combiner,base,n-1,term))  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = combiner(base, term(n))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = combiner(base, term(n))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = combiner(base, term(n))\r\n    if n==0:\r\n        return result\r\n    else:\r\n        return combiner(result, accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","81","","# Error: expected","#     26","# but got","#     81","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-base), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(LeafWildcard(\"ReturnStatementNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"81\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"58\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    \n    if n==0:\n    \treturn base\n\n    else:\n    \treturn combiner(term(n),accumulate(combiner,base,n-1,term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    result=combiner(base,term(n))\n    if n==0:\n        return result\n    else:\n        return combiner(result,accumulate(combiner,base,n-1,term))\n"},{"Id":296,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def accumulateHelp(count):\n        if count==n+1:\n            return base\n        return combiner(term(count),accumulateHelp(count+1))\n    return accumulateHelp(1)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n    if n==0:                                                           =>           \r\n        return base                                                    =>           \r\n        return combiner(term(n),accumulate(combiner, base, n-1, term)) =>           \r\n    else:                                                              =>           \r\n    def accumulateHelp(count):                                         <=           \r\n        if count==n+1:                                                 <=           \r\n            return base                                                <=           \r\n        return combiner(term(count), accumulateHelp(count+1))          <=           \r\n    return accumulateHelp(0)                                           <=           \r\n                                                                       <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulateHelp(count):\r\n        if count==n+1:\r\n            return base\r\n        return combiner(term(count), accumulateHelp(count+1))\r\n    return accumulateHelp(1)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulateHelp(count):\r\n        if count==n+1:\r\n            return base\r\n        return combiner(term(count), accumulateHelp(count+1))\r\n    return accumulateHelp(1)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"count":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4,3,2,1],[0,1,2,3,4,3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6,5,4,3,2,1],[0,1,2,3,4,5,6,5,4,3,2,1,0]],"print accumulate(add, 11, 0, identity)":[[1],[0,1,0]],"print accumulate(add, 11, 3, square)":[[1,2,3,4,3,2,1],[0,1,2,3,4,3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6,5,4,3,2,1],[0,1,2,3,4,5,6,5,4,3,2,1,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulateHelp(count):\r\n        if count==n+1:\r\n            return base\r\n        return combiner(term(count), accumulateHelp(count+1))\r\n    return accumulateHelp(0)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"count":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4,3,2,1],[0,1,2,3,4,3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6,5,4,3,2,1],[0,1,2,3,4,5,6,5,4,3,2,1,0]],"print accumulate(add, 11, 0, identity)":[[1],[0,1,0]],"print accumulate(add, 11, 3, square)":[[1,2,3,4,3,2,1],[0,1,2,3,4,3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6,5,4,3,2,1],[0,1,2,3,4,5,6,5,4,3,2,1,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def accumulateHelp(count):\n        if count==n+1:\n            return base\n        return combiner(term(count),accumulateHelp(count+1))\n    return accumulateHelp(0)\n"},{"Id":298,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n    if n<2:  =>           \r\n    if n==0: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n<2:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n    \n    \n    \n    \n    \n        \n        \n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":299,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":13,"tests":[{"expected":"11","output":"12","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def accumulator(x,total):\n        if x>n:\n            return total\n        else:\n            return accumulator(x+1,combiner(total,term(x)))\n    if n==0:\n        return base\n    return accumulator(2,combiner(base,term(1)))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n    if n == 0:                                                            =>           \r\n        return base                                                       =>           \r\n        return accumulate(combiner, combiner(base, term(n)), n - 1, term) =>           \r\n    else:                                                                 =>           \r\n                                                                          =>           \r\n    def accumulator(x, total):                                            <=           \r\n        if x > n:                                                         <=           \r\n            return total                                                  <=           \r\n        else:                                                             <=           \r\n            return accumulator(x + 1, combiner(total, term(x)))           <=           \r\n    return accumulator(2, combiner(base, term(1)))                        <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulator(x, total):\r\n        if x>n:\r\n            return total\r\n        else:\r\n            return accumulator(x+1, combiner(total, term(x)))\r\n    if n==0:\r\n        return base\r\n    return accumulator(2, combiner(base, term(1)))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulator(x, total):\r\n        if x>n:\r\n            return total\r\n        else:\r\n            return accumulator(x+1, combiner(total, term(x)))\r\n    if n==0:\r\n        return base\r\n    return accumulator(2, combiner(base, term(1)))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{},"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulator(x, total):\r\n        if x>n:\r\n            return total\r\n        else:\r\n            return accumulator(x+1, combiner(total, term(x)))\r\n    return accumulator(2, combiner(base, term(1)))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{},"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"12\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n - 1, term)\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def accumulator(x,total):\n        if x>n:\n            return total\n        else:\n            return accumulator(x+1,combiner(total,term(x)))\n    return accumulator(2,combiner(base,term(1)))\n"},{"Id":300,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":40,"tests":[{"expected":"72","output":"144","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    initial=0\n    if base>n:\n        initial=0\n        total=base\n    else:\n        total=base\n    for i in range(initial,n):\n        total=combiner(total,term(i+1))\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        total = base       =>           \r\n        total = term(base) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    initial = 0\r\n    if base>n:\r\n        initial = 0\r\n        total = base\r\n    else:\r\n        total = base\r\n    for i in range(initial, n):\r\n        total = combiner(total, term(i+1))\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    initial = 0\r\n    if base>n:\r\n        initial = 0\r\n        total = base\r\n    else:\r\n        total = base\r\n    for i in range(initial, n):\r\n        total = combiner(total, term(i+1))\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[4,16,144]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    initial = 0\r\n    if base>n:\r\n        initial = 0\r\n        total = base\r\n    else:\r\n        total = term(base)\r\n    for i in range(initial, n):\r\n        total = combiner(total, term(i+1))\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","144","","# Error: expected","#     72","# but got","#     144","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[4,16,144]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"144\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    initial = 0\n    if base > n:\n\t    initial = 0\n\t    total = base\n    else:\n\t    total = base\n    for i in range(initial, n):\n\t    total = combiner(total, term(i+1))\n    return total\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    initial=0\n    if base>n:\n        initial=0\n        total=base\n    else:\n        total=term(base)\n    for i in range(initial,n):\n        total=combiner(total,term(i+1))\n    return total\n"},{"Id":301,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":12,"tests":[{"expected":"15","output":"10","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    k=1\n    total=base\n    if n==0:\n        return base\n    while k<n+1:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while k <= n: =>           \r\n    while k < n:  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = base\r\n    if n==0:\r\n        return base\r\n    while k<n+1:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = base\r\n    if n==0:\r\n        return base\r\n    while k<n+1:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,17,21]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,16]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,6,10]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,3,4]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3,4]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = base\r\n    if n==0:\r\n        return base\r\n    while k<n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,17,21]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,16]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,6,10]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,3,4]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3,4]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"8\n","print accumulate(add, 11, 5, identity)":"21\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"16\n","print accumulate(add, 0, 5, identity)":"10\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\" \n    k = 1\n    total = base\n    if n == 0:\n        return base\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    k=1\n    total=base\n    if n==0:\n        return base\n    while k<n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n"},{"Id":304,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n    elif n==0:      =>           \r\n                    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94,-95,-96,-97,-98,-99,-100,-101,-102,-103,-104,-105,-106,-107,-108,-109,-110,-111,-112,-113,-114,-115,-116,-117,-118,-119,-120,-121,-122,-123,-124,-125,-126,-127,-128,-129,-130,-131,-132,-133,-134,-135,-136,-137,-138,-139,-140,-141,-142,-143,-144,-145,-146,-147,-148,-149,-150,-151,-152,-153,-154,-155,-156,-157,-158,-159,-160,-161,-162]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner,base,n-1,term),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner,base,n-1,term),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner,base,n-1,term),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner,base,n-1,term),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner,base,n-1,term),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner,base,n-1,term),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    if n==1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94,-95,-96,-97,-98,-99,-100,-101,-102,-103,-104,-105,-106,-107,-108,-109,-110,-111,-112,-113,-114,-115,-116,-117,-118,-119,-120,-121,-122,-123,-124,-125,-126,-127,-128,-129,-130,-131,-132,-133,-134,-135,-136,-137,-138,-139,-140,-141,-142,-143,-144,-145,-146,-147,-148,-149,-150,-151,-152,-153,-154,-155,-156,-157,-158,-159,-160,-161,-162]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==1:\n        return combiner(base,term(1))\n    elif n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n"},{"Id":306,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    for i in range(1,n+1,1):\n        total=combiner(total,term(i))\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    total = base  =>           \r\n    total = start <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1, 1):\r\n        total = combiner(total, term(i))\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1, 1):\r\n        total = combiner(total, term(i))\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = start\r\n    for i in range(1, n+1, 1):\r\n        total = combiner(total, term(i))\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    total = start","NameError: name 'start' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n + 1, 1):\n        total = combiner(total, term(i))\n    return total\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=start\n    for i in range(1,n+1,1):\n        total=combiner(total,term(i))\n    return total\n"},{"Id":309,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def helper(combiner,n,term):\n        if n==1:\n            return term(1)\n        return combiner(term(n),helper(combiner,n-1,term))\n    if n==0:\n        return base\n    return combiner(base,helper(combiner,n,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        elif n == 0:       =>           \r\n            return term(0) =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(combiner, n, term):\r\n        if n==1:\r\n            return term(1)\r\n        return combiner(term(n), helper(combiner, n-1, term))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, helper(combiner, n, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(combiner, n, term):\r\n        if n==1:\r\n            return term(1)\r\n        return combiner(term(n), helper(combiner, n-1, term))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, helper(combiner, n, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(combiner, n, term):\r\n        if n==1:\r\n            return term(1)\r\n        return combiner(term(n), helper(combiner, n-1, term))\r\n    return combiner(base, helper(combiner, n, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper","    return combiner(term(n), helper(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper","    return combiner(term(n), helper(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper","    return combiner(term(n), helper(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper","    return combiner(term(n), helper(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper","    return combiner(term(n), helper(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper","    return combiner(term(n), helper(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in helper","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(combiner, n, term):\n        if n == 1:\n            return term(1)\n        elif n == 0:\n            return term(0)\n        return combiner(term(n), helper(combiner, n - 1, term))\n    return combiner(base, helper(combiner, n, term))\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def helper(combiner,n,term):\n        if n==1:\n            return term(1)\n        return combiner(term(n),helper(combiner,n-1,term))\n    return combiner(base,helper(combiner,n,term))\n"},{"Id":311,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(n))\n    return combiner(accumulate(combiner,base,n-1,term),term(n))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n    return combine(accumulate(combiner, base, n-1, term), term(n))  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    return combiner(accumulate(combiner, base, n-1, term), term(n))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    return combiner(accumulate(combiner, base, n-1, term), term(n))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    return combine(accumulate(combiner, base, n-1, term), term(n))\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combine(accumulate(combiner, base, n-1, term), term(n))","NameError: name 'combine' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    if n == 1:\n        return combiner(base, term(n)) \n\n    return combiner(accumulate(combiner, base, n-1, term), term(n))\n    \n\n\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(n))\n    return combine(accumulate(combiner,base,n-1,term),term(n))\nfrom operator import add,mul\n"},{"Id":312,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":4,"tests":[{"expected":"15","output":"TypeError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    result=base\n    for i in range(1,n+1):\n        result=combiner(result,term(i))\n    return result\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    result=base     =>           \r\n    result=combiner <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    for i in range(1, n+1):\r\n        result = combiner(result, term(i))\r\n    return result","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    for i in range(1, n+1):\r\n        result = combiner(result, term(i))\r\n    return result","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = combiner\r\n    for i in range(1, n+1):\r\n        result = combiner(result, term(i))\r\n    return result","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    result=combiner(result, term(i))","TypeError: unsupported operand type(s) for +: 'builtin_function_or_method' and 'int'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"<built-in function add>\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result=base\n    for i in range (1, n+1):\n        result=combiner(result, term(i))\n    return result\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    result=combiner\n    for i in range(1,n+1):\n        result=combiner(result,term(i))\n    return result\n"},{"Id":313,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":11,"tests":[{"expected":"25","output":"17","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    while 1<=n:\n        total=combiner(total,term(n))\n        n=n-1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n        total = combiner(total,term(n)) =>           \r\n        total = combiner(total,n)       <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while 1<=n:\r\n        total = combiner(total, term(n))\r\n        n = n-1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while 1<=n:\r\n        total = combiner(total, term(n))\r\n        n = n-1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[2,6,12]],"print accumulate(add, 11, 3, square)":[[11,20,24,25],[11,14,16,17]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while 1<=n:\r\n        total = combiner(total, n)\r\n        n = n-1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[2,6,12]],"print accumulate(add, 11, 3, square)":[[11,20,24,25],[11,14,16,17]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"12\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"17\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total = base\n    while 1 <= n:\n        total = combiner(total,term(n))\n        n = n-1\n    return total\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    while 1<=n:\n        total=combiner(total,n)\n        n=n-1\n    return total\n"},{"Id":314,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":41,"tests":[{"expected":"15","output":"57","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    result=base\n    if n>0:\n        for x in range(1,n+1):\n            result=combiner(result,term(x))\n    return result\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                     SideIndicator\r\n-----------                                     -------------\r\n            result = combiner(result, term(x))  =>           \r\n            result += combiner(result, term(x)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    if n>0:\r\n        for x in range(1, n+1):\r\n            result = combiner(result, term(x))\r\n    return result","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    if n>0:\r\n        for x in range(1, n+1):\r\n            result = combiner(result, term(x))\r\n    return result","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"result":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,4,20,200]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,23,48,99,202,409]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,23,50,109]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,4,11,26,57]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    if n>0:\r\n        for x in range(1, n+1):\r\n            result += combiner(result, term(x))\r\n    return result","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","57","","# Error: expected","#     15","# but got","#     57","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"AugmentedAssignStatementNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"result":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,4,20,200]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,23,48,99,202,409]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,23,50,109]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,4,11,26,57]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"200\n","print accumulate(add, 11, 5, identity)":"409\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"109\n","print accumulate(add, 0, 5, identity)":"57\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = base\n    if n > 0:\n        for x in range(1, n + 1):\n            result = combiner(result, term(x))\n    return result\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    result=base\n    if n>0:\n        for x in range(1,n+1):\n            result+=combiner(result,term(x))\n    return result\n"},{"Id":315,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def take_term(i,function):\n        if n==0:\n            return 0\n        elif i==n:\n            return function(i)\n        else:\n            return combiner(function(i),take_term(i+1,function))\n    return combiner(base,take_term(1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                       SideIndicator\r\n-----------                                       -------------\r\n        if(i == n):                               =>           \r\n    if(n == 0):                                   =>           \r\n        return base                               =>           \r\n        return combiner(base, take_term(1, term)) =>           \r\n    else:                                         =>           \r\n        if(i == 0):                               <=           \r\n            return 0                              <=           \r\n        elif(i == n):                             <=           \r\n    return combiner(base, take_term(1, term))     <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def take_term(i, function):\r\n        if (n==0):\r\n            return 0\r\n        elif (i==n):\r\n            return function(i)\r\n        else:\r\n            return combiner(function(i), take_term(i+1, function))\r\n    return combiner(base, take_term(1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def take_term(i, function):\r\n        if (n==0):\r\n            return 0\r\n        elif (i==n):\r\n            return function(i)\r\n        else:\r\n            return combiner(function(i), take_term(i+1, function))\r\n    return combiner(base, take_term(1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{"print accumulate(add, 11, 0, identity)":[[1],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70]]},"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def take_term(i, function):\r\n        if (i==0):\r\n            return 0\r\n        elif (i==n):\r\n            return function(i)\r\n        else:\r\n            return combiner(function(i), take_term(i+1, function))\r\n    return combiner(base, take_term(1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term","    return combiner(function(i), take_term(i + 1, function))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term","    return combiner(function(i), take_term(i + 1, function))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term","    return combiner(function(i), take_term(i + 1, function))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term","    return combiner(function(i), take_term(i + 1, function))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term","    return combiner(function(i), take_term(i + 1, function))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term","    return combiner(function(i), take_term(i + 1, function))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in take_term","    if(i == 0):","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"i":{"print accumulate(add, 11, 0, identity)":[[1],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70]]},"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def take_term(i, function):\n        if(i == n):\n            return function(i)\n        else:\n            return combiner(function(i), take_term(i + 1, function))\n    \n    if(n == 0):\n        return base\n    else:\n        return combiner(base, take_term(1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def take_term(i,function):\n        if i==0:\n            return 0\n        elif i==n:\n            return function(i)\n        else:\n            return combiner(function(i),take_term(i+1,function))\n    return combiner(base,take_term(1,term))\n"},{"Id":316,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    while n>=1:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        return base                          =>           \r\n        while n >= 1:                        =>           \r\n            total = combiner(total, term(n)) =>           \r\n    if n == 0:                               =>           \r\n            n -= 1                           =>           \r\n    else:                                    =>           \r\n    while n >= 0:                            <=           \r\n        total = combiner(total, term(n))     <=           \r\n        n -= 1                               <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=1:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[2,18,72,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0],[3,2,1,0,-1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1,0,-1]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1]],"print accumulate(add, 11, 3, square)":[[3,2,1,0],[3,2,1,0,-1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1,0,-1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=0:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[2,18,72,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0],[3,2,1,0,-1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1,0,-1]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1]],"print accumulate(add, 11, 3, square)":[[3,2,1,0],[3,2,1,0,-1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1,0,-1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** LULU'S CODE HERE ***\"\n    \n    \n    # def combiner_func(combiner, n, term):\n    #     if n == 0:\n    #         return term(0)\n    #     elif n == 1:\n    #         return term(1)\n    #     else:\n    #         return combiner(term(n), combiner_func(combiner, n-1, term))\n\n    # return combiner(base, combiner_func(combiner, n, term))\n    total = base\n    if n == 0:\n        return base\n    else:\n        while n >= 1:\n            total = combiner(total, term(n))\n            n -= 1\n\n    return total\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    while n>=0:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n"},{"Id":317,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":42,"tests":[{"expected":"25","output":"21913","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    i=1\n    result=base\n    while i<=n:\n        if i>=1:\n            result=combiner(result,term(i))\n            i+=1\n        else:\n            result=combiner(term(result),term(i))\n            i+=1\n    return result\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                           SideIndicator\r\n-----------                                                           -------------\r\n            result = combiner(result, combiner(term(i), term(i + 1))) =>           \r\n            i += 2                                                    =>           \r\n            result = combiner(term(result), term(i))                  <=           \r\n            i += 1                                                    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    result = base\r\n    while i<=n:\r\n        if i>=1:\r\n            result = combiner(result, term(i))\r\n            i += 1\r\n        else:\r\n            result = combiner(term(result), term(i))\r\n            i += 1\r\n    return result","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    result = base\r\n    while i<=n:\r\n        if i>=1:\r\n            result = combiner(result, term(i))\r\n            i += 1\r\n        else:\r\n            result = combiner(term(result), term(i))\r\n            i += 1\r\n    return result","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"result":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,16,2304]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,148,21913]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1,2,16,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,12,2,14,3,17,4,21,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1,12,2,148,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3,6,4,10,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    result = base\r\n    while i<=n:\r\n        if i==1:\r\n            result = combiner(result, term(i))\r\n            i += 1\r\n        else:\r\n            result = combiner(term(result), term(i))\r\n            i += 1\r\n    return result\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","21913","","# Error: expected","#     25","# but got","#     21913","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\"))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"result":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,16,2304]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,148,21913]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1,2,16,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,12,2,14,3,17,4,21,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1,12,2,148,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3,6,4,10,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2304\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"21913\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    result = base\n    while i <= n:\n        if i == 1:\n            result = combiner(result, term(i))\n            i += 1\n        else:\n            result = combiner(result, combiner(term(i), term(i + 1)))\n            i += 2\n    return result\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    i=1\n    result=base\n    while i<=n:\n        if i==1:\n            result=combiner(result,term(i))\n            i+=1\n        else:\n            result=combiner(term(result),term(i))\n            i+=1\n    return result\nfrom operator import add,mul\n"},{"Id":318,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":20,"tests":[{"expected":"15","output":"1","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    return total         =>           \r\n            return total <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1,2]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1,2]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n        return total\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ReferenceNode(node, StartsWithParent(Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), Tutor.synthesis.MagicK), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), Tutor.synthesis.MagicK), 3), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast)))))))","sequence_comparison_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1,2]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1,2]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"12\n","print accumulate(add, 11, 0, identity)":"None\n","print accumulate(add, 11, 3, square)":"12\n","print accumulate(add, 0, 5, identity)":"1\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n            total, k = combiner(total, term(k)), k + 1\n    return total\n\n\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n        return total\nfrom operator import add,mul\n"},{"Id":319,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    def terms(n):\n        if n==1:\n            return term(1)\n        else:\n            return combiner(term(n),terms(n-1))\n    return combiner(base,terms(n))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        elif n == 0: =>           \r\n            return 0 =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def terms(n):\r\n        if n==1:\r\n            return term(1)\r\n        else:\r\n            return combiner(term(n), terms(n-1))\r\n    return combiner(base, terms(n))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def terms(n):\r\n        if n==1:\r\n            return term(1)\r\n        else:\r\n            return combiner(term(n), terms(n-1))\r\n    return combiner(base, terms(n))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def terms(n):\r\n        if n==1:\r\n            return term(1)\r\n        else:\r\n            return combiner(term(n), terms(n-1))\r\n    return combiner(base, terms(n))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms","    return combiner(term(n), terms(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms","    return combiner(term(n), terms(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms","    return combiner(term(n), terms(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms","    return combiner(term(n), terms(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms","    return combiner(term(n), terms(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms","    return combiner(term(n), terms(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in terms","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def terms(n):\n        if n == 1:\n            return term(1)\n        elif n == 0:\n            return 0\n        else:\n            return combiner(term(n), terms(n-1))\n    return combiner(base, terms(n))\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def terms(n):\n        if n==1:\n            return term(1)\n        else:\n            return combiner(term(n),terms(n-1))\n    return combiner(base,terms(n))\n"},{"Id":321,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (acc,i)=(base,1)\n    while i<=n:\n        (acc,i)=(combiner(acc,term(i)),i+1)\n    return acc\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                    SideIndicator\r\n-----------                                    -------------\r\n    acc, i = base, 1                           =>           \r\n        acc, i = combiner(acc, term(i)), i + 1 =>           \r\n    acc, i = base, 0                           <=           \r\n        acc, i = combiner(acc,term(i)), i + 1  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    acc, i = base, 1\r\n    while i<=n:\r\n        acc, i = combiner(acc, term(i)), i+1\r\n    return acc","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    acc, i = base, 1\r\n    while i<=n:\r\n        acc, i = combiner(acc, term(i)), i+1\r\n    return acc","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]],"print accumulate(add, 11, 0, identity)":[[1],[0,1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]]},"acc":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    acc, i = base, 0\r\n    while i<=n:\r\n        acc, i = combiner(acc, term(i)), i+1\r\n    return acc","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]],"print accumulate(add, 11, 0, identity)":[[1],[0,1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]]},"acc":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    acc, i = base, 1\n    while i <= n:\n        acc, i = combiner(acc, term(i)), i + 1\n    return acc\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (acc,i)=(base,0)\n    while i<=n:\n        (acc,i)=(combiner(acc,term(i)),i+1)\n    return acc\n"},{"Id":323,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":4,"tests":[{"expected":"15","output":"TypeError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term,k=1):\n    if n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner,base,n-1,term,term(n)),term(n))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n        return combiner( accumulate(combiner, base, n-1, term), term(n)) =>           \r\n        return combiner( accumulate(combiner, base, n-1, term, term(n))) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term, k = 1):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term, term(n)), term(n))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term, k = 1):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term, term(n)), term(n))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1,2,3],[3,2,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5,4,3,2,1]],"print accumulate(add, 11, 3, square)":[[3,2,1,2,3],[3,2,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5,4,3,2,1]]}},"before":"\r\ndef accumulate(combiner, base, n, term, k = 1):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term, term(n)))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner( accumulate(combiner, base, n-1, term, term(n)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner( accumulate(combiner, base, n-1, term, term(n)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner( accumulate(combiner, base, n-1, term, term(n)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner( accumulate(combiner, base, n-1, term, term(n)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner( accumulate(combiner, base, n-1, term, term(n)))","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"CallExpressionNode\"))), Tutor.synthesis.MagicK))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"any\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"CallExpressionNode\"))), Tutor.synthesis.MagicK))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"any\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"any\")))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"any\"))))))))))), InOrderSort(ast)))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1,2,3],[3,2,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5,4,3,2,1]],"print accumulate(add, 11, 3, square)":[[3,2,1,2,3],[3,2,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5,4,3,2,1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term, k =1):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner( accumulate(combiner, base, n-1, term), term(n))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term,k=1):\n    if n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner,base,n-1,term,term(n)))\n"},{"Id":325,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":7,"tests":[{"expected":"25","output":"135","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    for i in range(n):\n        total=combiner(total,term(increment(i)))\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total = base       =>           \r\n    total = term(base) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(n):\r\n        total = combiner(total, term(increment(i)))\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(n):\r\n        total = combiner(total, term(increment(i)))\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[4,16,144]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[121,122,126,135]]},"x":{"print accumulate(mul, 2, 3, square)":[[0,1,2,3],[2,0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[0,1,2,3,4,5],[11,0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[0,1,2,3],[11,0,1,2,3]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = term(base)\r\n    for i in range(n):\r\n        total = combiner(total, term(increment(i)))\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[4,16,144]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[121,122,126,135]]},"x":{"print accumulate(mul, 2, 3, square)":[[0,1,2,3],[2,0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[0,1,2,3,4,5],[11,0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[0,1,2,3],[11,0,1,2,3]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"144\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"135\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n\n    for i in range(n):\n        total = combiner(total, term(increment(i)))\n    return total\n    \n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=term(base)\n    for i in range(n):\n        total=combiner(total,term(increment(i)))\n    return total\n"},{"Id":326,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":7,"tests":[{"expected":"25","output":"135","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return term(base)\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                          SideIndicator\r\n-----------                                                          -------------\r\n    if n == 1:                                                       =>           \r\n        return combiner(base, term(n))                               =>           \r\n    elif n == 0:                                                     =>           \r\n        return base                                                  =>           \r\n        return combiner(term(n), accumulate(combiner,base,n-1,term)) =>           \r\n    def helper(x):                                                   =>           \r\n        return compose1(f,f)                                         =>           \r\n    return helper(x)                                                 =>           \r\n    else:                                                            =>           \r\n    if n == 0:                                                       <=           \r\n        return term(base)                                            <=           \r\n    return combiner(term(n), accumulate(combiner,base,n-1,term))     <=           \r\n                                                                     <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,11]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,11]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,11]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,11]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"144\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"135\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(base, term(n))\n    elif n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner,base,n-1,term))\n\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":327,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":0,"tests":[{"expected":"15","output":"14","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0 or base==1:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    if (n == 0):           =>           \r\n    if (n == 0 or n == 1): <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0 or base==1):\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0 or base==1):\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0 or n==1):\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"25\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"24\n","print accumulate(add, 0, 5, identity)":"14\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if (n == 0):\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0 or n==1:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":329,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return combiner(base,term(0))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return base                    =>           \r\n        return combiner(base, term(0)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(base, term(0))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(base, term(0))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return combiner(base, term(0))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return combiner(base,term(0))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":330,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    x=1\n    Total=base\n    while x<=n:\n        Total=combiner(Total,term(x))\n        x+=1\n    return Total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while x < n:  =>           \r\n    while x <= n: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = 1\r\n    Total = base\r\n    while x<=n:\r\n        Total = combiner(Total, term(x))\r\n        x += 1\r\n    return Total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = 1\r\n    Total = base\r\n    while x<=n:\r\n        Total = combiner(Total, term(x))\r\n        x += 1\r\n    return Total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"Total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]],"print accumulate(add, 11, 0, identity)":[[1],[0,1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = 0\r\n    Total = base\r\n    while x<=n:\r\n        Total = combiner(Total, term(x))\r\n        x += 1\r\n    return Total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"Total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]],"print accumulate(add, 11, 0, identity)":[[1],[0,1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = 0\n    Total = base\n    while x < n:\n        x += 1\n        Total = combiner(Total, term(x))\n    return Total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    x=0\n    Total=base\n    while x<=n:\n        Total=combiner(Total,term(x))\n        x+=1\n    return Total\n"},{"Id":331,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    def accumulate_helper(combiner,i,n_result):\n        if i==n:\n            return combiner(n_result,term(i))\n        else:\n            return accumulate_helper(combiner,i+1,combiner(n_result,term(i)))\n    return accumulate_helper(combiner,1,base)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n        if n == 0:      =>           \r\n            return base =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def accumulate_helper(combiner, i, n_result):\r\n        if i==n:\r\n            return combiner(n_result, term(i))\r\n        else:\r\n            return accumulate_helper(combiner, i+1, combiner(n_result, term(i)))\r\n    return accumulate_helper(combiner, 1, base)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def accumulate_helper(combiner, i, n_result):\r\n        if i==n:\r\n            return combiner(n_result, term(i))\r\n        else:\r\n            return accumulate_helper(combiner, i+1, combiner(n_result, term(i)))\r\n    return accumulate_helper(combiner, 1, base)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{},"n_result":{},"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulate_helper(combiner, i, n_result):\r\n        if i==n:\r\n            return combiner(n_result, term(i))\r\n        else:\r\n            return accumulate_helper(combiner, i+1, combiner(n_result, term(i)))\r\n    return accumulate_helper(combiner, 1, base)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper","    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper","    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper","    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper","    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper","    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper","    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate_helper","    if i == n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"i":{},"n_result":{},"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def accumulate_helper(combiner, i, n_result):\n        if n == 0:\n            return base\n        if i == n:\n            return combiner(n_result, term(i))\n        else:\n            return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))\n    return accumulate_helper(combiner, 1, base)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def accumulate_helper(combiner,i,n_result):\n        if i==n:\n            return combiner(n_result,term(i))\n        else:\n            return accumulate_helper(combiner,i+1,combiner(n_result,term(i)))\n    return accumulate_helper(combiner,1,base)\n"},{"Id":332,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":11,"tests":[{"expected":"25","output":"17","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    i=1\n    if n==0:\n        return base\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total = combiner(total, i)       <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    if n==0:\r\n        return base\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    if n==0:\r\n        return base\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,4,12]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,14,17]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    if n==0:\r\n        return base\r\n    while i<=n:\r\n        total = combiner(total, i)\r\n        i += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,4,12]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,14,17]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"12\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"17\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    total = base\n    i = 1\n    if n == 0:\n        return base\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n        \n    \n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    i=1\n    if n==0:\n        return base\n    while i<=n:\n        total=combiner(total,i)\n        i+=1\n    return total\n"},{"Id":333,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":15,"tests":[{"expected":"15","output":"21","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    first_number=base\n    i=0\n    while i+1<=n:\n        i=i+1\n        first_number=combiner(term(i),first_number)\n    return first_number\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n    while  i < n:  =>           \r\n    while  i <= n: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    first_number = base\r\n    i = 0\r\n    while i+1<=n:\r\n        i = i+1\r\n        first_number = combiner(term(i), first_number)\r\n    return first_number","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    first_number = base\r\n    i = 0\r\n    while i+1<=n:\r\n        i = i+1\r\n        first_number = combiner(term(i), first_number)\r\n    return first_number","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[0,1,2,3],[0,1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[0,1,2,3,4,5],[0,1,2,3,4,5,6]],"print accumulate(add, 11, 0, identity)":[[0],[0,1]],"print accumulate(add, 11, 3, square)":[[0,1,2,3],[0,1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[0,1,2,3,4,5],[0,1,2,3,4,5,6]]},"first_number":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8,72,1152]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,17,21,26,32]],"print accumulate(add, 11, 0, identity)":[[11],[11,12]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,16,25,41]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,6,10,15,21]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,3,4,5,6]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3,4,5,6]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    first_number = base\r\n    i = 0\r\n    while i<=n:\r\n        i = i+1\r\n        first_number = combiner(term(i), first_number)\r\n    return first_number\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","21","","# Error: expected","#     15","# but got","#     21","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[0,1,2,3],[0,1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[0,1,2,3,4,5],[0,1,2,3,4,5,6]],"print accumulate(add, 11, 0, identity)":[[0],[0,1]],"print accumulate(add, 11, 3, square)":[[0,1,2,3],[0,1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[0,1,2,3,4,5],[0,1,2,3,4,5,6]]},"first_number":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8,72,1152]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,17,21,26,32]],"print accumulate(add, 11, 0, identity)":[[11],[11,12]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,16,25,41]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,6,10,15,21]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,3,4,5,6]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3,4,5,6]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"1152\n","print accumulate(add, 11, 5, identity)":"32\n","print accumulate(add, 11, 0, identity)":"12\n","print accumulate(add, 11, 3, square)":"41\n","print accumulate(add, 0, 5, identity)":"21\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    first_number = base\n    i = 0\n    while  i < n:\n        i = i+ 1\n        first_number = combiner(term(i),first_number)\n    return first_number\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    first_number=base\n    i=0\n    while i<=n:\n        i=i+1\n        first_number=combiner(term(i),first_number)\n    return first_number\nfrom operator import add,mul\n"},{"Id":334,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":8,"tests":[{"expected":"15","output":"UnboundLocalError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    result=base\n    i=1\n    while i<=n:\n        result=combiner(result,term(i))\n        i+=1\n    return result\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    i = 1   =>           \r\n    x = 1   <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    i = 1\r\n    while i<=n:\r\n        result = combiner(result, term(i))\r\n        i += 1\r\n    return result","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    i = 1\r\n    while i<=n:\r\n        result = combiner(result, term(i))\r\n        i += 1\r\n    return result","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"result":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    x = 1\r\n    while i<=n:\r\n        result = combiner(result, term(i))\r\n        i += 1\r\n    return result","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    while i<=n:","UnboundLocalError: local variable 'i' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"result":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result = base\n    i = 1\n\n    while i<=n:\n        result = combiner(result,term(i))\n        i += 1\n\n    return result\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    result=base\n    x=1\n    while i<=n:\n        result=combiner(result,term(i))\n        i+=1\n    return result\n"},{"Id":337,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":43,"tests":[{"expected":"15","output":"RecursionError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n                    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94,-95,-96,-97]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","RecursionError: maximum recursion depth exceeded","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94,-95,-96,-97]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":null,"print accumulate(add, 11, 5, identity)":null,"print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":null,"print accumulate(add, 0, 5, identity)":null},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":338,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":7,"tests":[{"expected":"25","output":"135","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def helper(i,total):\n        if i>n:\n            return total\n        else:\n            total=combiner(total,term(i))\n            return helper(i+1,total)\n    return helper(1,base)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    return helper(1, base)       =>           \r\n    return helper(1, term(base)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i, total):\r\n        if i>n:\r\n            return total\r\n        else:\r\n            total = combiner(total, term(i))\r\n            return helper(i+1, total)\r\n    return helper(1, base)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i, total):\r\n        if i>n:\r\n            return total\r\n        else:\r\n            total = combiner(total, term(i))\r\n            return helper(i+1, total)\r\n    return helper(1, base)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72,8,2],[4,16,144,16,4]],"print accumulate(add, 11, 3, square)":[[11,12,16,25,16,12],[121,122,126,135,126,122]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[11,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[11,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i, total):\r\n        if i>n:\r\n            return total\r\n        else:\r\n            total = combiner(total, term(i))\r\n            return helper(i+1, total)\r\n    return helper(1, term(base))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72,8,2],[4,16,144,16,4]],"print accumulate(add, 11, 3, square)":[[11,12,16,25,16,12],[121,122,126,135,126,122]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[11,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[11,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"144\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"135\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i, total):\n        if i > n:\n            return total\n        else:\n            total = combiner(total, term(i))\n            return helper(i + 1, total)\n    return helper(1, base)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def helper(i,total):\n        if i>n:\n            return total\n        else:\n            total=combiner(total,term(i))\n            return helper(i+1,total)\n    return helper(1,term(base))\n"},{"Id":339,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    for i in range(1,n+1):\n        total=combiner(total,term(i))\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                    SideIndicator\r\n-----------                                    -------------\r\n    for i in range(1, n+1):                    =>           \r\n    return accumulate(add, base, n, term)      =>           \r\n    return accumulate(mul,1, n, term)          =>           \r\n    for i in range(0, n+1):                    <=           \r\n        #return accumulate(add, base, n, term) <=           \r\n        #return accumulate(mul,1, n, term)     <=           \r\n    \"*** YOUR CODE HERE ***\"                   <=           \r\n    \"*** YOUR CODE HERE ***\"                   <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1):\r\n        total = combiner(total, term(i))\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1):\r\n        total = combiner(total, term(i))\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(0, n+1):\r\n        total = combiner(total, term(i))\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        total = combiner(total, term(i))\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    for i in range(0,n+1):\n        total=combiner(total,term(i))\n    return total\n"},{"Id":340,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n < 1:       =>           \r\n        return base =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":343,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":7,"tests":[{"expected":"25","output":"135","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, (n-1), term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, (n-1), term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,11]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,11]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, (n-1), term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,11]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,11]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"144\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"135\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n\n    else:\n        return combiner(term(n), accumulate(combiner, base, (n-1), term))\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":344,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":13,"tests":[{"expected":"11","output":"12","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n<=1:\n        return combiner(term(1),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n <= 1:      <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n<=1:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, (n-1), term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n<=1:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, (n-1), term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, (n-1), term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"12\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, (n - 1), term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(term(1),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":345,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":11,"tests":[{"expected":"25","output":"17","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n                                                                    =>           \r\n        return combiner(n,accumulate(combiner,base,n-1,term))       <=           \r\n                                                                    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(n, accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"12\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"17\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # i, total = 1,base\n    # while i <= n:\n    #     total = combiner(total,term(i))\n    #     i += 1\n    # return total\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(n,accumulate(combiner,base,n-1,term))\n"},{"Id":349,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":7,"tests":[{"expected":"25","output":"135","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,11]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,11]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,11]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,11]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"144\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"135\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner,base,n-1,term))\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":350,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n == 0:      =>           \r\n    if n == 1:      <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1: \n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":352,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":9,"tests":[{"expected":"72","output":"108","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return 0+base\n    elif base==1:\n        return term(n)+base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(term(n), base) =>           \r\n        return term(n) + base          <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return 0+base\r\n    elif base==1:\r\n        return term(n)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return 0+base\r\n    elif base==1:\r\n        return term(n)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return 0+base\r\n    elif n==1:\r\n        return term(n)+base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"108\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return 0 + base\n    elif n == 1:\n        return combiner(term(n), base)\n    else:\n        return combiner( term(n), accumulate(combiner, base, n - 1, term))\n\n    # def counter(k):\n    #     if k == 0:\n    #         return 0\n    #     elif k == 1:\n    #         return term(k)\n    #     elif k > 1:\n    #         return combiner( term(k), counter(k-1) )\n\n    #return combiner( base, counter(n) )\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return 0+base\n    elif n==1:\n        return term(n)+base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":353,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":44,"tests":[{"expected":"26","output":"37","input":"accumulate(add, 11, 5, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (i,total)=(0,base)\n    if n==0:\n        return total\n    while n>0:\n        total=combiner(term(n),total)\n        i+=1\n        n-=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    return total                 =>           \r\n    return combiner(base, total) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    i, total = 0, base\r\n    if n==0:\r\n        return total\r\n    while n>0:\r\n        total = combiner(term(n), total)\r\n        i += 1\r\n        n -= 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i, total = 0, base\r\n    if n==0:\r\n        return total\r\n    while n>0:\r\n        total = combiner(term(n), total)\r\n        i += 1\r\n        n -= 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    i, total = 0, base\r\n    if n==0:\r\n        return total\r\n    while n>0:\r\n        total = combiner(term(n), total)\r\n        i += 1\r\n        n -= 1\r\n    return combiner(base, total)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","37","","# Error: expected","#     26","# but got","#     37","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"144\n","print accumulate(add, 11, 5, identity)":"37\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"36\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"The NEXT_TERM function was inspired from the use of product function \n    and after is the body of the accumulate funciton\"\"\" \n    i, total = 0, base \n\n    if n == 0: \n        return total \n    \n    while n > 0: \n        total = combiner(term(n), total)\n        i += 1 \n        n -= 1\n    return total \n        \n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (i,total)=(0,base)\n    if n==0:\n        return total\n    while n>0:\n        total=combiner(term(n),total)\n        i+=1\n        n-=1\n    return combiner(base,total)\n"},{"Id":354,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def accumulation_counter(combiner,counter,n,f):\n        if counter==n:\n            return f(n)\n        else:\n            return combiner(f(counter),accumulation_counter(combiner,counter+1,n,f))\n    if n==0:\n        return base\n    else:\n        return combiner(base,accumulation_counter(combiner,1,n,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(base, accumulation_counter(combiner, 1, n, term)) =>           \r\n        return combiner(base, accumulation_counter(combiner, 0, n, term)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulation_counter(combiner, counter, n, f):\r\n        if counter==n:\r\n            return f(n)\r\n        else:\r\n            return combiner(f(counter), accumulation_counter(combiner, (counter+1), n, f))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(base, accumulation_counter(combiner, 1, n, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulation_counter(combiner, counter, n, f):\r\n        if counter==n:\r\n            return f(n)\r\n        else:\r\n            return combiner(f(counter), accumulation_counter(combiner, (counter+1), n, f))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(base, accumulation_counter(combiner, 1, n, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"counter":{"print accumulate(mul, 2, 3, square)":[[1,2,3,2,1],[0,1,2,3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,4,3,2,1],[0,1,2,3,4,5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[1,2,3,2,1],[0,1,2,3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,4,3,2,1],[0,1,2,3,4,5,4,3,2,1,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulation_counter(combiner, counter, n, f):\r\n        if counter==n:\r\n            return f(n)\r\n        else:\r\n            return combiner(f(counter), accumulation_counter(combiner, (counter+1), n, f))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(base, accumulation_counter(combiner, 0, n, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"counter":{"print accumulate(mul, 2, 3, square)":[[1,2,3,2,1],[0,1,2,3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,4,3,2,1],[0,1,2,3,4,5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[1,2,3,2,1],[0,1,2,3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,4,3,2,1],[0,1,2,3,4,5,4,3,2,1,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    def accumulation_counter(combiner, counter, n, f):\n        if counter == n:\n            return f(n)\n        else: \n            return combiner(f(counter), accumulation_counter(combiner, (counter + 1), n, f))\n\n    if n == 0:\n        return base\n    else:\n        return combiner(base, accumulation_counter(combiner, 1, n, term))\n\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def accumulation_counter(combiner,counter,n,f):\n        if counter==n:\n            return f(n)\n        else:\n            return combiner(f(counter),accumulation_counter(combiner,counter+1,n,f))\n    if n==0:\n        return base\n    else:\n        return combiner(base,accumulation_counter(combiner,0,n,term))\n"},{"Id":355,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":0,"tests":[{"expected":"15","output":"14","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n    if n==0: =>           \r\n    if n==1: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"25\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"24\n","print accumulate(add, 0, 5, identity)":"14\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":358,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":45,"tests":[{"expected":"15","output":"<built-in function add>","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    x=1\n    total=base\n    if n==0:\n        return combiner(base,term(0))\n    while x!=n+1:\n        base=combiner(base,term(x))\n        x=x+1\n    return base\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    return total    =>           \r\n    return combiner <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = 1\r\n    total = base\r\n    if n==0:\r\n        return combiner(base, term(0))\r\n    while x!=n+1:\r\n        base = combiner(base, term(x))\r\n        x = x+1\r\n    return base","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = 1\r\n    total = base\r\n    if n==0:\r\n        return combiner(base, term(0))\r\n    while x!=n+1:\r\n        base = combiner(base, term(x))\r\n        x = x+1\r\n    return base","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]},"total":{"print accumulate(mul, 2, 3, square)":[[2],[2,8,72]],"print accumulate(add, 11, 5, identity)":[[11],[11,12,14,17,21,26]],"print accumulate(add, 11, 3, square)":[[11],[11,12,16,25]],"print accumulate(add, 0, 5, identity)":[[0],[0,1,3,6,10,15]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = 1\r\n    total = base\r\n    if n==0:\r\n        return combiner(base, term(0))\r\n    while x!=n+1:\r\n        total = combiner(total, term(x))\r\n        x = x+1\r\n    return combiner","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","<built-in function add>","","# Error: expected","#     15","# but got","#     <built-in function add>","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast)))))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]},"total":{"print accumulate(mul, 2, 3, square)":[[2],[2,8,72]],"print accumulate(add, 11, 5, identity)":[[11],[11,12,14,17,21,26]],"print accumulate(add, 11, 3, square)":[[11],[11,12,16,25]],"print accumulate(add, 0, 5, identity)":[[0],[0,1,3,6,10,15]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"<built-in function mul>\n","print accumulate(add, 11, 5, identity)":"<built-in function add>\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"<built-in function add>\n","print accumulate(add, 0, 5, identity)":"<built-in function add>\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x=1\n    total = base\n    if n==0:\n        return combiner(base, term(0))\n    while x!=n+1:\n        total = combiner(total, term(x))\n        x=x+1\n    return total\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    x=1\n    total=base\n    if n==0:\n        return combiner(base,term(0))\n    while x!=n+1:\n        total=combiner(total,term(x))\n        x=x+1\n    return combiner\n"},{"Id":359,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def helper(n):\n        if n<=1:\n            return term(n)\n        else:\n            return combiner(term(n),helper(n-1))\n    return combiner(base,helper(n))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n        if n <= 1: =>           \r\n        if n == 1: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(n):\r\n        if n<=1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), helper(n-1))\r\n    return combiner(base, helper(n))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(n):\r\n        if n<=1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), helper(n-1))\r\n    return combiner(base, helper(n))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(n):\r\n        if n==1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), helper(n-1))\r\n    return combiner(base, helper(n))\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(n), helper(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(n), helper(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(n), helper(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(n), helper(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(n), helper(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in helper","    return combiner(term(n), helper(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in helper","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(n):\n        if n <= 1:\n            return term(n)\n        else:\n            return combiner(term(n), helper(n-1))\n    return combiner(base, helper(n))\n\t\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def helper(n):\n        if n==1:\n            return term(n)\n        else:\n            return combiner(term(n),helper(n-1))\n    return combiner(base,helper(n))\nfrom operator import add,mul\n"},{"Id":360,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":4,"tests":[{"expected":"15","output":"TypeError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    elif n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return combiner(term(n), accumulate(base, n - 1, term))           <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    elif n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    elif n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    elif n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(base, n - 1, term))","TypeError: accumulate() missing 1 required positional argument: 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(base, term(n))\n    elif n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    elif n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(base,n-1,term))\n"},{"Id":361,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":24,"tests":[{"expected":"72","output":"16","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (total,i)=(base,1)\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total += term(i)                 <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, i = base, 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, i = base, 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,3,7,16]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, i = base, 1\r\n    while i<=n:\r\n        total += term(i)\r\n        i += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","16","","# Error: expected","#     72","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i))))))))))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,3,7,16]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"16\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, i = base, 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (total,i)=(base,1)\n    while i<=n:\n        total+=term(i)\n        i+=1\n    return total\n"},{"Id":362,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(combiner(term(n),term(n-1)),accumulate(combiner,base,n-2,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n ==0:                          =>           \r\n        return combiner(base, term(0)) =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(combiner(term(n), term(n-1)), accumulate(combiner, base, n-2, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(combiner(term(n), term(n-1)), accumulate(combiner, base, n-2, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-2,-4,-6,-8,-10,-12,-14,-16,-18,-20,-22,-24,-26,-28,-30,-32,-34,-36,-38,-40,-42,-44,-46,-48,-50,-52,-54,-56,-58,-60,-62,-64,-66,-68,-70,-72,-74,-76,-78,-80,-82,-84,-86,-88,-90,-92,-94,-96,-98,-100,-102,-104,-106,-108]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(combiner(term(n), term(n-1)), accumulate(combiner, base, n-2, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-2,-4,-6,-8,-10,-12,-14,-16,-18,-20,-22,-24,-26,-28,-30,-32,-34,-36,-38,-40,-42,-44,-46,-48,-50,-52,-54,-56,-58,-60,-62,-64,-66,-68,-70,-72,-74,-76,-78,-80,-82,-84,-86,-88,-90,-92,-94,-96,-98,-100,-102,-104,-106,-108]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n ==0:\n        return combiner(base, term(0))\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(combiner(term(n),term(n-1)),accumulate(combiner,base,n-2,term))\n"},{"Id":363,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    k=1\n    result=base\n    while k<=n:\n        result=combiner(result,term(k))\n        k+=1\n    return result\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        result = combiner(result,term(k)) =>           \r\n        result = combine(result,term(k))  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    result = base\r\n    while k<=n:\r\n        result = combiner(result, term(k))\r\n        k += 1\r\n    return result","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    result = base\r\n    while k<=n:\r\n        result = combiner(result, term(k))\r\n        k += 1\r\n    return result","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"result":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]},"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    result = base\r\n    while k<=n:\r\n        result = combine(result, term(k))\r\n        k += 1\r\n    return result","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    result = combine(result,term(k))","NameError: name 'combine' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"result":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]},"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 1\n    result = base\n    while k<=n:\n        result = combiner(result,term(k))\n        k += 1\n    return result\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    k=1\n    result=base\n    while k<=n:\n        result=combine(result,term(k))\n        k+=1\n    return result\n"},{"Id":366,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":46,"tests":[{"expected":"26","output":"RecursionError","input":"accumulate(add, 11, 5, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if term(n)==base:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n    if n == 0:                                                          =>           \r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))     =>           \r\n                                                                        =>           \r\n                                                                        =>           \r\n    if term(n) == base:                                                 <=           \r\n    else:                                                               <=           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) <=           \r\n    \"*** YOUR CODE HERE ***\"                                            <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if term(n)==base:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if term(n)==base:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if term(n)==base:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 67, in accumulate","    if term(n) == base:","RecursionError: maximum recursion depth exceeded","","# Error: expected","#     26","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":null,"print accumulate(add, 11, 5, identity)":null,"print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":null,"print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if term(n)==base:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":369,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":20,"tests":[{"expected":"15","output":"1","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=0\n    count=1\n    while n>0:\n        base=combiner(term(n),base)\n        n-=1\n    if n==0:\n        return base\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n        base = combiner(term(n), base)  =>           \r\n        return base                     =>           \r\n                                        =>           \r\n        total = combiner(term(n), base) <=           \r\n        return total                    <=           \r\n    return total                        <=           \r\n    total = 0                           <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    count = 1\r\n    while n>0:\r\n        base = combiner(term(n), base)\r\n        n -= 1\r\n    if n==0:\r\n        return base\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    count = 1\r\n    while n>0:\r\n        base = combiner(term(n), base)\r\n        n -= 1\r\n    if n==0:\r\n        return base\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26],[11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15],[0]]},"total":{"print accumulate(mul, 2, 3, square)":[[0],[0,18,8,2]],"print accumulate(add, 11, 5, identity)":[[0],[0,16,15,14,13,12]],"print accumulate(add, 11, 3, square)":[[0],[0,20,15,12]],"print accumulate(add, 0, 5, identity)":[[0],[0,5,4,3,2,1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    count = 1\r\n    while n>0:\r\n        total = combiner(term(n), base)\r\n        n -= 1\r\n    if n==0:\r\n        return total\r\n    return total\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26],[11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15],[0]]},"total":{"print accumulate(mul, 2, 3, square)":[[0],[0,18,8,2]],"print accumulate(add, 11, 5, identity)":[[0],[0,16,15,14,13,12]],"print accumulate(add, 11, 3, square)":[[0],[0,20,15,12]],"print accumulate(add, 0, 5, identity)":[[0],[0,5,4,3,2,1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"12\n","print accumulate(add, 11, 0, identity)":"0\n","print accumulate(add, 11, 3, square)":"12\n","print accumulate(add, 0, 5, identity)":"1\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    \"\"\"if n == 0:\n        return base\n    base = combiner(term(n), base)\n\n    return accumulate(combiner,base,n-1,term)\"\"\"\n    count = 1\n\n    while n > 0:\n        base = combiner(term(n), base)\n        n -= 1\n    if n == 0:\n        return base\n    \n\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=0\n    count=1\n    while n>0:\n        total=combiner(term(n),base)\n        n-=1\n    if n==0:\n        return total\n    return total\nfrom operator import add,mul\n"},{"Id":371,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":20,"tests":[{"expected":"15","output":"1","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    while n>0:\n        base=combiner(term(n),base)\n        n-=1\n    return base\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n    total=base                        =>           \r\n        total=combiner(term(n),total) =>           \r\n        total=combiner(term(n),base)  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    while n>0:\r\n        base = combiner(term(n), base)\r\n        n -= 1\r\n    return base","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    while n>0:\r\n        base = combiner(term(n), base)\r\n        n -= 1\r\n    return base","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26],[11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15],[0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    while n>0:\r\n        total = combiner(term(n), base)\r\n        n -= 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26],[11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15],[0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"12\n","print accumulate(add, 11, 0, identity)":"","print accumulate(add, 11, 3, square)":"12\n","print accumulate(add, 0, 5, identity)":"1\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=base\n    while n>0:\n        total=combiner(term(n),total)\n        n-=1\n    return total\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    while n>0:\n        total=combiner(term(n),base)\n        n-=1\n    return total\n"},{"Id":373,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":3,"tests":[{"expected":"15","output":"0","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    while k<=n: =>           \r\n    while n<=k: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 0, identity)":[[1],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 0, identity)":[[11],[11,12,14,17,21,26,32,39,47,56,66,77,89,102,116,131,147,164,182,201,221,242,264,287,311,336,362,389,417,446,476,507,539,572,606,641,677,714,752,791,831,872,914,957,1001,1046,1092,1139,1187,1236,1286,1337,1389,1442,1496,1551,1607,1664,1722,1781,1841,1902,1964,2027,2091,2156,2222,2289,2357,2426,2496,2567,2639,2712,2786,2861,2937,3014,3092,3171,3251,3332,3414,3497,3581,3666,3752,3839,3927,4016,4106,4197,4289,4382,4476,4571,4667,4764]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]},"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while n<=k:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 0, identity)":[[1],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 0, identity)":[[11],[11,12,14,17,21,26,32,39,47,56,66,77,89,102,116,131,147,164,182,201,221,242,264,287,311,336,362,389,417,446,476,507,539,572,606,641,677,714,752,791,831,872,914,957,1001,1046,1092,1139,1187,1236,1286,1337,1389,1442,1496,1551,1607,1664,1722,1781,1841,1902,1964,2027,2091,2156,2222,2289,2357,2426,2496,2567,2639,2712,2786,2861,2937,3014,3092,3171,3251,3332,3414,3497,3581,3666,3752,3839,3927,4016,4106,4197,4289,4382,4476,4571,4667,4764]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]},"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"11\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"11\n","print accumulate(add, 0, 5, identity)":"0\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k<=n:\n        total, k = combiner(total, term(k)), k+1\n    return total\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while n<=k:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n"},{"Id":374,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":0,"tests":[{"expected":"15","output":"14","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"25\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"24\n","print accumulate(add, 0, 5, identity)":"14\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":377,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":30,"tests":[{"expected":"72","output":"38","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    k=1\n    if combiner==add:\n        total=0\n    elif combiner==mul:\n        total=1\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return combiner(base,total)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    return combiner(base, total) =>           \r\n    return base + total          <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    if combiner==add:\r\n        total = 0\r\n    elif combiner==mul:\r\n        total = 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return combiner(base, total)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    if combiner==add:\r\n        total = 0\r\n    elif combiner==mul:\r\n        total = 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return combiner(base, total)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    if combiner==add:\r\n        total = 0\r\n    elif combiner==mul:\r\n        total = 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return base+total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"38\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    if combiner == add:\n        total = 0\n    elif combiner == mul:\n        total = 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return combiner(base, total)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    k=1\n    if combiner==add:\n        total=0\n    elif combiner==mul:\n        total=1\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return base+total\n"},{"Id":379,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":14,"tests":[{"expected":"15","output":"16","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    counter=1\n    base=1\n    while counter<=n:\n        total=combiner(term(counter),total)\n        counter+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    total = base =>           \r\n    total = 1    <=           \r\n    base = 1     <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    counter = 1\r\n    base = 1\r\n    while counter<=n:\r\n        total = combiner(term(counter), total)\r\n        counter += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    counter = 1\r\n    base = 1\r\n    while counter<=n:\r\n        total = combiner(term(counter), total)\r\n        counter += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[1,4,36]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[1,2,4,7,11,16]],"print accumulate(add, 11, 0, identity)":[[11],[1]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[1,2,6,15]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[1,2,4,7,11,16]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 1\r\n    counter = 1\r\n    base = 1\r\n    while counter<=n:\r\n        total = combiner(term(counter), total)\r\n        counter += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[1,4,36]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[1,2,4,7,11,16]],"print accumulate(add, 11, 0, identity)":[[11],[1]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[1,2,6,15]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[1,2,4,7,11,16]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"36\n","print accumulate(add, 11, 5, identity)":"16\n","print accumulate(add, 11, 0, identity)":"1\n","print accumulate(add, 11, 3, square)":"15\n","print accumulate(add, 0, 5, identity)":"16\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1\n    while counter <= n:\n        total = combiner(term(counter), total)\n        counter += 1\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=1\n    counter=1\n    base=1\n    while counter<=n:\n        total=combiner(term(counter),total)\n        counter+=1\n    return total\n"},{"Id":380,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":26,"tests":[{"expected":"15","output":"5","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    counter=1\n    while counter<=n:\n        k=term(counter)\n        total=combiner(total,k)\n        counter=counter+1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n        total = combiner (total, k) =>           \r\n        total = combiner (base, k)  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    counter = 1\r\n    while counter<=n:\r\n        k = term(counter)\r\n        total = combiner(total, k)\r\n        counter = counter+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    counter = 1\r\n    while counter<=n:\r\n        k = term(counter)\r\n        total = combiner(total, k)\r\n        counter = counter+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8,18]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,13,14,15,16]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,15,20]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    counter = 1\r\n    while counter<=n:\r\n        k = term(counter)\r\n        total = combiner(base, k)\r\n        counter = counter+1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8,18]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,13,14,15,16]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,15,20]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"18\n","print accumulate(add, 11, 5, identity)":"16\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"20\n","print accumulate(add, 0, 5, identity)":"5\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1    \n    while counter <= n:\n        k = term (counter)\n        total = combiner (total, k)\n        counter = counter + 1\n    return total \n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    counter=1\n    while counter<=n:\n        k=term(counter)\n        total=combiner(base,k)\n        counter=counter+1\n    return total\n"},{"Id":382,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":13,"tests":[{"expected":"11","output":"12","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def helper(k,total):\n        if n<=k:\n            return combiner(term(n),total)\n        else:\n            total=combiner(term(k),total)\n        return helper(k+1,total)\n    return helper(1,base)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n        if n == 0:       =>           \r\n            return total =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(k, total):\r\n        if n<=k:\r\n            return combiner(term(n), total)\r\n        else:\r\n            total = combiner(term(k), total)\r\n        return helper(k+1, total)\r\n    return helper(1, base)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(k, total):\r\n        if n<=k:\r\n            return combiner(term(n), total)\r\n        else:\r\n            total = combiner(term(k), total)\r\n        return helper(k+1, total)\r\n    return helper(1, base)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(k, total):\r\n        if n<=k:\r\n            return combiner(term(k), total)\r\n        else:\r\n            total = combiner(term(k), total)\r\n        return helper(k+1, total)\r\n    return helper(1, base)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"12\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(k,total):\n        if n == 0:\n            return total\n        if n <= k:\n            return combiner(term(k),total)\n        else:\n            total = combiner(term(k),total)\n        return helper (k+1, total)\n    return helper(1,base)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def helper(k,total):\n        if n<=k:\n            return combiner(term(k),total)\n        else:\n            total=combiner(term(k),total)\n        return helper(k+1,total)\n    return helper(1,base)\n"},{"Id":384,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":13,"tests":[{"expected":"11","output":"12","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    ans=combiner(base,term(1))\n    i=2\n    while i<=n:\n        ans=combiner(ans,term(i))\n        i+=1\n    return ans\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n    if n==0:                          =>           \r\n        return base                   =>           \r\n        ans=combiner(base,term(1))    =>           \r\n        i=2                           =>           \r\n        while i<=n:                   =>           \r\n            ans=combiner(ans,term(i)) =>           \r\n            i+=1                      =>           \r\n        return ans                    =>           \r\n    else:                             =>           \r\n    ans=combiner(base,term(1))        <=           \r\n    i=2                               <=           \r\n    while i<=n:                       <=           \r\n        ans=combiner(ans,term(i))     <=           \r\n        i+=1                          <=           \r\n    return ans                        <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    ans = combiner(base, term(1))\r\n    i = 2\r\n    while i<=n:\r\n        ans = combiner(ans, term(i))\r\n        i += 1\r\n    return ans","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    ans = combiner(base, term(1))\r\n    i = 2\r\n    while i<=n:\r\n        ans = combiner(ans, term(i))\r\n        i += 1\r\n    return ans","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{},"x":{},"ans":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    ans = combiner(base, term(1))\r\n    i = 2\r\n    while i<=n:\r\n        ans = combiner(ans, term(i))\r\n        i += 1\r\n    return ans","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"i":{},"x":{},"ans":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"12\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        ans=combiner(base,term(1))\n        i=2\n        while i<=n:\n            ans=combiner(ans,term(i))\n            i+=1\n        return ans\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    ans=combiner(base,term(1))\n    i=2\n    while i<=n:\n        ans=combiner(ans,term(i))\n        i+=1\n    return ans\n"},{"Id":385,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":42,"tests":[{"expected":"15","output":"RecursionError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumulate(combiner, base, n, term))   <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    if n < 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":null,"print accumulate(add, 11, 5, identity)":null,"print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":null,"print accumulate(add, 0, 5, identity)":null},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n<1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n,term))\n"},{"Id":388,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":8,"tests":[{"expected":"15","output":"UnboundLocalError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    term_total=term(1)\n    i=2\n    if n==0:\n        term_total=0\n    while i<=n:\n        term_total=combiner(term_total,term(i))\n        i=i+1\n    return combiner(base,term_total)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    term_total = term(1) =>           \r\n    term_total = term(i) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    term_total = term(1)\r\n    i = 2\r\n    if n==0:\r\n        term_total = 0\r\n    while i<=n:\r\n        term_total = combiner(term_total, term(i))\r\n        i = i+1\r\n    return combiner(base, term_total)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    term_total = term(1)\r\n    i = 2\r\n    if n==0:\r\n        term_total = 0\r\n    while i<=n:\r\n        term_total = combiner(term_total, term(i))\r\n        i = i+1\r\n    return combiner(base, term_total)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    term_total = term(i)\r\n    i = 2\r\n    if n==0:\r\n        term_total = 0\r\n    while i<=n:\r\n        term_total = combiner(term_total, term(i))\r\n        i = i+1\r\n    return combiner(base, term_total)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    term_total = term(i)","UnboundLocalError: local variable 'i' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    term_total = term(1)\n    i = 2\n    if n == 0:\n        term_total = 0\n    while i <= n:\n        term_total = combiner(term_total, term(i))\n        i = i + 1\n    return combiner(base, term_total)\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    term_total=term(i)\n    i=2\n    if n==0:\n        term_total=0\n    while i<=n:\n        term_total=combiner(term_total,term(i))\n        i=i+1\n    return combiner(base,term_total)\n"},{"Id":390,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":4,"tests":[{"expected":"15","output":"TypeError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    x=1\n    while x<=n:\n        total=combiner(total,term(x))\n        x=x+1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n                                          =>           \r\n        total = combiner(total,term(x))   =>           \r\n                                          =>           \r\n        total = combiner((total,term(x))) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    x = 1\r\n    while x<=n:\r\n        total = combiner(total, term(x))\r\n        x = x+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    x = 1\r\n    while x<=n:\r\n        total = combiner(total, term(x))\r\n        x = x+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    x = 1\r\n    while x<=n:\r\n        total = combiner(total, term(x))\r\n        x = x+1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    total = combiner((total,term(x)))","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total = base\n    x = 1\n    while x <= n:\n        total = combiner(total,term(x))\n        x = x + 1\n    return total\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    x=1\n    while x<=n:\n        total=combiner(total,term(x))\n        x=x+1\n    return total\n"},{"Id":392,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":0,"tests":[{"expected":"15","output":"14","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"25\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"24\n","print accumulate(add, 0, 5, identity)":"14\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":393,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":3,"tests":[{"expected":"15","output":"0","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    while n>0:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(n)) =>           \r\n        combiner(total, term(n))         <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>0:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>0:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26],[11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15],[0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>0:\r\n        combiner(total, term(n))\r\n        n -= 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26],[11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15],[0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"11\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"11\n","print accumulate(add, 0, 5, identity)":"0\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n\n    if n == 0:\n    \treturn combiner(base)\n    else:\n\t\tcombiner(term(n), term(n - 1))\n\n\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # def addition(n, term):\n    # \tif n == 0:\n    # \t\treturn 0\n    # \telse:\n    # \t\t# print(term(n) + addition(n-1, term))\n    # \t\treturn term(n) + addition(n-1, term)\n    total = base\n    while n > 0:\n    \ttotal = combiner(total, term(n))\n    \tn -= 1\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    while n>0:\n        combiner(total,term(n))\n        n-=1\n    return total\n"},{"Id":395,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":45,"tests":[{"expected":"26","output":"RecursionError","input":"accumulate(add, 11, 5, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    if n == 0:    =>           \r\n    if n == base: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==base:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if n == base:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     26","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast)))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"18\n","print accumulate(add, 11, 5, identity)":null,"print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":null,"print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    \n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==base:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":397,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n == 1:      <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    elif n == 1:\n    \treturn combiner(base, term(n))\n    else:\n    \treturn combiner(term(n), accumulate(combiner, base, n-1, term)) \n    \n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":399,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":17,"tests":[{"expected":"15","output":"25","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    result=base\n    k=1\n    while k<=n:\n        result=combiner(result,term(k))\n        k+=1\n    return result\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        result = combiner(result, term(k)) =>           \r\n        result = combiner(result, term(n)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    k = 1\r\n    while k<=n:\r\n        result = combiner(result, term(k))\r\n        k += 1\r\n    return result","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    k = 1\r\n    while k<=n:\r\n        result = combiner(result, term(k))\r\n        k += 1\r\n    return result","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"result":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,18,162,1458]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,16,21,26,31,36]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,20,29,38]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,5,10,15,20,25]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    k = 1\r\n    while k<=n:\r\n        result = combiner(result, term(n))\r\n        k += 1\r\n    return result","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast)))))))))","sequence_comparison_diff":{"result":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,18,162,1458]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,16,21,26,31,36]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,20,29,38]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,5,10,15,20,25]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"1458\n","print accumulate(add, 11, 5, identity)":"36\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"38\n","print accumulate(add, 0, 5, identity)":"25\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\"\"\"\n    result = base\n    k = 1\n    while k <= n:\n        result = combiner(result, term(k))\n        k += 1\n    return result\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    result=base\n    k=1\n    while k<=n:\n        result=combiner(result,term(n))\n        k+=1\n    return result\n"},{"Id":400,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"1\n2\n3\n72\n","print accumulate(add, 11, 5, identity)":"1\n2\n3\n4\n5\n26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"1\n2\n3\n25\n","print accumulate(add, 0, 5, identity)":"1\n2\n3\n4\n5\n15\n"},"group_id":20,"tests":[{"expected":"15","output":"1","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def helper(i):\n        print i\n        if i==n:\n            return term(n)\n        else:\n            return combiner(term(i),helper(i+1))\n    if n==0:\n        return base\n    else:\n        return combiner(helper(1),base)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n        print(i) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i):\r\n        print(i)\r\n        if i==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(i), helper(i+1))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(helper(1), base)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i):\r\n        print(i)\r\n        if i==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(i), helper(i+1))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(helper(1), base)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i):\r\n        print(i)\r\n        if i==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(i), helper(i+1))\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(helper(1), base)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","2","3","4","5","15","","# Error: expected","#     15","# but got","#     1","#     2","#     3","#     4","#     5","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"1\n2\n3\n72\n","print accumulate(add, 11, 5, identity)":"1\n2\n3\n4\n5\n26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"1\n2\n3\n25\n","print accumulate(add, 0, 5, identity)":"1\n2\n3\n4\n5\n15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i):\n        if i == n:\n            return term(n)\n        else:\n            return combiner(term(i), helper(i+1))\n\n    if n == 0:\n        return base\n    else:\n        return combiner(helper(1), base)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def helper(i):\n        print i\n        if i==n:\n            return term(n)\n        else:\n            return combiner(term(i),helper(i+1))\n    if n==0:\n        return base\n    else:\n        return combiner(helper(1),base)\n"},{"Id":402,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    base=combiner(base,term(n))\n    if n>1:\n        return accumulate(combiner,base,n-1,term)\n    else:\n        return base\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n    if n> 1: =>           \r\n    if n> 0: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    base = combiner(base, term(n))\r\n    if n>1:\r\n        return accumulate(combiner, base, n-1, term)\r\n    else:\r\n        return base","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    base = combiner(base, term(n))\r\n    if n>1:\r\n        return accumulate(combiner, base, n-1, term)\r\n    else:\r\n        return base","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18],[2,18,72,0,72,18]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,2,3],[3,2,1,0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5,4,3,2,1,0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,2,3],[3,2,1,0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5,4,3,2,1,0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    base = combiner(base, term(n))\r\n    if n>0:\r\n        return accumulate(combiner, base, n-1, term)\r\n    else:\r\n        return base","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18],[2,18,72,0,72,18]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,2,3],[3,2,1,0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5,4,3,2,1,0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,2,3],[3,2,1,0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5,4,3,2,1,0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    base =  combiner(base,term(n))\n    if n> 1:\n        return accumulate(combiner, base, n-1, term)\n    else:\n        return base\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    base=combiner(base,term(n))\n    if n>0:\n        return accumulate(combiner,base,n-1,term)\n    else:\n        return base\n"},{"Id":403,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<1:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                                     SideIndicator\r\n-----------                                                                     -------------\r\n    next_term= accumulate(combiner,term(n), n-1, term)                          =>           \r\n    return combiner(base, next_term)                                            =>           \r\n    if n<=0:                                                                    =>           \r\n    if n<1:                                                                     <=           \r\n    return combiner(base, combiner(term(n), accumulate(combiner,0, n-1, term))) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<1:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<1:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2],[2,0,2]],"print accumulate(add, 11, 5, identity)":[[11],[11,0,11]],"print accumulate(add, 11, 3, square)":[[11],[11,0,11]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<1:\r\n        return base\r\n    return combiner(base, combiner(term(n), accumulate(combiner, 0, n-1, term)))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))), InOrderSort(ast)))))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2],[2,0,2]],"print accumulate(add, 11, 5, identity)":[[11],[11,0,11]],"print accumulate(add, 11, 3, square)":[[11],[11,0,11]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"def term2(combiner, n, term):\n        if combiner==add and n<=0:\n            return 0\n        elif combiner==mul and n<=0:\n            return 1\n        else:\n            return combiner(term(n), term2(combiner, n-1, term))\"\"\"\n\n    if n<=0:\n        return base\n    next_term= accumulate(combiner,term(n), n-1, term)\n    return combiner(base, next_term)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n<1:\n        return base\n    return combiner(base,combiner(term(n),accumulate(combiner,0,n-1,term)))\n"},{"Id":404,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":7,"tests":[{"expected":"25","output":"135","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def accumulate_combiner(x,num):\n        if num==0:\n            return x\n        else:\n            return accumulate_combiner(combiner(x,term(num)),num-1)\n    return accumulate_combiner(base,n)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n    return accumulate_combiner(base, n)       =>           \r\n    return accumulate_combiner(term(base), n) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulate_combiner(x, num):\r\n        if num==0:\r\n            return x\r\n        else:\r\n            return accumulate_combiner(combiner(x, term(num)), num-1)\r\n    return accumulate_combiner(base, n)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulate_combiner(x, num):\r\n        if num==0:\r\n            return x\r\n        else:\r\n            return accumulate_combiner(combiner(x, term(num)), num-1)\r\n    return accumulate_combiner(base, n)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[2,3,18,2,72,1,72,18,2],[2,4,3,36,2,144,1,144,36,4]],"print accumulate(add, 11, 3, square)":[[11,3,20,2,24,1,25,24,20,11],[11,121,3,130,2,134,1,135,134,130,121]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulate_combiner(x, num):\r\n        if num==0:\r\n            return x\r\n        else:\r\n            return accumulate_combiner(combiner(x, term(num)), num-1)\r\n    return accumulate_combiner(term(base), n)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[2,3,18,2,72,1,72,18,2],[2,4,3,36,2,144,1,144,36,4]],"print accumulate(add, 11, 3, square)":[[11,3,20,2,24,1,25,24,20,11],[11,121,3,130,2,134,1,135,134,130,121]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"144\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"135\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def accumulate_combiner(x, num):\n        if num == 0:\n            return x\n        else:\n            return accumulate_combiner(combiner(x, term(num)), num-1)\n    return accumulate_combiner(base, n)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def accumulate_combiner(x,num):\n        if num==0:\n            return x\n        else:\n            return accumulate_combiner(combiner(x,term(num)),num-1)\n    return accumulate_combiner(term(base),n)\n"},{"Id":405,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":14,"tests":[{"expected":"15","output":"16","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n>0:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n    else:\n        return combiner(base,1)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        return base              =>           \r\n        return combiner(base, 1) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n>0:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    else:\r\n        return combiner(base, 1)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n>0:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    else:\r\n        return combiner(base, 1)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n>0:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    else:\r\n        return combiner(base, 1)\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"27\n","print accumulate(add, 11, 0, identity)":"12\n","print accumulate(add, 11, 3, square)":"26\n","print accumulate(add, 0, 5, identity)":"16\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n > 0:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n    else:\n        return base\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n>0:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n    else:\n        return combiner(base,1)\nfrom operator import add,mul\n"},{"Id":406,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":3,"tests":[{"expected":"15","output":"0","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if term(n)==0:\n        return base\n    return combiner(base,accumulate(combiner,term(n),n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    if term(n)==0:    =>           \r\n    if term(base)==0: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if term(n)==0:\r\n        return base\r\n    return combiner(base, accumulate(combiner, term(n), n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if term(n)==0:\r\n        return base\r\n    return combiner(base, accumulate(combiner, term(n), n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,9,4,1,4,9,2],[2,9,4,1,0,1,4,9,2]],"print accumulate(add, 11, 5, identity)":[[11,5,4,3,2,1,2,3,4,5,11],[11,5,4,3,2,1,0,1,2,3,4,5,11]],"print accumulate(add, 11, 0, identity)":[[11],[11,0,11]],"print accumulate(add, 11, 3, square)":[[11,9,4,1,4,9,11],[11,9,4,1,0,1,4,9,11]],"print accumulate(add, 0, 5, identity)":[[0,5,4,3,2,1,2,3,4,5,0],[0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0],[2,3,9,2,4,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0],[11,5,4,3,2,1,0]],"print accumulate(add, 11, 0, identity)":[[0],[11,0]],"print accumulate(add, 11, 3, square)":[[3,2,1,0],[11,3,9,2,4,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0],[0]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,0,-1,0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,0,-1,0,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,0,-1,0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if term(base)==0:\r\n        return base\r\n    return combiner(base, accumulate(combiner, term(n), n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,9,4,1,4,9,2],[2,9,4,1,0,1,4,9,2]],"print accumulate(add, 11, 5, identity)":[[11,5,4,3,2,1,2,3,4,5,11],[11,5,4,3,2,1,0,1,2,3,4,5,11]],"print accumulate(add, 11, 0, identity)":[[11],[11,0,11]],"print accumulate(add, 11, 3, square)":[[11,9,4,1,4,9,11],[11,9,4,1,0,1,4,9,11]],"print accumulate(add, 0, 5, identity)":[[0,5,4,3,2,1,2,3,4,5,0],[0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0],[2,3,9,2,4,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0],[11,5,4,3,2,1,0]],"print accumulate(add, 11, 0, identity)":[[0],[11,0]],"print accumulate(add, 11, 3, square)":[[3,2,1,0],[11,3,9,2,4,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0],[0]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,0,-1,0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,0,-1,0,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,0,-1,0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"0\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if term(n)==0:\n        return base\n    return combiner(base, accumulate(combiner, term(n), n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if term(base)==0:\n        return base\n    return combiner(base,accumulate(combiner,term(n),n-1,term))\n"},{"Id":407,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":47,"tests":[{"expected":"","output":"","input":""}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif True:\n        accumulating=combiner(term(n),base)\n        return accumulate(combiner,accumulating,n-1,term)\n    else:\n        return accumulate(a,accumulating,n-1,term)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                                      SideIndicator\r\n-----------                                                                      -------------\r\n    \"\"\"Return the result of combining the first N terms in a sequence.  The      =>           \r\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a      =>           \r\n    two-argument function.  Treating COMBINER as if it were a binary operator,   =>           \r\n    the return value is                                                          =>           \r\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)              =>           \r\n#     \"\"\"Return the result of combining the first N terms in a sequence.  The    <=           \r\n#     terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a    <=           \r\n#     two-argument function.  Treating COMBINER as if it were a binary operator, <=           \r\n#     the return value is                                                        <=           \r\n#         BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)            <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif True:\r\n        accumulating = combiner(term(n), base)\r\n        return accumulate(combiner, accumulating, n-1, term)\r\n    else:\r\n        return accumulate(a, accumulating, n-1, term)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif True:\r\n        accumulating = combiner(term(n), base)\r\n        return accumulate(combiner, accumulating, n-1, term)\r\n    else:\r\n        return accumulate(a, accumulating, n-1, term)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif True:\r\n        accumulating = combiner(term(n), base)\r\n        return accumulate(combiner, accumulating, n-1, term)\r\n    else:\r\n        return accumulate(combiner, accumulating, n-1, term)\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","","-- No doctests found for accumulate --","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-a)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n#     >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n#     15\n#     >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n#     26\n#     >>> accumulate(add, 11, 0, identity) # 11\n#     11\n#     >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n#     25\n#     >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n#     72\n#     \"\"\"\n    if n == 0:\n        return base\n    elif True:\n        accumulating = combiner(term(n), base)\n        return accumulate(combiner, accumulating, n-1, term)        \n    else:\n        return accumulate(combiner, accumulating, n-1, term)  \n\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif True:\n        accumulating=combiner(term(n),base)\n        return accumulate(combiner,accumulating,n-1,term)\n    else:\n        return accumulate(combiner,accumulating,n-1,term)\nfrom operator import add,mul\n"},{"Id":410,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":11,"tests":[{"expected":"25","output":"17","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    counter=1\n    while counter<=n:\n        total=combiner(total,term(counter))\n        counter=counter+1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                     SideIndicator\r\n-----------                                     -------------\r\n        total = combiner(total, term(counter))  =>           \r\n        total = combiner(total, counter)        <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    counter = 1\r\n    while counter<=n:\r\n        total = combiner(total, term(counter))\r\n        counter = counter+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    counter = 1\r\n    while counter<=n:\r\n        total = combiner(total, term(counter))\r\n        counter = counter+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,4,12]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,14,17]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    counter = 1\r\n    while counter<=n:\r\n        total = combiner(total, counter)\r\n        counter = counter+1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,4,12]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,14,17]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"12\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"17\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1\n    while counter <= n:\n        total = combiner(total, term(counter)) \n        counter = counter + 1\n    return total\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    counter=1\n    while counter<=n:\n        total=combiner(total,counter)\n        counter=counter+1\n    return total\n"},{"Id":412,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":8,"tests":[{"expected":"15","output":"UnboundLocalError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        total=combiner(base,term(1))\n        i=2\n        while i<=n:\n            total=combiner(total,term(i))\n            i+=1\n        return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n        i = 1  =>           \r\n        i += 1 =>           \r\n        i = 2  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total = combiner(base, term(1))\r\n        i = 2\r\n        while i<=n:\r\n            total = combiner(total, term(i))\r\n            i += 1\r\n        return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total = combiner(base, term(1))\r\n        i = 2\r\n        while i<=n:\r\n            total = combiner(total, term(i))\r\n            i += 1\r\n        return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total = combiner(base, term(i))\r\n        i = 2\r\n        while i<=n:\r\n            total = combiner(total, term(i))\r\n            i += 1\r\n        return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    total = combiner(base, term(i))","UnboundLocalError: local variable 'i' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0: \n        return base\n    else: \n        i = 1\n        total = combiner(base, term(i))\n        i += 1\n        while i <= n:\n            total = combiner(total, term(i))\n            i += 1\n        return total \n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        total=combiner(base,term(i))\n        i=2\n        while i<=n:\n            total=combiner(total,term(i))\n            i+=1\n        return total\n"},{"Id":413,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":48,"tests":[{"expected":"15","output":"40500","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    counter=1\n    index=2\n    total=combiner(base,term(1))\n    def helper(combiner,base,n,term,counter,index,total):\n        if n==0:\n            return base\n        if n==1:\n            return total\n        if n>counter or n>index:\n            total=combiner(total,term(index))\n            counter+=1\n            index+=1\n            return 1*helper(combiner,base,n,term,counter,index,total)\n        return total\n    return helper(combiner,base,n,term,counter,index,total)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                                     SideIndicator\r\n-----------                                                                     -------------\r\n        if n > index:                                                           =>           \r\n            return helper(combiner, base, n, term, counter, index, total)       =>           \r\n        return combiner(total, term(n))                                         =>           \r\n        if n > counter or n > index:                                            <=           \r\n            return total*helper(combiner, base, n, term, counter, index, total) <=           \r\n        return total                                                            <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    index = 2\r\n    total = combiner(base, term(1))\r\n    def helper(combiner, base, n, term, counter, index, total):\r\n        if n==0:\r\n            return base\r\n        if n==1:\r\n            return total\r\n        if n>counter or n>index:\r\n            total = combiner(total, term(index))\r\n            counter += 1\r\n            index += 1\r\n            return 1*helper(combiner, base, n, term, counter, index, total)\r\n        return total\r\n    return helper(combiner, base, n, term, counter, index, total)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    index = 2\r\n    total = combiner(base, term(1))\r\n    def helper(combiner, base, n, term, counter, index, total):\r\n        if n==0:\r\n            return base\r\n        if n==1:\r\n            return total\r\n        if n>counter or n>index:\r\n            total = combiner(total, term(index))\r\n            counter += 1\r\n            index += 1\r\n            return 1*helper(combiner, base, n, term, counter, index, total)\r\n        return total\r\n    return helper(combiner, base, n, term, counter, index, total)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    index = 2\r\n    total = combiner(base, term(1))\r\n    def helper(combiner, base, n, term, counter, index, total):\r\n        if n==0:\r\n            return base\r\n        if n==1:\r\n            return total\r\n        if n>counter or n>index:\r\n            total = combiner(total, term(index))\r\n            counter += 1\r\n            index += 1\r\n            return total*helper(combiner, base, n, term, counter, index, total)\r\n        return total\r\n    return helper(combiner, base, n, term, counter, index, total)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","40500","","# Error: expected","#     15","# but got","#     40500","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"41472\n","print accumulate(add, 11, 5, identity)":"3378648\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"10000\n","print accumulate(add, 0, 5, identity)":"40500\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    index = 2\n    total = combiner(base, term(1))\n    def helper(combiner, base, n, term, counter, index, total):\n        if n == 0: \n            return base\n        if n == 1:\n            return total\n        if n > index:\n            total = combiner(total, term(index))\n            counter += 1\n            index += 1\n            return helper(combiner, base, n, term, counter, index, total)\n        return combiner(total, term(n))\n    return helper(combiner, base, n, term, counter, index, total)\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    counter=1\n    index=2\n    total=combiner(base,term(1))\n    def helper(combiner,base,n,term,counter,index,total):\n        if n==0:\n            return base\n        if n==1:\n            return total\n        if n>counter or n>index:\n            total=combiner(total,term(index))\n            counter+=1\n            index+=1\n            return total*helper(combiner,base,n,term,counter,index,total)\n        return total\n    return helper(combiner,base,n,term,counter,index,total)\n"},{"Id":416,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def accumulate_helper(n,term):\n        counter=n-1\n        listen=[base]\n        if counter<0:\n            result=0\n        else:\n            result=combiner(term(n),term(counter))\n        while counter>1:\n            counter-=1\n            x=term(counter)\n            result=combiner(x,result)\n        return result\n    result=accumulate_helper(n,term)\n    return combiner(base,result)\n    print listen\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n        while counter>1: =>           \r\n        while counter>0: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulate_helper(n, term):\r\n        counter = n-1\r\n        listen = [base]\r\n        if counter<0:\r\n            result = 0\r\n        else:\r\n            result = combiner(term(n), term(counter))\r\n        while counter>1:\r\n            counter -= 1\r\n            x = term(counter)\r\n            result = combiner(x, result)\r\n        return result\r\n    result = accumulate_helper(n, term)\r\n    return combiner(base, result)\r\n    print(listen)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulate_helper(n, term):\r\n        counter = n-1\r\n        listen = [base]\r\n        if counter<0:\r\n            result = 0\r\n        else:\r\n            result = combiner(term(n), term(counter))\r\n        while counter>1:\r\n            counter -= 1\r\n            x = term(counter)\r\n            result = combiner(x, result)\r\n        return result\r\n    result = accumulate_helper(n, term)\r\n    return combiner(base, result)\r\n    print(listen)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"result":{"print accumulate(mul, 2, 3, square)":[[36],[36,0]]},"counter":{"print accumulate(mul, 2, 3, square)":[[2,1],[2,1,0]],"print accumulate(add, 11, 5, identity)":[[4,3,2,1],[4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[2,1],[2,1,0]],"print accumulate(add, 0, 5, identity)":[[4,3,2,1],[4,3,2,1,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulate_helper(n, term):\r\n        counter = n-1\r\n        listen = [base]\r\n        if counter<0:\r\n            result = 0\r\n        else:\r\n            result = combiner(term(n), term(counter))\r\n        while counter>0:\r\n            counter -= 1\r\n            x = term(counter)\r\n            result = combiner(x, result)\r\n        return result\r\n    result = accumulate_helper(n, term)\r\n    return combiner(base, result)\r\n    print(listen)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"result":{"print accumulate(mul, 2, 3, square)":[[36],[36,0]]},"counter":{"print accumulate(mul, 2, 3, square)":[[2,1],[2,1,0]],"print accumulate(add, 11, 5, identity)":[[4,3,2,1],[4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[2,1],[2,1,0]],"print accumulate(add, 0, 5, identity)":[[4,3,2,1],[4,3,2,1,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulate_helper(n, term):\n        counter=n-1\n        listen = [base]\n        if counter < 0:\n            result = 0\n        else:\n            result = combiner(term(n), term(counter))\n        while counter>1:\n            counter-=1\n            x = term(counter)\n            result = combiner(x, result)\n        return result\n    result = accumulate_helper(n, term)\n    return combiner(base, result)\n    print(listen)\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def accumulate_helper(n,term):\n        counter=n-1\n        listen=[base]\n        if counter<0:\n            result=0\n        else:\n            result=combiner(term(n),term(counter))\n        while counter>0:\n            counter-=1\n            x=term(counter)\n            result=combiner(x,result)\n        return result\n    result=accumulate_helper(n,term)\n    return combiner(base,result)\n    print listen\n"},{"Id":417,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":3,"tests":[{"expected":"15","output":"0","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        base=combiner(term(n),base)\n        return accumulate(combiner,base,n-1,term)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n        base = combiner(term(n), base)  =>           \r\n        start = combiner(term(n), base) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        base = combiner(term(n), base)\r\n        return accumulate(combiner, base, n-1, term)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        base = combiner(term(n), base)\r\n        return accumulate(combiner, base, n-1, term)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18],[2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26,25,23,20,16],[11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25,24,20],[11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15,14,12,9,5],[0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        start = combiner(term(n), base)\r\n        return accumulate(combiner, base, n-1, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18],[2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26,25,23,20,16],[11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25,24,20],[11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15,14,12,9,5],[0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"11\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"11\n","print accumulate(add, 0, 5, identity)":"0\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        base = combiner(term(n), base)\n        return accumulate(combiner, base, n-1, term)\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        start=combiner(term(n),base)\n        return accumulate(combiner,base,n-1,term)\n"},{"Id":418,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":11,"tests":[{"expected":"25","output":"17","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    i=1\n    total=base\n    if n==0:\n        return total\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total = combiner(total, i)       <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    total = base\r\n    if n==0:\r\n        return total\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    total = base\r\n    if n==0:\r\n        return total\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,4,12]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,14,17]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    total = base\r\n    if n==0:\r\n        return total\r\n    while i<=n:\r\n        total = combiner(total, i)\r\n        i += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,4,12]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,14,17]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"12\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"17\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = base\n    if n == 0:\n        return total\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    i=1\n    total=base\n    if n==0:\n        return total\n    while i<=n:\n        total=combiner(total,i)\n        i+=1\n    return total\n"},{"Id":421,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":24,"tests":[{"expected":"72","output":"16","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (i,total)=(1,base)\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n                                         =>           \r\n        total += term(i)                 <=           \r\n                                         <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    i, total = 1, base\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i, total = 1, base\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,3,7,16]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    i, total = 1, base\r\n    while i<=n:\r\n        total += term(i)\r\n        i += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","16","","# Error: expected","#     72","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i))))))))))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,3,7,16]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"16\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n < 1:\n    #     return base\n    # else:\n    #     return combiner(base, accumulate(combiner, term(n), n-1, term))\n\n    # if n < 1:\n    #     return combiner(base, term(n))\n    # else:\n    #     return accumulate(combiner, term(n), n-1, term)\n\n    i, total = 1, base\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (i,total)=(1,base)\n    while i<=n:\n        total+=term(i)\n        i+=1\n    return total\n"},{"Id":422,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":4,"tests":[{"expected":"15","output":"TypeError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumulate(n-1))                       <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(n-1))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(n-1))","TypeError: accumulate() missing 3 required positional arguments: 'base', 'n', and 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(n-1))\n"},{"Id":423,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":40,"tests":[{"expected":"15","output":"57","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        (total,next)=(base,1)\n        while next<=n:\n            total=combiner(total,term(next))\n            next+=1\n        return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                     SideIndicator\r\n-----------                                     -------------\r\n            total = combiner(total,term(next))  =>           \r\n            total += combiner(total,term(next)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total, next = base, 1\r\n        while next<=n:\r\n            total = combiner(total, term(next))\r\n            next += 1\r\n        return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total, next = base, 1\r\n        while next<=n:\r\n            total = combiner(total, term(next))\r\n            next += 1\r\n        return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,4,20,200]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,23,48,99,202,409]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,23,50,109]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,4,11,26,57]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        total, next = base, 1\r\n        while next<=n:\r\n            total += combiner(total, term(next))\r\n            next += 1\r\n        return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","57","","# Error: expected","#     15","# but got","#     57","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"AugmentedAssignStatementNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,4,20,200]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,23,48,99,202,409]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,23,50,109]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,4,11,26,57]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"200\n","print accumulate(add, 11, 5, identity)":"409\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"109\n","print accumulate(add, 0, 5, identity)":"57\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n==0:\n    #     return base\n    # else:\n    #     return combiner(term(n),accumulate(combiner,base,n-1,term))\n    if n==0:\n        return base\n    else:\n        total, next = base,1\n        while next<=n:\n            total = combiner(total,term(next))\n            next+=1\n        return total\n\n        \n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        (total,next)=(base,1)\n        while next<=n:\n            total+=combiner(total,term(next))\n            next+=1\n        return total\n"},{"Id":427,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":49,"tests":[{"expected":"15_________","output":"15","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    15                                 =>           \r\n    15_________                        <=           \r\n    elif n == 1:                       <=           \r\n        return combiner(base, term(n)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     15_________","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0: \n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n      \n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":428,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":12,"tests":[{"expected":"15","output":"10","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        i=1\n        accumulation=base\n        while i<n+1:\n            accumulation=combiner(accumulation,term(i))\n            i+=1\n        return accumulation\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n        while i < n+1: =>           \r\n        while i < n:   <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        i = 1\r\n        accumulation = base\r\n        while i<n+1:\r\n            accumulation = combiner(accumulation, term(i))\r\n            i += 1\r\n        return accumulation","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        i = 1\r\n        accumulation = base\r\n        while i<n+1:\r\n            accumulation = combiner(accumulation, term(i))\r\n            i += 1\r\n        return accumulation","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,3,4]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3,4]]},"accumulation":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,17,21]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,16]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,6,10]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        i = 1\r\n        accumulation = base\r\n        while i<n:\r\n            accumulation = combiner(accumulation, term(i))\r\n            i += 1\r\n        return accumulation","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,3,4]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3,4]]},"accumulation":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,17,21]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,16]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,6,10]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"8\n","print accumulate(add, 11, 5, identity)":"21\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"16\n","print accumulate(add, 0, 5, identity)":"10\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        i = 1\n        accumulation = base\n        while i < n+1:\n            accumulation = combiner(accumulation, term(i))\n            i += 1\n        return accumulation      \n    \n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        i=1\n        accumulation=base\n        while i<n:\n            accumulation=combiner(accumulation,term(i))\n            i+=1\n        return accumulation\n"},{"Id":430,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":20,"tests":[{"expected":"15","output":"1","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    return total     =>           \r\n        return total <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1,2]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1,2]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n        return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ReferenceNode(node, StartsWithParent(Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), Tutor.synthesis.MagicK), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), Tutor.synthesis.MagicK), 3), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast)))))))","sequence_comparison_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1,2]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1,2]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"12\n","print accumulate(add, 11, 0, identity)":"None\n","print accumulate(add, 11, 3, square)":"12\n","print accumulate(add, 0, 5, identity)":"1\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # k is the next term in the sequence\n\n    total , k = base , 1\n    while k <= n:\n        total, k = combiner(total , term(k)), k + 1\n    return total\n        \n\n        \n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n        return total\n"},{"Id":431,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    i=1\n    combined=base\n    while i<=n:\n        combined=combiner(combined,term(i))\n        i+=1\n    return combined\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    i = 1   =>           \r\n    i = 0   <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    combined = base\r\n    while i<=n:\r\n        combined = combiner(combined, term(i))\r\n        i += 1\r\n    return combined","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    combined = base\r\n    while i<=n:\r\n        combined = combiner(combined, term(i))\r\n        i += 1\r\n    return combined","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]],"print accumulate(add, 11, 0, identity)":[[1],[0,1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]},"combined":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 0\r\n    combined = base\r\n    while i<=n:\r\n        combined = combiner(combined, term(i))\r\n        i += 1\r\n    return combined","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]],"print accumulate(add, 11, 0, identity)":[[1],[0,1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]},"combined":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    combined = base\n    while i <= n:\n        combined = combiner(combined, term(i))\n        i += 1\n    return combined\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    i=0\n    combined=base\n    while i<=n:\n        combined=combiner(combined,term(i))\n        i+=1\n    return combined\n"},{"Id":432,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=0\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n <= 1: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    if n <= 1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n), accumulate(combiner,base,n-1,term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=0\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":433,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":13,"tests":[{"expected":"11","output":"12","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n<=1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n == 0:                         =>           \r\n        return base                    =>           \r\n    if n == 1:                         =>           \r\n    return accumulate(add, 0, n, term) =>           \r\n    return accumulate(mul, 0, n, term) =>           \r\n    if n <= 1:                         <=           \r\n    return _______                     <=           \r\n    return _______                     <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n<=1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n<=1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"12\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":434,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":12,"tests":[{"expected":"15","output":"10","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    count=1\n    answer=base\n    while count<n+1:\n        answer=combiner(answer,term(count))\n        count+=1\n    return answer\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    while count <= n: =>           \r\n                      =>           \r\n    while count < n:  <=           \r\n                      <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    answer = base\r\n    while count<n+1:\r\n        answer = combiner(answer, term(count))\r\n        count += 1\r\n    return answer","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    answer = base\r\n    while count<n+1:\r\n        answer = combiner(answer, term(count))\r\n        count += 1\r\n    return answer","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"answer":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,17,21]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,16]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,6,10]]},"count":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,3,4]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3,4]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    answer = base\r\n    while count<n:\r\n        answer = combiner(answer, term(count))\r\n        count += 1\r\n    return answer","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"answer":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,17,21]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,16]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,6,10]]},"count":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,3,4]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3,4]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"8\n","print accumulate(add, 11, 5, identity)":"21\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"16\n","print accumulate(add, 0, 5, identity)":"10\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    count = 1\n    answer = base\n\n    while count <= n:\n        answer = combiner(answer, term(count) )\n        count +=1\n\n    return answer\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    count=1\n    answer=base\n    while count<n:\n        answer=combiner(answer,term(count))\n        count+=1\n    return answer\n"},{"Id":435,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":0,"tests":[{"expected":"15","output":"14","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    i=n\n    total=base\n    if n==0:\n        return base\n    else:\n        while i>=1:\n            total=combiner(total,term(i))\n            i-=1\n        return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n        while i >= 1: =>           \r\n        while i > 1:  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = n\r\n    total = base\r\n    if n==0:\r\n        return base\r\n    else:\r\n        while i>=1:\r\n            total = combiner(total, term(i))\r\n            i -= 1\r\n        return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = n\r\n    total = base\r\n    if n==0:\r\n        return base\r\n    else:\r\n        while i>=1:\r\n            total = combiner(total, term(i))\r\n            i -= 1\r\n        return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0],[3,2,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1]],"print accumulate(add, 11, 3, square)":[[3,2,1,0],[3,2,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1]]},"total":{"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26],[11,16,20,23,25]],"print accumulate(add, 11, 3, square)":[[11,20,24,25],[11,20,24]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15],[0,5,9,12,14]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = n\r\n    total = base\r\n    if n==0:\r\n        return base\r\n    else:\r\n        while i>1:\r\n            total = combiner(total, term(i))\r\n            i -= 1\r\n        return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\"))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0],[3,2,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1]],"print accumulate(add, 11, 3, square)":[[3,2,1,0],[3,2,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1]]},"total":{"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26],[11,16,20,23,25]],"print accumulate(add, 11, 3, square)":[[11,20,24,25],[11,20,24]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15],[0,5,9,12,14]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"25\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"24\n","print accumulate(add, 0, 5, identity)":"14\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = n\n    total = base \n    if n == 0:\n        return base\n    else:\n        while i >= 1:\n            total = combiner (total, term (i))\n            i -= 1\n        return total\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    i=n\n    total=base\n    if n==0:\n        return base\n    else:\n        while i>1:\n            total=combiner(total,term(i))\n            i-=1\n        return total\n"},{"Id":436,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":40,"tests":[{"expected":"15","output":"57","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    s=base\n    for i in range(1,n+1):\n        s=combiner(s,term(i))\n    return s\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n        s = combiner(s, term(i))  =>           \r\n        s += combiner(s, term(i)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    s = base\r\n    for i in range(1, n+1):\r\n        s = combiner(s, term(i))\r\n    return s","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    s = base\r\n    for i in range(1, n+1):\r\n        s = combiner(s, term(i))\r\n    return s","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"s":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,4,20,200]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,23,48,99,202,409]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,23,50,109]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,4,11,26,57]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    s = base\r\n    for i in range(1, n+1):\r\n        s += combiner(s, term(i))\r\n    return s","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","57","","# Error: expected","#     15","# but got","#     57","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"AugmentedAssignStatementNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"s":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,4,20,200]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,23,48,99,202,409]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,23,50,109]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,4,11,26,57]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"200\n","print accumulate(add, 11, 5, identity)":"409\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"109\n","print accumulate(add, 0, 5, identity)":"57\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    s = base\n    for i in range(1, n + 1):\n        s = combiner(s, term(i))\n    return s\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    s=base\n    for i in range(1,n+1):\n        s+=combiner(s,term(i))\n    return s\n"},{"Id":438,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    k=1\n    total=base\n    if base>n:\n        total=base\n    while k<=n:\n        total=combiner(total,term(k))\n        k+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    if base > 0: =>           \r\n    if base > n: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = base\r\n    if base>n:\r\n        total = base\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = base\r\n    if base>n:\r\n        total = base\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[0,11,12,14,17,21,26]],"print accumulate(add, 11, 0, identity)":[[11],[0,11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[0,11,12,16,25]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = 0\r\n    if base>n:\r\n        total = base\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[0,11,12,14,17,21,26]],"print accumulate(add, 11, 0, identity)":[[11],[0,11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[0,11,12,16,25]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    k = 1\n    total = 0\n    if base > 0:\n        total = base\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n        \n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    k=1\n    total=0\n    if base>n:\n        total=base\n    while k<=n:\n        total=combiner(total,term(k))\n        k+=1\n    return total\n"},{"Id":440,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":50,"tests":[{"expected":"15","output":"11","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<2:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n-0),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))   =>           \r\n        return combiner(term(n-1), accumulate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<2:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n-0), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<2:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n-0), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[2,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[4,3,2,1]],"print accumulate(add, 11, 3, square)":[[3,2,1],[2,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[4,3,2,1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<2:\r\n        return combiner(term(n), base)\r\n    else:\r\n        return combiner(term(n-1), accumulate(combiner, base, n-1, term))\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","11","","# Error: expected","#     15","# but got","#     11","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[2,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[4,3,2,1]],"print accumulate(add, 11, 3, square)":[[3,2,1],[2,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[4,3,2,1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"8\n","print accumulate(add, 11, 5, identity)":"22\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"17\n","print accumulate(add, 0, 5, identity)":"11\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n < 2:\n        return combiner(term(n), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n<2:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n-1),accumulate(combiner,base,n-1,term))\nfrom operator import add,mul\n"},{"Id":441,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        next_acc=combiner(term(n),base)\n        return accumulate(combiner,next_acc,n-1,term)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                              SideIndicator\r\n-----------                                              -------------\r\n        return base                                      =>           \r\n        base = combiner(term(n), base)                   =>           \r\n        return accumulate(combiner, base, n-1, term)     =>           \r\n        return acc                                       <=           \r\n        next_acc = combiner(term(n), acc)                <=           \r\n        return accumulate(combiner, next_acc, n-1, term) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        next_acc = combiner(term(n), base)\r\n        return accumulate(combiner, next_acc, n-1, term)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        next_acc = combiner(term(n), base)\r\n        return accumulate(combiner, next_acc, n-1, term)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18,2],[2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26,25,23,20,16,11],[11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25,24,20,11],[11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15,14,12,9,5,0],[0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return acc\r\n    else:\r\n        next_acc = combiner(term(n), acc)\r\n        return accumulate(combiner, next_acc, n-1, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    next_acc = combiner(term(n), acc)","NameError: name 'acc' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18,2],[2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26,25,23,20,16,11],[11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25,24,20,11],[11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15,14,12,9,5,0],[0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        base = combiner(term(n), base)\n        return accumulate(combiner, base, n-1, term)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return acc\n    else:\n        next_acc=combiner(term(n),acc)\n        return accumulate(combiner,next_acc,n-1,term)\n"},{"Id":442,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    q=base\n    for i in range(1,n+1):\n        q=combiner(q,term(i))\n    return q\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    q=term(1)               =>           \r\n    for i in range(2, n+1): =>           \r\n    q=0                     <=           \r\n    for i in range(1, n+1): <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    q = base\r\n    for i in range(1, n+1):\r\n        q = combiner(q, term(i))\r\n    return q","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    q = base\r\n    for i in range(1, n+1):\r\n        q = combiner(q, term(i))\r\n    return q","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"q":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[0,1,3,6,10,15]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[0,1,5,14]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    q = 0\r\n    for i in range(1, n+1):\r\n        q = combiner(q, term(i))\r\n    return combiner(base, q)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))","sequence_comparison_diff":{"q":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[0,1,3,6,10,15]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[0,1,5,14]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if (n==0): return base\n    q=term(1)\n    for i in range(2, n+1):\n    \tq=combiner(q, term(i))\n    return combiner(base, q)\n    \n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    q=0\n    for i in range(1,n+1):\n        q=combiner(q,term(i))\n    return combiner(base,q)\n"},{"Id":444,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":21,"tests":[{"expected":"15","output":"9","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return combiner(term(n), term(n - 1))                             <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<1:\r\n        return base\r\n    else:\r\n        return combiner(term(n), term(n-1))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","9","","# Error: expected","#     15","# but got","#     9","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"36\n","print accumulate(add, 11, 5, identity)":"9\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"13\n","print accumulate(add, 0, 5, identity)":"9\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n<1:\n        return base\n    else:\n        return combiner(term(n),term(n-1))\n"},{"Id":445,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":30,"tests":[{"expected":"72","output":"38","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def combiner_helper(n):\n        if n==0:\n            return 0\n        elif n==1:\n            return term(n)\n        else:\n            return combiner(term(n),combiner_helper(n-1))\n    return combiner(combiner_helper(n),base)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n    return combiner(combiner_helper(n), base) =>           \r\n    return combiner_helper(n) + base          <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def combiner_helper(n):\r\n        if n==0:\r\n            return 0\r\n        elif n==1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), combiner_helper(n-1))\r\n    return combiner(combiner_helper(n), base)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def combiner_helper(n):\r\n        if n==0:\r\n            return 0\r\n        elif n==1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), combiner_helper(n-1))\r\n    return combiner(combiner_helper(n), base)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def combiner_helper(n):\r\n        if n==0:\r\n            return 0\r\n        elif n==1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), combiner_helper(n-1))\r\n    return combiner_helper(n)+base","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"38\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def combiner_helper(n):\n        if n == 0:\n            return 0\n        elif n == 1:\n            return term(n)\n        else:\n            return combiner(term(n), combiner_helper(n - 1))\n    return combiner(combiner_helper(n), base)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def combiner_helper(n):\n        if n==0:\n            return 0\n        elif n==1:\n            return term(n)\n        else:\n            return combiner(term(n),combiner_helper(n-1))\n    return combiner_helper(n)+base\n"},{"Id":448,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":4,"tests":[{"expected":"15","output":"TypeError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n>0:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n    elif n==1:\n        return combiner(base,term(n))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n        return combiner(base, term(n))\"\"\"          =>           \r\n    return combiner(base, accumulate_helper(1))    =>           \r\n        return combiner(base, term(n))             <=           \r\n    return combiner(base, accumulate_helper(1))\"\"\" <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n>0:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    elif n==1:\r\n        return combiner(base, term(n))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n>0:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\n    elif n==1:\r\n        return combiner(base, term(n))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n>0:\r\n        return combiner(term(n), accumulate(n-1))\r\n    elif n==1:\r\n        return combiner(base, term(n))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate","    return combiner(term(n), accumulate(n-1))","TypeError: accumulate() missing 3 required positional arguments: 'base', 'n', and 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"if n==0:\n        return base\n    elif n>0:\n        return combiner(term(n), accumulate(n-1))\n    elif n==1:\n        return combiner(base, term(n))\"\"\"\n    \n    \n    if n==0:\n        return base\n    def accumulate_helper(i):\n        if i==n:\n            return term(i)\n        else:\n            return combiner(term(i), accumulate_helper(i+1))\n    return combiner(base, accumulate_helper(1))\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n>0:\n        return combiner(term(n),accumulate(n-1))\n    elif n==1:\n        return combiner(base,term(n))\n"},{"Id":450,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":30,"tests":[{"expected":"72","output":"38","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    i=1\n    if combiner==add:\n        total=0\n    else:\n        total=1\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return combiner(base,total)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    total = base        =>           \r\n    return total        =>           \r\n    if combiner == add: <=           \r\n        total = 0       <=           \r\n        total = 1       <=           \r\n    return base+total   <=           \r\n    else:               <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    if combiner==add:\r\n        total = 0\r\n    else:\r\n        total = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return combiner(base, total)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    if combiner==add:\r\n        total = 0\r\n    else:\r\n        total = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return combiner(base, total)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    if combiner==add:\r\n        total = 0\r\n    else:\r\n        total = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return base+total\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"38\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    total = base\n    while i <= n:\n        total = combiner(total,term(i))\n        i += 1\n \n    return total\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    i=1\n    if combiner==add:\n        total=0\n    else:\n        total=1\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return base+total\nfrom operator import add,mul\n"},{"Id":455,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":14,"tests":[{"expected":"15","output":"16","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    final=base\n    x=1\n    while x<=n:\n        final=combiner(term(x),final)\n        x=x+1\n    return final\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n    final = base                                    =>           \r\n    x = 1                                           =>           \r\n    while x <= n:                                   =>           \r\n        final = combiner(term(x), final)            =>           \r\n    # total, k = base, 1                            <=           \r\n    # while k <=n:                                  <=           \r\n    #     total, k = combiner(term(k),total), k + 1 <=           \r\n    # return total                                  <=           \r\n    # total = 1                                     <=           \r\n    # k = base                                      <=           \r\n    # while k <=n:                                  <=           \r\n    #     total = combiner(term(k),total)           <=           \r\n    #     k = k + 1                                 <=           \r\n    # return total                                  <=           \r\n    final = 1                                       <=           \r\n    x = base                                        <=           \r\n    while x <=n:                                    <=           \r\n        final = combiner(term(x),final)             <=           \r\n                                                    <=           \r\n                                                    <=           \r\n                                                    <=           \r\n                                                    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    final = base\r\n    x = 1\r\n    while x<=n:\r\n        final = combiner(term(x), final)\r\n        x = x+1\r\n    return final","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    final = base\r\n    x = 1\r\n    while x<=n:\r\n        final = combiner(term(x), final)\r\n        x = x+1\r\n    return final","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"final":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[1,4,36]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[1]],"print accumulate(add, 11, 0, identity)":[[11],[1]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[1]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[1,2,4,7,11,16]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[2,3,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[11]],"print accumulate(add, 11, 0, identity)":[[1],[11]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[11]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    final = 1\r\n    x = base\r\n    while x<=n:\r\n        final = combiner(term(x), final)\r\n        x = x+1\r\n    return final","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))))))","sequence_comparison_diff":{"final":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[1,4,36]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[1]],"print accumulate(add, 11, 0, identity)":[[11],[1]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[1]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[1,2,4,7,11,16]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[2,3,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[11]],"print accumulate(add, 11, 0, identity)":[[1],[11]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[11]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"36\n","print accumulate(add, 11, 5, identity)":"1\n","print accumulate(add, 11, 0, identity)":"1\n","print accumulate(add, 11, 3, square)":"1\n","print accumulate(add, 0, 5, identity)":"16\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    final = base\n    x = 1\n    while x <= n:\n        final = combiner(term(x), final)\n        x = x + 1\n    return final\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    final=1\n    x=base\n    while x<=n:\n        final=combiner(term(x),final)\n        x=x+1\n    return final\n"},{"Id":456,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    k=0\n    result=base\n    while k<n:\n        (result,k)=(combiner(result,term(k+1)),k+1)\n    return result\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n    result = combiner(base, term(n))                 =>           \r\n    while n>1:                                       =>           \r\n        result, n = combiner(result, term(n-1)), n-1 =>           \r\n    k=0                                              <=           \r\n    result = combiner(base, term(k))                 <=           \r\n    while k<n:                                       <=           \r\n        result, k = combiner(result, term(k+1)), k+1 <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 0\r\n    result = base\r\n    while k<n:\r\n        result, k = combiner(result, term(k+1)), k+1\r\n    return result","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 0\r\n    result = base\r\n    while k<n:\r\n        result, k = combiner(result, term(k+1)), k+1\r\n    return result","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"result":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 0\r\n    result = combiner(base, term(k))\r\n    while k<n:\r\n        result, k = combiner(result, term(k+1)), k+1\r\n    return result","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"result":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result = combiner(base, term(n))\n    while n>1:\n        result, n = combiner(result, term(n-1)), n-1\n    return result\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    k=0\n    result=combiner(base,term(k))\n    while k<n:\n        (result,k)=(combiner(result,term(k+1)),k+1)\n    return result\n"},{"Id":457,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(term(k),total),k+1)\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    total, k = base, 1  =>           \r\n    total, k = start, 1 <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(term(k), total), k+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(term(k), total), k+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = start, 1\r\n    while k<=n:\r\n        total, k = combiner(term(k), total), k+1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    total, k = start, 1","NameError: name 'start' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(term(k), total), k + 1\n    return total\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (total,k)=(start,1)\n    while k<=n:\n        (total,k)=(combiner(term(k),total),k+1)\n    return total\n"},{"Id":458,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    while n>=1:\n        total=combiner(term(n),total)\n        n-=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        if combiner == mul and n == 0: =>           \r\n            return total               =>           \r\n                                       =>           \r\n    return total                       =>           \r\n    return total                       <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=1:\r\n        total = combiner(term(n), total)\r\n        n -= 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=1:\r\n        total = combiner(term(n), total)\r\n        n -= 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[2,18,72,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0],[3,2,1,0,-1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1,0,-1]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1]],"print accumulate(add, 11, 3, square)":[[3,2,1,0],[3,2,1,0,-1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1,0,-1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>=0:\r\n        total = combiner(term(n), total)\r\n        n -= 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[2,18,72,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0],[3,2,1,0,-1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1,0,-1]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1]],"print accumulate(add, 11, 3, square)":[[3,2,1,0],[3,2,1,0,-1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1,0,-1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #func, first number, count from one to, term\n    total = base\n    while n >= 0:      \n        total = combiner(term(n), total)\n        n -= 1\n        if combiner == mul and n == 0:\n            return total\n            \n      #  if n == 0:\n            #total = combiner(base, total)\n    return total \n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    while n>=0:\n        total=combiner(term(n),total)\n        n-=1\n    return total\n"},{"Id":459,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":6,"tests":[{"expected":"11","output":"0","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    def helper(x,term):\n        if x==1:\n            return term(1)\n        else:\n            return combiner(term(x),helper(x-1,term))\n    return combiner(base,helper(n,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        if n == 0:         =>           \r\n            return term(0) =>           \r\n        elif x == 1:       =>           \r\n                           =>           \r\n    if n == 0:             <=           \r\n        return term(0)     <=           \r\n        if x == 1:         <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    def helper(x, term):\r\n        if x==1:\r\n            return term(1)\r\n        else:\r\n            return combiner(term(x), helper(x-1, term))\r\n    return combiner(base, helper(n, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    def helper(x, term):\r\n        if x==1:\r\n            return term(1)\r\n        else:\r\n            return combiner(term(x), helper(x-1, term))\r\n    return combiner(base, helper(n, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[11],[0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(0)\r\n    def helper(x, term):\r\n        if x==1:\r\n            return term(1)\r\n        else:\r\n            return combiner(term(x), helper(x-1, term))\r\n    return combiner(base, helper(n, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","0","","# Error: expected","#     11","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[11],[0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"0\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    def helper(x, term):\n        if n == 0:\n            return term(0)\n        elif x == 1:\n            return term(1)\n        else:\n            return combiner(term(x), helper(x-1, term))\n    return combiner(base, helper(n, term))\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(0)\n    def helper(x,term):\n        if x==1:\n            return term(1)\n        else:\n            return combiner(term(x),helper(x-1,term))\n    return combiner(base,helper(n,term))\n"},{"Id":461,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":51,"tests":[{"expected":"15","output":"Timeout","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    k=1\n    total=base\n    while k<=n:\n        total=combiner(total,term(k))\n        k+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n        k = k + 1 =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = base\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = base\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = base\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     15","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":null,"print accumulate(add, 11, 5, identity)":null,"print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":null,"print accumulate(add, 0, 5, identity)":null},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    total = base\n    while k <= n:\n        total = combiner(total, term(k))\n        k = k + 1\n    return total \n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    k=1\n    total=base\n    while k<=n:\n        total=combiner(total,term(k))\n    return total\n"},{"Id":463,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":13,"tests":[{"expected":"11","output":"12","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=1\n    if n==0:\n        return base\n    for i in range(2,n+1):\n        total=combiner(total,term(i))\n    return combiner(base,total)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n    if n == 0:                                =>           \r\n        return base                           =>           \r\n        total = 1                             =>           \r\n        for i in range(2, n+1):               =>           \r\n            total = combiner(total, term(i))  =>           \r\n        return combiner(base, total)          =>           \r\n    else:                                     =>           \r\n    total = 1                                 <=           \r\n    for i in range(2, n+1):                   <=           \r\n        total = combiner(total, term(i))      <=           \r\n    return combiner(base, total)              <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 1\r\n    if n==0:\r\n        return base\r\n    for i in range(2, n+1):\r\n        total = combiner(total, term(i))\r\n    return combiner(base, total)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 1\r\n    if n==0:\r\n        return base\r\n    for i in range(2, n+1):\r\n        total = combiner(total, term(i))\r\n    return combiner(base, total)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 1\r\n    for i in range(2, n+1):\r\n        total = combiner(total, term(i))\r\n    return combiner(base, total)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"12\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        total = 1\n        for i in range(2, n+1):\n            total = combiner(total, term(i)) \n        return combiner(base, total)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=1\n    for i in range(2,n+1):\n        total=combiner(total,term(i))\n    return combiner(base,total)\n"},{"Id":464,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":9,"tests":[{"expected":"72","output":"108","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0 or base==1:\n        return base+term(n)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(base, term(n)) =>           \r\n        return base + term(n)          <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or base==1:\r\n        return base+term(n)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or base==1:\r\n        return base+term(n)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0],[3,2,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1]],"print accumulate(add, 11, 3, square)":[[3,2,1,0],[3,2,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0 or n==1:\r\n        return base+term(n)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0],[3,2,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1]],"print accumulate(add, 11, 3, square)":[[3,2,1,0],[3,2,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"108\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0 or n==1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0 or n==1:\n        return base+term(n)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":468,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    acc=base\n    for i in range(1,n+1):\n        acc=combiner(acc,term(i))\n    return acc\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    for i in range(n):                 =>           \r\n        acc = combiner(acc, term(i+1)) =>           \r\n    for i in range(n+1):               <=           \r\n        acc = combiner(acc, term(i))   <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    acc = base\r\n    for i in range(1, n+1):\r\n        acc = combiner(acc, term(i))\r\n    return acc","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    acc = base\r\n    for i in range(1, n+1):\r\n        acc = combiner(acc, term(i))\r\n    return acc","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]},"acc":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    acc = base\r\n    for i in range(n+1):\r\n        acc = combiner(acc, term(i))\r\n    return acc","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]},"acc":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    acc = base \n    for i in range(n):\n        acc = combiner(acc, term(i+1))\n    return acc\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    acc=base\n    for i in range(n+1):\n        acc=combiner(acc,term(i))\n    return acc\n"},{"Id":469,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":5,"tests":[{"expected":"26","output":"15","input":"accumulate(add, 11, 5, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return n\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return n    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return n\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return n\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return n\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"15\n","print accumulate(add, 11, 0, identity)":"0\n","print accumulate(add, 11, 3, square)":"14\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return n\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":470,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    total, k = base, 1  =>           \r\n                        =>           \r\n    total, k = start, 1 <=           \r\n                        <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = start, 1\r\n    while k<=n:\r\n        total, k = combiner(total, term(k)), k+1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    total, k = start, 1","NameError: name 'start' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k+1\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (total,k)=(start,1)\n    while k<=n:\n        (total,k)=(combiner(total,term(k)),k+1)\n    return total\n"},{"Id":471,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n        return combine(accumulate(combiner, base, n-1, term), term(n))  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combine(accumulate(combiner, base, n-1, term), term(n))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate","    return combine(accumulate(combiner, base, n-1, term), term(n))","NameError: name 'combine' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #def producer(i):\n        #if base == n: \n            #return combiner(base, base)\n        #if i == n:\n            #return combiner(term(i), base)\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\n        #return combiner(term(i), producer(i+1))\n    #return producer(1)\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combine(accumulate(combiner,base,n-1,term),term(n))\n"},{"Id":472,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":6,"tests":[{"expected":"11","output":"0","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return n\n    ans=combiner(base,term(1))\n    for i in range(2,n+1):\n        ans=combiner(ans,term(i))\n    return ans\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return n    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return n\r\n    ans = combiner(base, term(1))\r\n    for i in range(2, n+1):\r\n        ans = combiner(ans, term(i))\r\n    return ans","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return n\r\n    ans = combiner(base, term(1))\r\n    for i in range(2, n+1):\r\n        ans = combiner(ans, term(i))\r\n    return ans","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return n\r\n    ans = combiner(base, term(1))\r\n    for i in range(2, n+1):\r\n        ans = combiner(ans, term(i))\r\n    return ans\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","0","","# Error: expected","#     11","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"0\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    ans = combiner(base, term(1))\n    for i in range(2, n+1):\n        ans = combiner(ans, term(i))\n    return ans\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return n\n    ans=combiner(base,term(1))\n    for i in range(2,n+1):\n        ans=combiner(ans,term(i))\n    return ans\nfrom operator import add,mul\n"},{"Id":473,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":13,"tests":[{"expected":"11","output":"12","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n<=1:\n        return combiner(base,term(1))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n <= 1:      <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n<=1:\r\n        return combiner(base, term(1))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n<=1:\r\n        return combiner(base, term(1))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(1))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"12\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(1))\n    return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(1))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":474,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    if n==0:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    if n==0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    if n==0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 67, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(1))\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":475,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def helper_function(combiner,n,term):\n        if n<=1:\n            return term(n)\n        else:\n            return combiner(term(n),helper_function(combiner,n-1,term))\n    return combiner(base,helper_function(combiner,n,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        if (n == 1) | (n == 0) : =>           \r\n        if n == 1:               <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper_function(combiner, n, term):\r\n        if n<=1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), helper_function(combiner, n-1, term))\r\n    return combiner(base, helper_function(combiner, n, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper_function(combiner, n, term):\r\n        if n<=1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), helper_function(combiner, n-1, term))\r\n    return combiner(base, helper_function(combiner, n, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper_function(combiner, n, term):\r\n        if n==1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), helper_function(combiner, n-1, term))\r\n    return combiner(base, helper_function(combiner, n, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function","    return combiner(term(n), helper_function(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function","    return combiner(term(n), helper_function(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function","    return combiner(term(n), helper_function(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function","    return combiner(term(n), helper_function(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function","    return combiner(term(n), helper_function(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function","    return combiner(term(n), helper_function(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in helper_function","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    #combiner(base, term(n))\n    def helper_function(combiner, n, term):\n        if (n == 1) | (n == 0) :\n            return term(n)\n        else:\n            return combiner(term(n), helper_function(combiner, n - 1, term))\n    return combiner(base, helper_function(combiner, n, term))  \n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def helper_function(combiner,n,term):\n        if n==1:\n            return term(n)\n        else:\n            return combiner(term(n),helper_function(combiner,n-1,term))\n    return combiner(base,helper_function(combiner,n,term))\n"},{"Id":477,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n2\n8\n72\n","print accumulate(add, 11, 5, identity)":"11\n12\n14\n17\n21\n26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"11\n12\n16\n25\n","print accumulate(add, 0, 5, identity)":"0\n1\n3\n6\n10\n15\n"},"group_id":3,"tests":[{"expected":"15","output":"0","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def term_output(n):\n        return term(n)\n    (total,i)=(base,1)\n    while i<=n:\n        print total\n        total=combiner(total,term_output(i))\n        i+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n                     =>           \r\n        print(total) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def term_output(n):\r\n        return term(n)\r\n    total, i = (base), 1\r\n    while i<=n:\r\n        print(total)\r\n        total = combiner(total, term_output(i))\r\n        i += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def term_output(n):\r\n        return term(n)\r\n    total, i = (base), 1\r\n    while i<=n:\r\n        print(total)\r\n        total = combiner(total, term_output(i))\r\n        i += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def term_output(n):\r\n        return term(n)\r\n    total, i = (base), 1\r\n    while i<=n:\r\n        print(total)\r\n        total = combiner(total, term_output(i))\r\n        i += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","1","3","6","10","15","","# Error: expected","#     15","# but got","#     0","#     1","#     3","#     6","#     10","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n2\n8\n72\n","print accumulate(add, 11, 5, identity)":"11\n12\n14\n17\n21\n26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"11\n12\n16\n25\n","print accumulate(add, 0, 5, identity)":"0\n1\n3\n6\n10\n15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    def term_output(n):\n        return term(n)\n\n\n    total, i = (base), 1\n\n    while i <= n:\n     \n        total = combiner(total, term_output(i))\n        i+= 1\n        \n\n    return total\n\n\n\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def term_output(n):\n        return term(n)\n    (total,i)=(base,1)\n    while i<=n:\n        print total\n        total=combiner(total,term_output(i))\n        i+=1\n    return total\n"},{"Id":479,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    list=[]\n    total=base\n    k=1\n    while k<=n:\n        total=combiner(total,term(k))\n        k\n        k+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n        list.append(k) =>           \r\n        append.list(k) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    list = []\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k\r\n        k += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    list = []\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k\r\n        k += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    list = []\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        append.list(k)\r\n        k += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    append.list(k)","NameError: name 'append' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    list = []\n    total = base\n    k = 1\n    while k <= n:\n        total = combiner(total, term(k))\n        list.append(k)\n        k += 1\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    list=[]\n    total=base\n    k=1\n    while k<=n:\n        total=combiner(total,term(k))\n        append.list(k)\n        k+=1\n    return total\n"},{"Id":480,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":3,"tests":[{"expected":"15","output":"0","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n        total=combiner(term(n),base)               =>           \r\n        return accumulate(combiner,total,n-1,term) =>           \r\n        return accumulate(combiner,base,n-1,term)  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return accumulate(combiner, base, n-1, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"11\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"11\n","print accumulate(add, 0, 5, identity)":"0\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base \n    else:\n        total=combiner(term(n),base)\n        return accumulate(combiner,total,n-1,term)\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return accumulate(combiner,base,n-1,term)\n"},{"Id":483,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n <= 1: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <= 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":485,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":3,"tests":[{"expected":"15","output":"0","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<=0:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    return base + accumulate(combiner, base, n-1, term)             <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=0:\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=0:\r\n        return base\r\n    return base+accumulate(combiner, base, n-1, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"8\n","print accumulate(add, 11, 5, identity)":"66\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"44\n","print accumulate(add, 0, 5, identity)":"0\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n<=0:\n        return base\n    return base+accumulate(combiner,base,n-1,term)\n"},{"Id":487,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    a=1\n    b=base\n    while a<=n:\n        b=combiner(b,term(a))\n        a+=1\n    return b\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    a = 1   =>           \r\n    a = 0   <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    a = 1\r\n    b = base\r\n    while a<=n:\r\n        b = combiner(b, term(a))\r\n        a += 1\r\n    return b","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    a = 1\r\n    b = base\r\n    while a<=n:\r\n        b = combiner(b, term(a))\r\n        a += 1\r\n    return b","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"a":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]],"print accumulate(add, 11, 0, identity)":[[1],[0,1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]]},"b":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    a = 0\r\n    b = base\r\n    while a<=n:\r\n        b = combiner(b, term(a))\r\n        a += 1\r\n    return b","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"a":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]],"print accumulate(add, 11, 0, identity)":[[1],[0,1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]]},"b":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    a = 1\n    b = base\n    while a <= n:\n        b = combiner(b, term(a))\n        a += 1\n    return b\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    a=0\n    b=base\n    while a<=n:\n        b=combiner(b,term(a))\n        a+=1\n    return b\n"},{"Id":489,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":17,"tests":[{"expected":"15","output":"25","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    start=base\n    k=1\n    while k<=n:\n        start=combiner(start,term(k))\n        k+=1\n    return start\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    while n > 0:      =>           \r\n        n-=1          =>           \r\n    while count <= n: <=           \r\n        count += 1    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    start = base\r\n    k = 1\r\n    while k<=n:\r\n        start = combiner(start, term(k))\r\n        k += 1\r\n    return start","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    start = base\r\n    k = 1\r\n    while k<=n:\r\n        start = combiner(start, term(k))\r\n        k += 1\r\n    return start","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"start":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,18,162,1458]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,16,21,26,31,36]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,20,29,38]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,5,10,15,20,25]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    start = base\r\n    count = 1\r\n    while count<=n:\r\n        start = combiner(start, term(n))\r\n        count += 1\r\n    return start","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast)))))))))","sequence_comparison_diff":{"start":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,18,162,1458]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,16,21,26,31,36]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,20,29,38]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,5,10,15,20,25]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"1458\n","print accumulate(add, 11, 5, identity)":"36\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"38\n","print accumulate(add, 0, 5, identity)":"25\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    start = base\n    count = 1\n    while n > 0:\n        start = combiner(start, term(n))\n        n-=1\n    return start\n\n    \"\"\"\n    if combiner == mul:\n        return (base * product(n,term))\n    else:\n        summation = base\n        while n > 0:\n            summation += term(n)\n            n -= 1\n        return summation\n    \"\"\"\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    start=base\n    count=1\n    while count<=n:\n        start=combiner(start,term(n))\n        count+=1\n    return start\n"},{"Id":491,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":12,"tests":[{"expected":"15","output":"10","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    k=1\n    while k<n+1:\n        total=combiner(total,term(k))\n        k+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    k = 1         =>           \r\n    while k <= n: =>           \r\n    k = 0         <=           \r\n    while k < n:  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<n+1:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<n+1:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[1],[0]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,17,21]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,16]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,6,10]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 0\r\n    while k<n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))))","sequence_comparison_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[1],[0]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,17,21]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,16]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,6,10]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"21\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"16\n","print accumulate(add, 0, 5, identity)":"10\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    k=0\n    while k<n:\n        total=combiner(total,term(k))\n        k+=1\n    return total\n"},{"Id":492,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    i=n\n    total=term(n)\n    while i>1:\n        i-=1\n        total=combiner(total,term(i))\n    return combiner(total,base)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    while i > 1: =>           \r\n    while i > 0: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = n\r\n    total = term(n)\r\n    while i>1:\r\n        i -= 1\r\n        total = combiner(total, term(i))\r\n    return combiner(total, base)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = n\r\n    total = term(n)\r\n    while i>1:\r\n        i -= 1\r\n        total = combiner(total, term(i))\r\n    return combiner(total, base)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]},"total":{"print accumulate(mul, 2, 3, square)":[[9,36],[9,36,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = n\r\n    total = term(n)\r\n    while i>0:\r\n        i -= 1\r\n        total = combiner(total, term(i))\r\n    return combiner(total, base)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]},"total":{"print accumulate(mul, 2, 3, square)":[[9,36],[9,36,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = n\n    total = term(n)\n    while i > 1:\n        i -= 1\n        total = combiner(total, term(i))\n    return combiner(total, base)\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    i=n\n    total=term(n)\n    while i>0:\n        i-=1\n        total=combiner(total,term(i))\n    return combiner(total,base)\n"},{"Id":494,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    while n>0:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    total=base                  =>           \r\n    return total                =>           \r\n    total=0                     <=           \r\n    return combiner(base,total) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>0:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while n>0:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26],[0,5,9,12,14,15]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,20,24,25],[0,9,13,14]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    while n>0:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return combiner(base, total)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26],[0,5,9,12,14,15]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,20,24,25],[0,9,13,14]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=base\n    while n>0:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n    \n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=0\n    while n>0:\n        total=combiner(total,term(n))\n        n-=1\n    return combiner(base,total)\n"},{"Id":495,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":52,"tests":[{"expected":"26","output":"70","input":"accumulate(add, 11, 5, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (index,total)=(1,base)\n    while index<=n:\n        total=combiner(total,term(index))\n        index+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                                     SideIndicator\r\n-----------                                                                     -------------\r\n    return accumulate(combiner, base, n, term if pred(base) else lambda x:0)    =>           \r\n        return 0                                                                <=           \r\n        return combiner(base, term (n)) + accumulate(combiner, base, n-1, term) <=           \r\n    return accumulate(combiner, base, n, term if pred(base) else lambda x :0)   <=           \r\n    if n == 0:                                                                  <=           \r\n    else:                                                                       <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    index, total = 1, base\r\n    while index<=n:\r\n        total = combiner(total, term(index))\r\n        index += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    index, total = 1, base\r\n    while index<=n:\r\n        total = combiner(total, term(index))\r\n        index += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[3,2,1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[5,4,3,2,1]],"print accumulate(add, 11, 3, square)":[[1,2,3],[3,2,1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[5,4,3,2,1]]},"n":{"print accumulate(mul, 2, 3, square)":[[3],[3,2,1,0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5],[5,4,3,2,1,0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3],[3,2,1,0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5],[5,4,3,2,1,0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return 0\r\n    else:\r\n        return combiner(base, term(n))+accumulate(combiner, base, n-1, term)\r\n    index, total = 1, base\r\n    while index<=n:\r\n        total = combiner(total, term(index))\r\n        index += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","70","","# Error: expected","#     26","# but got","#     70","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[3,2,1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[5,4,3,2,1]],"print accumulate(add, 11, 3, square)":[[1,2,3],[3,2,1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[5,4,3,2,1]]},"n":{"print accumulate(mul, 2, 3, square)":[[3],[3,2,1,0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5],[5,4,3,2,1,0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3],[3,2,1,0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5],[5,4,3,2,1,0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"28\n","print accumulate(add, 11, 5, identity)":"70\n","print accumulate(add, 11, 0, identity)":"0\n","print accumulate(add, 11, 3, square)":"47\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    index, total = 1, base\n    while index <= n:\n        total = combiner(total, term(index))\n        index += 1\n    return total\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return 0\n    else:\n        return combiner(base,term(n))+accumulate(combiner,base,n-1,term)\n    (index,total)=(1,base)\n    while index<=n:\n        total=combiner(total,term(index))\n        index+=1\n    return total\n"},{"Id":496,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    i=1\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    i = 1   =>           \r\n    i = 0   <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]],"print accumulate(add, 11, 0, identity)":[[1],[0,1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 0\r\n    while i<=n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]],"print accumulate(add, 11, 0, identity)":[[1],[0,1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    i=0\n    while i<=n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n"},{"Id":497,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":17,"tests":[{"expected":"15","output":"25","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    x=base\n    for n in range(1,n+1):\n        y=combiner\n        x=y(x,term(n))\n    return x\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        x = y(x, term(i)) =>           \r\n        x = y(x, term(n)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = base\r\n    for n in range(1, n+1):\r\n        y = combiner\r\n        x = y(x, term(n))\r\n    return x","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = base\r\n    for n in range(1, n+1):\r\n        y = combiner\r\n        x = y(x, term(n))\r\n    return x","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[2,1,2,8,3,72],[2,3,18,3,162,3,1458]],"print accumulate(add, 11, 5, identity)":[[11,1,12,2,14,3,17,4,21,5,26],[11,5,16,5,21,5,26,5,31,5,36]],"print accumulate(add, 11, 3, square)":[[11,1,12,2,16,3,25],[11,3,20,3,29,3,38]],"print accumulate(add, 0, 5, identity)":[[0,1,2,3,6,4,10,5,15],[0,5,10,5,15,5,20,5,25]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = base\r\n    for i in range(1, n+1):\r\n        y = combiner\r\n        x = y(x, term(n))\r\n    return x","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[2,1,2,8,3,72],[2,3,18,3,162,3,1458]],"print accumulate(add, 11, 5, identity)":[[11,1,12,2,14,3,17,4,21,5,26],[11,5,16,5,21,5,26,5,31,5,36]],"print accumulate(add, 11, 3, square)":[[11,1,12,2,16,3,25],[11,3,20,3,29,3,38]],"print accumulate(add, 0, 5, identity)":[[0,1,2,3,6,4,10,5,15],[0,5,10,5,15,5,20,5,25]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"1458\n","print accumulate(add, 11, 5, identity)":"36\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"38\n","print accumulate(add, 0, 5, identity)":"25\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    for i in range(1, n + 1):\n        y = combiner\n        x = y(x, term(i))\n    return x\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    x=base\n    for i in range(1,n+1):\n        y=combiner\n        x=y(x,term(n))\n    return x\n"},{"Id":498,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":14,"tests":[{"expected":"15","output":"16","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    x=1\n    y=base\n    if term==add:\n        y=0\n    while x<=n:\n        y=combiner(y,term(x))\n        x+=1\n    return y\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    if combiner == add: =>           \r\n    if term == add:     <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = 1\r\n    y = base\r\n    if term==add:\r\n        y = 0\r\n    while x<=n:\r\n        y = combiner(y, term(x))\r\n        x += 1\r\n    return y","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = 1\r\n    y = base\r\n    if term==add:\r\n        y = 0\r\n    while x<=n:\r\n        y = combiner(y, term(x))\r\n        x += 1\r\n    return y","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"y":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[1,4,36]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[1,2,4,7,11,16]],"print accumulate(add, 11, 0, identity)":[[11],[1]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[1,2,6,15]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[1,2,4,7,11,16]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = 1\r\n    y = 1\r\n    if term==add:\r\n        y = 0\r\n    while x<=n:\r\n        y = combiner(y, term(x))\r\n        x += 1\r\n    return combiner(base, y)\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))","sequence_comparison_diff":{"y":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[1,4,36]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[1,2,4,7,11,16]],"print accumulate(add, 11, 0, identity)":[[11],[1]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[1,2,6,15]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[1,2,4,7,11,16]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"27\n","print accumulate(add, 11, 0, identity)":"12\n","print accumulate(add, 11, 3, square)":"26\n","print accumulate(add, 0, 5, identity)":"16\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    x = 1\n    y = 1\n    if combiner == add:\n        y = 0\n    while x <= n:\n        y = combiner(y, term(x))\n        x += 1\n    return combiner(base, y)\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    x=1\n    y=1\n    if term==add:\n        y=0\n    while x<=n:\n        y=combiner(y,term(x))\n        x+=1\n    return combiner(base,y)\nfrom operator import add,mul\n"},{"Id":501,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":9,"tests":[{"expected":"72","output":"108","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if base==1:\n        return term(1)+base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    if n == 1:                <=           \r\n        return term(1) + base <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if base==1:\r\n        return term(1)+base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if base==1:\r\n        return term(1)+base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return term(1)+base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"108\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) \n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return term(1)+base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":503,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":3,"tests":[{"expected":"15","output":"0","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n        return combiner(accumulate(combiner, base, n-1,term), term(n)) =>           \r\n        return accumulate(combiner, base, n-1,term)                    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return accumulate(combiner, base, n-1, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"11\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"11\n","print accumulate(add, 0, 5, identity)":"0\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1,term), term(n))\n\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return accumulate(combiner,base,n-1,term)\n"},{"Id":504,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (a,b)=(base,1)\n    while b<=n:\n        a=combiner(a,term(b))\n        b=b+1\n    return a\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        a = combiner(a, term(b)) =>           \r\n        a = combiner(a, term(i)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    a, b = base, 1\r\n    while b<=n:\r\n        a = combiner(a, term(b))\r\n        b = b+1\r\n    return a","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    a, b = base, 1\r\n    while b<=n:\r\n        a = combiner(a, term(b))\r\n        b = b+1\r\n    return a","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"a":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]},"b":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    a, b = base, 1\r\n    while b<=n:\r\n        a = combiner(a, term(i))\r\n        b = b+1\r\n    return a","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    a = combiner(a, term(i))","NameError: name 'i' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-b)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast)))))","sequence_comparison_diff":{"a":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]},"b":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    a, b = base, 1\n    while b <= n:\n        a = combiner(a, term(b))\n        b = b + 1\n    return a\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (a,b)=(base,1)\n    while b<=n:\n        a=combiner(a,term(i))\n        b=b+1\n    return a\n"},{"Id":505,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":24,"tests":[{"expected":"72","output":"16","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n        return combiner(term(n),accumulate(combiner, base, n-1, term)) =>           \r\n        return term(n)+accumulate(combiner, base, n-1, term)           <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return term(n)+accumulate(combiner, base, n-1, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","16","","# Error: expected","#     72","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\"))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"16\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return term(n)+accumulate(combiner,base,n-1,term)\n"},{"Id":507,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    counter=1\n    total=base\n    while counter<=n:\n        total=combiner(total,term(counter))\n        counter+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    counter = 1 =>           \r\n    counter = 0 <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    total = base\r\n    while counter<=n:\r\n        total = combiner(total, term(counter))\r\n        counter += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    total = base\r\n    while counter<=n:\r\n        total = combiner(total, term(counter))\r\n        counter += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"counter":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]],"print accumulate(add, 11, 0, identity)":[[1],[0,1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    from operator import add, mul\r\n    counter = 0\r\n    total = base\r\n    while counter<=n:\r\n        total = combiner(total, term(counter))\r\n        counter += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"counter":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]],"print accumulate(add, 11, 0, identity)":[[1],[0,1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[0,1,2,3,4]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5,6]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    from operator import add, mul\n    counter = 1\n    total = base\n    while counter <= n:\n        total = combiner(total, term(counter))\n        counter += 1\n\n    return total \n\n \n'''    def value(i):\n        if n == 0:\n            return term(n)\n        if i == n:\n            return term(i)\n        else:\n            return combiner( term(i), value(i + 1))\n    \n    value = value(1)\n    return combiner(base, value)'''\n\n\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    from operator import add,mul\n    counter=0\n    total=base\n    while counter<=n:\n        total=combiner(total,term(counter))\n        counter+=1\n    return total\n"},{"Id":508,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":12,"tests":[{"expected":"15","output":"10","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    counter=1\n    total=base\n    while counter<n+1:\n        total=combiner(total,term(counter))\n        counter+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    while counter <= n: =>           \r\n    while counter < n:  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    total = base\r\n    while counter<n+1:\r\n        total = combiner(total, term(counter))\r\n        counter += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    total = base\r\n    while counter<n+1:\r\n        total = combiner(total, term(counter))\r\n        counter += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"counter":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,17,21]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,16]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,6,10]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,3,4]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3,4]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    counter = 1\r\n    total = base\r\n    while counter<n:\r\n        total = combiner(total, term(counter))\r\n        counter += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"counter":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,17,21]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,16]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,6,10]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,3,4]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3,4]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"8\n","print accumulate(add, 11, 5, identity)":"21\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"16\n","print accumulate(add, 0, 5, identity)":"10\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1\n    while counter <= n:\n        total = combiner(total, term(counter))\n        counter += 1\n    return total\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    counter=1\n    total=base\n    while counter<n:\n        total=combiner(total,term(counter))\n        counter+=1\n    return total\n"},{"Id":509,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":51,"tests":[{"expected":"26","output":"70","input":"accumulate(add, 11, 5, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    if n==0:\n        return term(base)\n    else:\n        return 0+combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                                    SideIndicator\r\n-----------                                                                    -------------\r\n        return combiner(base, term(1))                                         =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))        =>           \r\n        return combiner(base, term(n))                                         <=           \r\n        return base + combiner(term(n), accumulate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return 0+combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return 0+combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return base+combiner(term(n), accumulate(combiner, base, n-1, term))\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","70","","# Error: expected","#     26","# but got","#     70","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"92\n","print accumulate(add, 11, 5, identity)":"70\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"47\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==1:\n        return combiner(base, term(1))\n    if n == 0:\n        return term(base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    if n==0:\n        return term(base)\n    else:\n        return base+combiner(term(n),accumulate(combiner,base,n-1,term))\nfrom operator import add,mul\n"},{"Id":511,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    k=0\n    k=1\n    sum2=0\n    sum3=1\n    if combiner==add:\n        while k<=n:\n            sum2=sum2+term(k)\n            k+=1\n        return base+sum2\n    if combiner==mul:\n        while k<=n:\n            sum3=sum3*term(k)\n            k+=1\n        return base*sum3\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n            sum3 = sum3 * term(p) =>           \r\n            sum3 = sum3 * term(k) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 0\r\n    k = 1\r\n    sum2 = 0\r\n    sum3 = 1\r\n    if combiner==add:\r\n        while k<=n:\r\n            sum2 = sum2+term(k)\r\n            k += 1\r\n        return base+sum2\r\n    if combiner==mul:\r\n        while k<=n:\r\n            sum3 = sum3*term(k)\r\n            k += 1\r\n        return base*sum3","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 0\r\n    k = 1\r\n    sum2 = 0\r\n    sum3 = 1\r\n    if combiner==add:\r\n        while k<=n:\r\n            sum2 = sum2+term(k)\r\n            k += 1\r\n        return base+sum2\r\n    if combiner==mul:\r\n        while k<=n:\r\n            sum3 = sum3*term(k)\r\n            k += 1\r\n        return base*sum3","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[0,1,2,3,4],[0]]},"sum3":{"print accumulate(mul, 2, 3, square)":[[1,4,36],[1,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 0\r\n    p = 1\r\n    sum2 = 0\r\n    sum3 = 1\r\n    if combiner==add:\r\n        while k<=n:\r\n            sum2 = sum2+term(k)\r\n            k += 1\r\n        return base+sum2\r\n    if combiner==mul:\r\n        while p<=n:\r\n            sum3 = sum3*term(k)\r\n            p += 1\r\n        return base*sum3","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast)))))))))","sequence_comparison_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[0,1,2,3,4],[0]]},"sum3":{"print accumulate(mul, 2, 3, square)":[[1,4,36],[1,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 0\n    p = 1\n    sum2 = 0\n    sum3 = 1\n\n    if combiner == add :\n        while k <= n :\n            sum2 = sum2 + term(k)\n            k += 1\n\n        return base + sum2\n    \n    if combiner == mul :\n        while p <= n :\n            sum3 = sum3 * term(p)\n            p += 1\n\n        return base * sum3\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    k=0\n    p=1\n    sum2=0\n    sum3=1\n    if combiner==add:\n        while k<=n:\n            sum2=sum2+term(k)\n            k+=1\n        return base+sum2\n    if combiner==mul:\n        while p<=n:\n            sum3=sum3*term(k)\n            p+=1\n        return base*sum3\n"},{"Id":514,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def accumulate_helper(x,newterm,k):\n        if k==n:\n            return newterm(x)\n        return combiner(newterm(k),accumulate_helper(x,newterm,k+1))\n    if n==0:\n        return base\n    return combiner(base,accumulate_helper(n,term,1))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n==0:        =>           \r\n        return base =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulate_helper(x, newterm, k):\r\n        if k==n:\r\n            return newterm(x)\r\n        return combiner(newterm(k), accumulate_helper(x, newterm, k+1))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, accumulate_helper(n, term, 1))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulate_helper(x, newterm, k):\r\n        if k==n:\r\n            return newterm(x)\r\n        return combiner(newterm(k), accumulate_helper(x, newterm, k+1))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, accumulate_helper(n, term, 1))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"k":{},"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulate_helper(x, newterm, k):\r\n        if k==n:\r\n            return newterm(x)\r\n        return combiner(newterm(k), accumulate_helper(x, newterm, k+1))\r\n    return combiner(base, accumulate_helper(n, term, 1))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper","    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper","    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper","    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper","    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper","    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper","    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate_helper","    if k==n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"k":{},"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    def accumulate_helper(x,newterm,k):\n        if k==n:\n            return newterm(x)\n        return combiner(newterm(k),accumulate_helper(x,newterm,k+1))\n    return combiner(base,accumulate_helper(n,term,1))\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def accumulate_helper(x,newterm,k):\n        if k==n:\n            return newterm(x)\n        return combiner(newterm(k),accumulate_helper(x,newterm,k+1))\n    return combiner(base,accumulate_helper(n,term,1))\n"},{"Id":516,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n    return combiner(term(n), accumulate(combiner, base, n - 1, term))  =>           \r\n    return combiner(term(n), accumulator(combiner, base, n - 1, term)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if (n==0):\r\n        return base\r\n    return combiner(term(n), accumulator(combiner, base, n-1, term))\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulator(combiner, base, n - 1, term))","NameError: name 'accumulator' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-accumulate)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(LeafWildcard(\"ArgNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if(n == 0):\n        return base\n    return combiner(term(n), accumulate(combiner, base, n - 1, term))\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    return combiner(term(n),accumulator(combiner,base,n-1,term))\nfrom operator import add,mul\n"},{"Id":517,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    if n == 1 or n == 0: =>           \r\n    if n == 1:           <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1 or n == 0:\n        return combiner(base, term(n))\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":518,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 67, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner, base, n-1, term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":519,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":4,"tests":[{"expected":"15","output":"TypeError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                                SideIndicator\r\n-----------                                                                -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))  =>           \r\n        combiner(term(n), accumulate(combiner, base, n - 1, term))         <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    combiner(term(n), accumulate(combiner, base, n - 1, term))","TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK)))), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner,  base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) \n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":522,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":14,"tests":[{"expected":"15","output":"16","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<=0:\n        return base\n    i=1\n    final=base\n    while i<=n:\n        final=combiner(final,term(i))\n        i+=1\n    return final\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    i = 2   =>           \r\n    i = 1   <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=0:\r\n        return base\r\n    i = 1\r\n    final = base\r\n    while i<=n:\r\n        final = combiner(final, term(i))\r\n        i += 1\r\n    return final","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=0:\r\n        return base\r\n    i = 1\r\n    final = base\r\n    while i<=n:\r\n        final = combiner(final, term(i))\r\n        i += 1\r\n    return final","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"final":{"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[12,13,15,18,22,27]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[12,13,17,26]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[1,2,4,7,11,16]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=0:\r\n        return base\r\n    i = 1\r\n    final = combiner(base, term(1))\r\n    while i<=n:\r\n        final = combiner(final, term(i))\r\n        i += 1\r\n    return final","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"final":{"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[12,13,15,18,22,27]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[12,13,17,26]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[1,2,4,7,11,16]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"27\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"26\n","print accumulate(add, 0, 5, identity)":"16\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 0:\n        return base\n    final = combiner(base, term(1))\n    i = 2\n    while i <= n:\n        final = combiner(final, term(i))\n        i += 1\n    return final\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n<=0:\n        return base\n    i=1\n    final=combiner(base,term(1))\n    while i<=n:\n        final=combiner(final,term(i))\n        i+=1\n    return final\n"},{"Id":523,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":14,"tests":[{"expected":"15","output":"16","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    k=1\n    while k<=n:\n        total=combiner(term(k),total)\n        k=k+1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                               SideIndicator\r\n-----------                                               -------------\r\n    total, k = base, 1                                    =>           \r\n        total, k = combiner(term(k), total), increment(k) =>           \r\n    total = 1                                             <=           \r\n    k = 1                                                 <=           \r\n        total = combiner(term(k), total)                  <=           \r\n        k = k + 1                                         <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        total = combiner(term(k), total)\r\n        k = k+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    k = 1\r\n    while k<=n:\r\n        total = combiner(term(k), total)\r\n        k = k+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[1,4,36]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[1,2,4,7,11,16]],"print accumulate(add, 11, 0, identity)":[[11],[1]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[1,2,6,15]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[1,2,4,7,11,16]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 1\r\n    k = 1\r\n    while k<=n:\r\n        total = combiner(term(k), total)\r\n        k = k+1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[1,4,36]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[1,2,4,7,11,16]],"print accumulate(add, 11, 0, identity)":[[11],[1]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[1,2,6,15]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[1,2,4,7,11,16]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"36\n","print accumulate(add, 11, 5, identity)":"16\n","print accumulate(add, 11, 0, identity)":"1\n","print accumulate(add, 11, 3, square)":"15\n","print accumulate(add, 0, 5, identity)":"16\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(term(k), total), increment(k)\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=1\n    k=1\n    while k<=n:\n        total=combiner(term(k),total)\n        k=k+1\n    return total\n"},{"Id":524,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":11,"tests":[{"expected":"25","output":"17","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(n, accumulate(combiner, base, n-1, term))       <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(n, accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"12\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"17\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(n,accumulate(combiner,base,n-1,term))\n"},{"Id":525,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":11,"tests":[{"expected":"25","output":"17","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    lst=map(term,range(1,n+1))\n    total=base\n    k=0\n    while k<n:\n        k+=1\n        total=combiner(total,term(k))\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                                               SideIndicator\r\n-----------                                                                               -------------\r\n        total = combiner(total, term(k))                                                  =>           \r\n    def f(g, h):                                                                          =>           \r\n        return g                                                                          =>           \r\n    return accumulate(lambda y,x: combiner(y,x) if pred(x) else f(y, x), base, n, term)   =>           \r\n        total = combiner(total, k)                                                        <=           \r\n    return accumulate(combiner, base, n, term)                                            <=           \r\n                                                                                          <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    lst = map(term, range(1, n+1))\r\n    total = base\r\n    k = 0\r\n    while k<n:\r\n        k += 1\r\n        total = combiner(total, term(k))\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    lst = map(term, range(1, n+1))\r\n    total = base\r\n    k = 0\r\n    while k<n:\r\n        k += 1\r\n        total = combiner(total, term(k))\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,4,12]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,14,17]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3,1,2,3],[1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,1,2,3,4,5],[1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3,1,2,3],[1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,1,2,3,4,5],[1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    lst = map(term, range(1, n+1))\r\n    total = base\r\n    k = 0\r\n    while k<n:\r\n        k += 1\r\n        total = combiner(total, k)\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,4,12]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,14,17]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3,1,2,3],[1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,1,2,3,4,5],[1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3,1,2,3],[1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,1,2,3,4,5],[1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"12\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"17\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    lst = map(term,range(1, n+1))\n\n    total = base\n    k = 0\n    while k < n:\n        k += 1\n        total = combiner(total, term(k))\n    return total\n    \"\"\"def apply(f):\n        return map(f, lst)\n\n    def combine_option(j):\n        if combiner(1,4) == 5:\n            return base + sum(apply(term))\n        else:\n            return base * product(n, term)\n\n    return combine_option(1)\"\"\"\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    lst=map(term,range(1,n+1))\n    total=base\n    k=0\n    while k<n:\n        k+=1\n        total=combiner(total,k)\n    return total\n"},{"Id":526,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":26,"tests":[{"expected":"15","output":"5","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    result=base\n    a=1\n    while a<=n:\n        base=result=combiner(base,term(a))\n        a+=1\n    return result\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    while a <= n:                          =>           \r\n        result = combiner(term(a), result) =>           \r\n    while(a <= n):                         <=           \r\n        result = combiner(base, term(a))   <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    a = 1\r\n    while (a<=n):\r\n        base = result = combiner(base, term(a))\r\n        a += 1\r\n    return result","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    a = 1\r\n    while (a<=n):\r\n        base = result = combiner(base, term(a))\r\n        a += 1\r\n    return result","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"result":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8,18]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,13,14,15,16]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,15,20]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,2,3,4,5]]},"base":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    result = base\r\n    a = 1\r\n    while (a<=n):\r\n        result = combiner(base, term(a))\r\n        a += 1\r\n    return result","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"result":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8,18]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,13,14,15,16]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,15,20]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,2,3,4,5]]},"base":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"18\n","print accumulate(add, 11, 5, identity)":"16\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"20\n","print accumulate(add, 0, 5, identity)":"5\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = base\n    a = 1\n    while a <= n:\n        result = combiner(term(a), result)\n        a += 1\n        # result += 1\n        # a += 1\n    return result\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    result=base\n    a=1\n    while a<=n:\n        result=combiner(base,term(a))\n        a+=1\n    return result\n"},{"Id":527,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":53,"tests":[{"expected":"72","output":"72.0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    num=1\n    x=term(1)\n    while num<=n:\n        x=combiner(x,term(num+1))\n        num+=1\n    if combiner==mul:\n        return combiner(x,base)/term(n+1)\n    else:\n        return combiner(x,base)-term(n+1)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return combiner(x, base) // term(n+1) =>           \r\n        return combiner(x, base) / term(n+1)  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    num = 1\r\n    x = term(1)\r\n    while num<=n:\r\n        x = combiner(x, term(num+1))\r\n        num += 1\r\n    if combiner==mul:\r\n        return combiner(x, base)/term(n+1)\r\n    else:\r\n        return combiner(x, base)-term(n+1)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    num = 1\r\n    x = term(1)\r\n    while num<=n:\r\n        x = combiner(x, term(num+1))\r\n        num += 1\r\n    if combiner==mul:\r\n        return combiner(x, base)/term(n+1)\r\n    else:\r\n        return combiner(x, base)-term(n+1)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    num = 1\r\n    x = term(1)\r\n    while num<=n:\r\n        x = combiner(x, term(num+1))\r\n        num += 1\r\n    if combiner==mul:\r\n        return combiner(x, base)/term(n+1)\r\n    else:\r\n        return combiner(x, base)-term(n+1)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","72.0","","# Error: expected","#     72","# but got","#     72.0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    num = 1\n    x = term(1)\n    while num <= n:\n        x = combiner(x, term(num+1))\n        num += 1\n    if combiner == mul:\n        return combiner(x, base) // term(n+1)\n    else:\n        return combiner(x, base) - term(n+1)\n    \n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    num=1\n    x=term(1)\n    while num<=n:\n        x=combiner(x,term(num+1))\n        num+=1\n    if combiner==mul:\n        return combiner(x,base)/term(n+1)\n    else:\n        return combiner(x,base)-term(n+1)\n"},{"Id":528,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":24,"tests":[{"expected":"72","output":"16","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n>0:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return term(n) + accumulate(combiner, base, n-1, term)          <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n>0:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n>0:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n>0:\r\n        return term(n)+accumulate(combiner, base, n-1, term)\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","16","","# Error: expected","#     72","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\")))))), Tutor.synthesis.MagicK)))))))), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\"))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"16\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n > 0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n>0:\n        return term(n)+accumulate(combiner,base,n-1,term)\nfrom operator import add,mul\n"},{"Id":530,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":4,"tests":[{"expected":"15","output":"TypeError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumulate(base, n-1, term))           <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(base, n-1, term))","TypeError: accumulate() missing 1 required positional argument: 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n   \n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(base,n-1,term))\n"},{"Id":531,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":54,"tests":[{"expected":"15","output":"","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return\n    else:\n        new_base=combiner(base,term(n))\n        return accumulate(combiner,new_base,n-1,term)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return      <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return \r\n    else:\r\n        new_base = combiner(base, term(n))\r\n        return accumulate(combiner, new_base, (n-1), term)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return \r\n    else:\r\n        new_base = combiner(base, term(n))\r\n        return accumulate(combiner, new_base, (n-1), term)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return \r\n    else:\r\n        new_base = combiner(base, term(n))\r\n        return accumulate(combiner, new_base, (n-1), term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"None\n","print accumulate(add, 11, 5, identity)":"None\n","print accumulate(add, 11, 0, identity)":"None\n","print accumulate(add, 11, 3, square)":"None\n","print accumulate(add, 0, 5, identity)":"None\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        new_base = combiner(base,term(n))\n        return accumulate(combiner, new_base, (n-1), term)\n    \n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return\n    else:\n        new_base=combiner(base,term(n))\n        return accumulate(combiner,new_base,n-1,term)\n"},{"Id":532,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(term(1),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n <= 1:                         =>           \r\n        return term(n)                 =>           \r\n    if n <= 1:                         =>           \r\n        return combiner(term(n), base) =>           \r\n    if n == 1:                         <=           \r\n        return term(1)                 <=           \r\n    if n == 1:                         <=           \r\n        return combiner(term(1), base) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <= 1:\n        return combiner(term(n), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(term(1),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":535,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":12,"tests":[{"expected":"15","output":"10","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    counter=1\n    while counter<n+1:\n        total=combiner(total,term(counter))\n        counter+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    while counter < n + 1: =>           \r\n    while counter < n:     <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    counter = 1\r\n    while counter<n+1:\r\n        total = combiner(total, term(counter))\r\n        counter += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    counter = 1\r\n    while counter<n+1:\r\n        total = combiner(total, term(counter))\r\n        counter += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"counter":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,17,21]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,16]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,6,10]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,3,4]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3,4]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    counter = 1\r\n    while counter<n:\r\n        total = combiner(total, term(counter))\r\n        counter += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"counter":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1,2,3,4,5]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,8]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,17,21]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,16]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,6,10]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1,2,3,4]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1,2,3,4]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"8\n","print accumulate(add, 11, 5, identity)":"21\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"16\n","print accumulate(add, 0, 5, identity)":"10\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1\n\n    while counter < n + 1:\n        total = combiner(total, term(counter))\n        counter += 1\n\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    counter=1\n    while counter<n:\n        total=combiner(total,term(counter))\n        counter+=1\n    return total\n"},{"Id":536,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    if n == 1 or n == 0: =>           \r\n    if n == 1:           <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1 or n == 0:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":537,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":6,"tests":[{"expected":"11","output":"0","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return 0\n    elif n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return 0    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return 0\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return 0\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return 0\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","0","","# Error: expected","#     11","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"0\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner( base , term(n))\n    else:\n        return combiner(term(n) , accumulate(combiner, base, n-1, term))    \nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return 0\n    elif n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\nfrom operator import add,mul\n"},{"Id":539,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":3,"tests":[{"expected":"15","output":"0","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    i=1\n    def counter(i):\n        if n<i:\n            return 0\n        elif i==n:\n            return term(n)\n        else:\n            return combiner(term(i),counter(i+1))\n    return combiner(base,counter(i))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n        if i>n: =>           \r\n        if i<n: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    def counter(i):\r\n        if n<i:\r\n            return 0\r\n        elif i==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(i), counter(i+1))\r\n    return combiner(base, counter(i))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    def counter(i):\r\n        if n<i:\r\n            return 0\r\n        elif i==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(i), counter(i+1))\r\n    return combiner(base, counter(i))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3,2,1],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,4,3,2,1],[1]],"print accumulate(add, 11, 0, identity)":[[1],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70]],"print accumulate(add, 11, 3, square)":[[1,2,3,2,1],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,4,3,2,1],[1]]},"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    i = 1\r\n    def counter(i):\r\n        if i<n:\r\n            return 0\r\n        elif i==n:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(i), counter(i+1))\r\n    return combiner(base, counter(i))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3,2,1],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,4,3,2,1],[1]],"print accumulate(add, 11, 0, identity)":[[1],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70]],"print accumulate(add, 11, 3, square)":[[1,2,3,2,1],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,4,3,2,1],[1]]},"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"11\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"11\n","print accumulate(add, 0, 5, identity)":"0\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i=1\n    def counter(i):\n        if i>n:\n            return 0\n        elif i==n:\n            return term(n)\n        else:\n            return combiner(term(i),counter(i+1))\n    return combiner(base,counter(i))\n\n\n\n\n\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    i=1\n    def counter(i):\n        if i<n:\n            return 0\n        elif i==n:\n            return term(n)\n        else:\n            return combiner(term(i),counter(i+1))\n    return combiner(base,counter(i))\n"},{"Id":540,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=0\n    x=1\n    while not x>n:\n        base=combiner(base,term(x))\n        x+=1\n    final=combiner(base,total)\n    return base\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    total = base                  =>           \r\n    return total                  =>           \r\n    total = 0                     <=           \r\n    final = combiner(base, total) <=           \r\n    return final                  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    x = 1\r\n    while not x>n:\r\n        base = combiner(base, term(x))\r\n        x += 1\r\n    final = combiner(base, total)\r\n    return base","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    x = 1\r\n    while not x>n:\r\n        base = combiner(base, term(x))\r\n        x += 1\r\n    final = combiner(base, total)\r\n    return base","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]},"total":{"print accumulate(add, 11, 5, identity)":[[0],[0,1,3,6,10,15]],"print accumulate(add, 11, 3, square)":[[0],[0,1,5,14]],"print accumulate(add, 0, 5, identity)":[[0],[0,1,3,6,10,15]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    x = 1\r\n    while not x>n:\r\n        total = combiner(total, term(x))\r\n        x += 1\r\n    final = combiner(base, total)\r\n    return final","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast)))))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]},"total":{"print accumulate(add, 11, 5, identity)":[[0],[0,1,3,6,10,15]],"print accumulate(add, 11, 3, square)":[[0],[0,1,5,14]],"print accumulate(add, 0, 5, identity)":[[0],[0,1,3,6,10,15]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    x = 1\n    while not x > n:\n        total = combiner(total, term(x))\n        x += 1\n    return total\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=0\n    x=1\n    while not x>n:\n        total=combiner(total,term(x))\n        x+=1\n    final=combiner(base,total)\n    return final\n"},{"Id":541,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n2\n8\n72\n","print accumulate(add, 11, 5, identity)":"11\n12\n14\n17\n21\n26\n","print accumulate(add, 11, 0, identity)":"11\n11\n","print accumulate(add, 11, 3, square)":"11\n12\n16\n25\n","print accumulate(add, 0, 5, identity)":"0\n1\n3\n6\n10\n15\n"},"group_id":3,"tests":[{"expected":"15","output":"0","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def counter(i,total=base):\n        print total\n        if i==n:\n            return combiner(total,term(i))\n        elif n==0:\n            return total\n        else:\n            return counter(i+1,total=combiner(total,term(i)))\n    return counter(1)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n            return counter(i + 1, combiner(total, term(i)))         =>           \r\n        print(total)                                                <=           \r\n            return counter(i + 1, total + combiner(total, term(i))) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def counter(i, total = base):\r\n        print(total)\r\n        if i==n:\r\n            return combiner(total, term(i))\r\n        elif n==0:\r\n            return total\r\n        else:\r\n            return counter(i+1, \r\n            total = combiner(total, term(i)))\r\n    return counter(1)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def counter(i, total = base):\r\n        print(total)\r\n        if i==n:\r\n            return combiner(total, term(i))\r\n        elif n==0:\r\n            return total\r\n        else:\r\n            return counter(i+1, \r\n            total = combiner(total, term(i)))\r\n    return counter(1)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,2],[2,4,20,4,2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,17,14,12,11],[11,23,48,99,202,99,48,23,11]],"print accumulate(add, 11, 3, square)":[[11,12,16,12,11],[11,23,50,23,11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,6,3,1,0],[0,1,4,11,26,11,4,1,0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def counter(i, total = base):\r\n        print(total)\r\n        if i==n:\r\n            return combiner(total, term(i))\r\n        elif n==0:\r\n            return total\r\n        else:\r\n            return counter(i+1, total+combiner(total, term(i)))\r\n    return counter(1)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","1","4","11","26","31","","# Error: expected","#     15","# but got","#     0","#     1","#     4","#     11","#     26","#     31","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,2],[2,4,20,4,2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,17,14,12,11],[11,23,48,99,202,99,48,23,11]],"print accumulate(add, 11, 3, square)":[[11,12,16,12,11],[11,23,50,23,11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,6,3,1,0],[0,1,4,11,26,11,4,1,0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n4\n20\n180\n","print accumulate(add, 11, 5, identity)":"11\n23\n48\n99\n202\n207\n","print accumulate(add, 11, 0, identity)":"11\n11\n","print accumulate(add, 11, 3, square)":"11\n23\n50\n59\n","print accumulate(add, 0, 5, identity)":"0\n1\n4\n11\n26\n31\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def counter(i, total = base):\n        if i == n:\n            return combiner(total, term(i))\n        elif n == 0:\n            return total\n        else:\n            return counter(i + 1, combiner(total, term(i)))\n    return counter(1)\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def counter(i,total=base):\n        print total\n        if i==n:\n            return combiner(total,term(i))\n        elif n==0:\n            return total\n        else:\n            return counter(i+1,total+combiner(total,term(i)))\n    return counter(1)\n"},{"Id":542,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":5,"tests":[{"expected":"26","output":"15","input":"accumulate(add, 11, 5, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return n\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return n    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return n\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return n\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return n\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"15\n","print accumulate(add, 11, 0, identity)":"0\n","print accumulate(add, 11, 3, square)":"14\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner( term(n), accumulate(combiner, base, n-1, term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return n\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":544,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":4,"tests":[{"expected":"15","output":"TypeError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return combiner(term(n), accumulate(n - 1))                       <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(n-1))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(n - 1))","TypeError: accumulate() missing 3 required positional arguments: 'base', 'n', and 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(n-1))\n"},{"Id":545,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return base                    =>           \r\n        return combiner(base, term(n)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":546,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":12,"tests":[{"expected":"15","output":"10","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    i=1\n    while i<n+1:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    i = 1         =>           \r\n    while i <= n: =>           \r\n    i = 0         <=           \r\n    while i < n:  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<n+1:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 1\r\n    while i<n+1:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[1],[0]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,17,21]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,16]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,6,10]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    i = 0\r\n    while i<n:\r\n        total = combiner(total, term(i))\r\n        i += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))))","sequence_comparison_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[1],[0]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[0,1,2,3,4,5]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,14,17,21]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,16]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,3,6,10]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[0,1,2]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4]],"print accumulate(add, 11, 3, square)":[[1,2,3],[0,1,2]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"21\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"16\n","print accumulate(add, 0, 5, identity)":"10\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    i=0\n    while i<n:\n        total=combiner(total,term(i))\n        i+=1\n    return total\n"},{"Id":549,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":7,"tests":[{"expected":"25","output":"135","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,11]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,11]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,11]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,11]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"144\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"135\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":550,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":21,"tests":[{"expected":"15","output":"9","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return combiner(term(n), term(n - 1))                             <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), term(n-1))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","9","","# Error: expected","#     15","# but got","#     9","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"36\n","print accumulate(add, 11, 5, identity)":"9\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"13\n","print accumulate(add, 0, 5, identity)":"9\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),term(n-1))\n"},{"Id":551,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":50,"tests":[{"expected":"15","output":"Timeout","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        total=combiner(total,term(k))\n        k+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n        k = increment(k) =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n        k += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total = combiner(total, term(k))\r\n    return total\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     15","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, StartsWithParent(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":null,"print accumulate(add, 11, 5, identity)":null,"print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":null,"print accumulate(add, 0, 5, identity)":null},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total = combiner(total, term(k))\n        k = increment(k)\n    return total\n\n\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        total=combiner(total,term(k))\n    return total\nfrom operator import add,mul\n"},{"Id":552,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    b=base\n    c=combiner\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(c(total,term(k)),k+1)\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, k = base, 1 =>           \r\n    return total       =>           \r\n    total, k = 0, 1    <=           \r\n    return c(b, total) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    b = base\r\n    c = combiner\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = c(total, term(k)), k+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    b = base\r\n    c = combiner\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = c(total, term(k)), k+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[0,1,3,6,10,15]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[0,1,5,14]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    b = base\r\n    c = combiner\r\n    total, k = 0, 1\r\n    while k<=n:\r\n        total, k = c(total, term(k)), k+1\r\n    return c(b, total)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[0,1,3,6,10,15]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[0,1,5,14]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    b = base\n    c = combiner\n    total, k = base, 1\n    while k <= n:\n        total, k = c(total, term(k)), k + 1\n    return total\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    b=base\n    c=combiner\n    (total,k)=(0,1)\n    while k<=n:\n        (total,k)=(c(total,term(k)),k+1)\n    return c(b,total)\n"},{"Id":554,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":55,"tests":[{"expected":"26","output":"0","input":"accumulate(add, 11, 5, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    while 1<=n:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    while n >= 1:                        =>           \r\n        base = combiner(base, term(n))   =>           \r\n                                         =>           \r\n    total = 0                            <=           \r\n        total = combiner(total, term(n)) <=           \r\n    return total                         <=           \r\n        base = combiner(base, term(i))   <=           \r\n        i += 1                           <=           \r\n    while base <= n:                     <=           \r\n    i = 1                                <=           \r\n    while i <= n:                        <=           \r\n    \"\"\"                                  <=           \r\n    \"\"\"                                  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while 1<=n:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    while 1<=n:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26],[0]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,20,24,25],[0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0],[3,2,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1,0,-1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = 0\r\n    while base<=n:\r\n        total = combiner(total, term(n))\r\n        n -= 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     26","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,18,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26],[0]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,20,24,25],[0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0],[3,2,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0],[5,4,3,2,1,0,-1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"0\n","print accumulate(add, 11, 0, identity)":"0\n","print accumulate(add, 11, 3, square)":"0\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while n >= 1:\n        base = combiner(base, term(n))\n        n -= 1\n    return base\n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=0\n    while base<=n:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n"},{"Id":557,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":45,"tests":[{"expected":"26","output":"RecursionError","input":"accumulate(add, 11, 5, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    if n==0: return base    =>           \r\n    if n==base: return base <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==base:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    else: return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    else: return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    else: return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    else: return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    else: return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    else: return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 67, in accumulate","    if n==base: return base","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     26","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast)))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"18\n","print accumulate(add, 11, 5, identity)":null,"print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":null,"print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0: return base\n    else: return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==base:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":558,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":7,"tests":[{"expected":"25","output":"135","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return term(base)\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[11,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[11,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[11,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[11,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"144\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"135\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n"},{"Id":559,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":3,"tests":[{"expected":"15","output":"0","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n        # (base, term(n))                                               =>           \r\n        return accumulate(combiner, base, n-1, term)                    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return accumulate(combiner, base, n-1, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"11\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"11\n","print accumulate(add, 0, 5, identity)":"0\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n        # (base, term(n))\n    # def base_sequence(combiner, n, term):\n    #     if n < 2:\n    #         return term (n)\n    #     else:\n    #         return combiner(term(n), base_sequence(combiner, n-1, term))\n    # return combiner(base, base_sequence(combiner, n, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return accumulate(combiner,base,n-1,term)\n"},{"Id":560,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":8,"tests":[{"expected":"15","output":"UnboundLocalError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        start=combiner(term(n),base)\n        return accumulate(combiner,start,n-1,term)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                           SideIndicator\r\n-----------                                           -------------\r\n        return base                                   =>           \r\n        base = combiner(term(n), base)                =>           \r\n        return accumulate(combiner, base, n-1, term)  =>           \r\n        return start                                  <=           \r\n        start = combiner(term(n), start)              <=           \r\n        return accumulate(combiner, start, n-1, term) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        start = combiner(term(n), base)\r\n        return accumulate(combiner, start, n-1, term)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        start = combiner(term(n), base)\r\n        return accumulate(combiner, start, n-1, term)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18,2],[2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26,25,23,20,16,11],[11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25,24,20,11],[11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15,14,12,9,5,0],[0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return start\r\n    else:\r\n        start = combiner(term(n), start)\r\n        return accumulate(combiner, start, n-1, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    start = combiner(term(n), start)","UnboundLocalError: local variable 'start' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18,2],[2]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26,25,23,20,16,11],[11]],"print accumulate(add, 11, 3, square)":[[11,20,24,25,24,20,11],[11]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15,14,12,9,5,0],[0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        base = combiner(term(n), base)\n        return accumulate(combiner, base, n-1, term)\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return start\n    else:\n        start=combiner(term(n),start)\n        return accumulate(combiner,start,n-1,term)\n"},{"Id":561,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def whatever(n):\n        if n<=1:\n            return term(n)\n        else:\n            return combiner(term(n),whatever(n-1))\n    return combiner(base,whatever(n))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n        if n <= 1: =>           \r\n        if n == 1: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def whatever(n):\r\n        if n<=1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), whatever(n-1))\r\n    return combiner(base, whatever(n))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def whatever(n):\r\n        if n<=1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), whatever(n-1))\r\n    return combiner(base, whatever(n))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def whatever(n):\r\n        if n==1:\r\n            return term(n)\r\n        else:\r\n            return combiner(term(n), whatever(n-1))\r\n    return combiner(base, whatever(n))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever","    return combiner(term(n), whatever(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever","    return combiner(term(n), whatever(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever","    return combiner(term(n), whatever(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever","    return combiner(term(n), whatever(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever","    return combiner(term(n), whatever(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever","    return combiner(term(n), whatever(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in whatever","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def whatever(n):\n        if n <= 1:\n            return term(n) \n        else:\n            return combiner(term(n), whatever(n-1))\n   \n    return combiner(base, whatever(n))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def whatever(n):\n        if n==1:\n            return term(n)\n        else:\n            return combiner(term(n),whatever(n-1))\n    return combiner(base,whatever(n))\n"},{"Id":564,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":56,"tests":[{"expected":"25","output":"SyntaxError","input":"accumulate(add, 11, 3, square)   t"}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    k=1\n    total=term(k)\n    if n==0:\n        return base\n    while k<n:\n        (k,total)=(k+1,combiner(total,term(k+1)))\n    return combiner(base,total)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                      SideIndicator\r\n-----------                                                      -------------\r\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2  =>           \r\n    >>> accumulate(add, 11, 3, square)   t# 11 + 1^2 + 2^2 + 3^2 <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = term(k)\r\n    if n==0:\r\n        return base\r\n    while k<n:\r\n        k, total = k+1, combiner(total, term(k+1))\r\n    return combiner(base, total)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = term(k)\r\n    if n==0:\r\n        return base\r\n    while k<n:\r\n        k, total = k+1, combiner(total, term(k+1))\r\n    return combiner(base, total)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = 1\r\n    total = term(k)\r\n    if n==0:\r\n        return base\r\n    while k<n:\r\n        k, total = k+1, combiner(total, term(k+1))\r\n    return combiner(base, total)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   t# 11 + 1^2 + 2^2 + 3^2","Traceback (most recent call last):","    accumulate(add, 11, 3, square)   t# 11 + 1^2 + 2^2 + 3^2","                                     ^","SyntaxError: invalid syntax","","# Error: expected","#     25","# but got","#     SyntaxError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    total = term(k)\n    if n == 0:\n        return base\n    while k < n:\n        k, total = k + 1, combiner(total,term(k+1))\n    return combiner(base, total)\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    k=1\n    total=term(k)\n    if n==0:\n        return base\n    while k<n:\n        (k,total)=(k+1,combiner(total,term(k+1)))\n    return combiner(base,total)\n"},{"Id":565,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base,term(n))\n    else:\n        base=combiner(base,term(n))\n        return accumulate(combiner,base,n-1,term)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                             SideIndicator\r\n-----------                                             -------------\r\n        return accumulate(combiner, base, n - 1, term)  =>           \r\n        return accumulator(combiner, base, n - 1, term) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        base = combiner(base, term(n))\r\n        return accumulate(combiner, base, n-1, term)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        base = combiner(base, term(n))\r\n        return accumulate(combiner, base, n-1, term)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18],[2,18]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,23,20,16],[11,16]],"print accumulate(add, 11, 3, square)":[[11,20,24,20],[11,20]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,12,9,5],[0,5]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    elif n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        base = combiner(base, term(n))\r\n        return accumulator(combiner, base, n-1, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return accumulator(combiner, base, n - 1, term)","NameError: name 'accumulator' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-accumulate)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(LeafWildcard(\"ArgNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18],[2,18]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,23,20,16],[11,16]],"print accumulate(add, 11, 3, square)":[[11,20,24,20],[11,20]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,12,9,5],[0,5]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n#def accumulator(combiner, base, n, term):\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        base = combiner(base, term(n))\n        return accumulate(combiner, base, n - 1, term)\n\n#    return accumulator(combiner, base, n, term)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base,term(n))\n    else:\n        base=combiner(base,term(n))\n        return accumulator(combiner,base,n-1,term)\n"},{"Id":568,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":57,"tests":[{"expected":"11","output":"UnboundLocalError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        accumulutation=combiner(base,term(0))\n    else:\n        accumulation=combiner(base,term(1))\n    for i in range(2,n+1):\n        accumulation=combiner(accumulation,term(i))\n    return accumulation\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        accumulation=combiner(base,term(0))   =>           \r\n        accumulutation=combiner(base,term(0)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        accumulutation = combiner(base, term(0))\r\n    else:\r\n        accumulation = combiner(base, term(1))\r\n    for i in range(2, n+1):\r\n        accumulation = combiner(accumulation, term(i))\r\n    return accumulation","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        accumulutation = combiner(base, term(0))\r\n    else:\r\n        accumulation = combiner(base, term(1))\r\n    for i in range(2, n+1):\r\n        accumulation = combiner(accumulation, term(i))\r\n    return accumulation","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        accumulutation = combiner(base, term(0))\r\n    else:\r\n        accumulation = combiner(base, term(1))\r\n    for i in range(2, n+1):\r\n        accumulation = combiner(accumulation, term(i))\r\n    return accumulation","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    return accumulation","UnboundLocalError: local variable 'accumulation' referenced before assignment","","# Error: expected","#     11","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        accumulation=combiner(base,term(0))\n    else:\n        accumulation=combiner(base,term(1))\n    for i in range(2,n+1):\n        accumulation=combiner(accumulation, term(i))\n    return accumulation\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        accumulutation=combiner(base,term(0))\n    else:\n        accumulation=combiner(base,term(1))\n    for i in range(2,n+1):\n        accumulation=combiner(accumulation,term(i))\n    return accumulation\n"},{"Id":569,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":13,"tests":[{"expected":"11","output":"12","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def helper(i,total,combiner,base,n,term):\n        if n<=1:\n            return combiner(total,term(i))\n        elif n==0:\n            return total\n        else:\n            total=combiner(total,term(i))\n            return helper(i+1,total,combiner,base,n-1,term)\n    if n==0:\n        return base\n    return helper(1,base,combiner,base,n,term)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        if n == 0:   =>           \r\n        elif n <= 1: =>           \r\n        if n <= 1:   <=           \r\n        elif n == 0: <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i, total, combiner, base, n, term):\r\n        if n<=1:\r\n            return combiner(total, term(i))\r\n        elif n==0:\r\n            return total\r\n        else:\r\n            total = combiner(total, term(i))\r\n            return helper(i+1, total, combiner, base, n-1, term)\r\n    if n==0:\r\n        return base\r\n    return helper(1, base, combiner, base, n, term)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i, total, combiner, base, n, term):\r\n        if n<=1:\r\n            return combiner(total, term(i))\r\n        elif n==0:\r\n            return total\r\n        else:\r\n            total = combiner(total, term(i))\r\n            return helper(i+1, total, combiner, base, n-1, term)\r\n    if n==0:\r\n        return base\r\n    return helper(1, base, combiner, base, n, term)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{},"total":{},"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def helper(i, total, combiner, base, n, term):\r\n        if n<=1:\r\n            return combiner(total, term(i))\r\n        elif n==0:\r\n            return total\r\n        else:\r\n            total = combiner(total, term(i))\r\n            return helper(i+1, total, combiner, base, n-1, term)\r\n    return helper(1, base, combiner, base, n, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"i":{},"total":{},"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"12\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i, total, combiner, base, n, term): \n        if n == 0:\n            return total \n        elif n <= 1:\n            return combiner(total, term(i))\n        else:\n            total = combiner(total, term(i)) \n            return helper(i+1, total, combiner, base, n-1, term)\n\n    return helper(1, base, combiner, base, n, term)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def helper(i,total,combiner,base,n,term):\n        if n<=1:\n            return combiner(total,term(i))\n        elif n==0:\n            return total\n        else:\n            total=combiner(total,term(i))\n            return helper(i+1,total,combiner,base,n-1,term)\n    return helper(1,base,combiner,base,n,term)\n"},{"Id":571,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":11,"tests":[{"expected":"25","output":"17","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return accumulate(combiner,combiner(base,term(n)),n-1,term)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return accumulate(combiner, combiner(base, term(n)), n-1, term) =>           \r\n        return accumulate(combiner, combiner(base, n), n-1, term)       <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18,2],[2,6,12,6,2]],"print accumulate(add, 11, 3, square)":[[11,20,24,25,24,20,11],[11,14,16,17,16,14,11]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return accumulate(combiner, combiner(base, n), n-1, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)))))), 2), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18,2],[2,6,12,6,2]],"print accumulate(add, 11, 3, square)":[[11,20,24,25,24,20,11],[11,14,16,17,16,14,11]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"12\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"17\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return accumulate(combiner,combiner(base,n),n-1,term)\n"},{"Id":572,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":21,"tests":[{"expected":"15","output":"9","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=combiner(base,term(n))\n    n=n-1\n    if n<1:\n        return total\n    else:\n        return combiner(term(n),accumulate(combiner,total,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                 SideIndicator\r\n-----------                                                 -------------\r\n        return accumulate(combiner, total, n, term)         =>           \r\n        return accumulate(combiner, total, n-1, term)       <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = combiner(base, term(n))\r\n    n = n-1\r\n    if n<1:\r\n        return total\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, total, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = combiner(base, term(n))\r\n    n = n-1\r\n    if n<1:\r\n        return total\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, total, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,3,1]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,3,1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = combiner(base, term(n))\r\n    n = n-1\r\n    if n<1:\r\n        return total\r\n    else:\r\n        return accumulate(combiner, total, n-1, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","9","","# Error: expected","#     15","# but got","#     9","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,1]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,3,1]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,1]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,3,1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"18\n","print accumulate(add, 11, 5, identity)":"20\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"21\n","print accumulate(add, 0, 5, identity)":"9\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"    \n    total = combiner(base, term(n))\n    n = n - 1\n    if n < 1:\n        return total\n    else: \n        return accumulate(combiner, total, n, term)      \n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=combiner(base,term(n))\n    n=n-1\n    if n<1:\n        return total\n    else:\n        return accumulate(combiner,total,n-1,term)\n"},{"Id":576,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":17,"tests":[{"expected":"15","output":"25","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    acc_sum=base\n    k=1\n    while k<=n:\n        acc_sum=combiner(acc_sum,term(k))\n        k+=1\n    return acc_sum\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                      SideIndicator\r\n-----------                                      -------------\r\n        acc_sum = combiner(acc_sum, term(index)) =>           \r\n        acc_sum = combiner(acc_sum, term(n))     <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    acc_sum = base\r\n    k = 1\r\n    while k<=n:\r\n        acc_sum = combiner(acc_sum, term(k))\r\n        k += 1\r\n    return acc_sum","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    acc_sum = base\r\n    k = 1\r\n    while k<=n:\r\n        acc_sum = combiner(acc_sum, term(k))\r\n        k += 1\r\n    return acc_sum","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"acc_sum":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,18,162,1458]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,16,21,26,31,36]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,20,29,38]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,5,10,15,20,25]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    acc_sum = base\r\n    index = 1\r\n    while index<=n:\r\n        acc_sum = combiner(acc_sum, term(n))\r\n        index += 1\r\n    return acc_sum","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, StartsWithParent(Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast)))))))))","sequence_comparison_diff":{"acc_sum":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,18,162,1458]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,16,21,26,31,36]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,20,29,38]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,5,10,15,20,25]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"1458\n","print accumulate(add, 11, 5, identity)":"36\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"38\n","print accumulate(add, 0, 5, identity)":"25\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #if n == 0:\n    #    return base\n    #return combiner(term(n), accumulate(combiner,base,n-1, term))\n\n    acc_sum = base \n    index = 1 \n    while index <= n:\n        acc_sum = combiner(acc_sum, term(index))\n        index += 1 \n    return acc_sum \n\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    acc_sum=base\n    index=1\n    while index<=n:\n        acc_sum=combiner(acc_sum,term(n))\n        index+=1\n    return acc_sum\n"},{"Id":577,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":5,"tests":[{"expected":"26","output":"15","input":"accumulate(add, 11, 5, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    (total,k)=(base,1)\n    while k<=n:\n        (total,k)=(combiner(term(k),total),k+1)\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                       SideIndicator\r\n-----------                                       -------------\r\n    total, k = base, 1                            =>           \r\n        total, k = combiner(total, term (k)), k+1 =>           \r\n    total, k = 0, 1                               <=           \r\n        total, k = combiner(term(k), total), k+1  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(term(k), total), k+1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = base, 1\r\n    while k<=n:\r\n        total, k = combiner(term(k), total), k+1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[0,1,3,6,10,15]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[0,1,5,14]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total, k = 0, 1\r\n    while k<=n:\r\n        total, k = combiner(term(k), total), k+1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[0,1,3,6,10,15]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[0,1,5,14]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"15\n","print accumulate(add, 11, 0, identity)":"0\n","print accumulate(add, 11, 3, square)":"14\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k<= n:\n        total, k = combiner(total, term (k)), k+1\n    return total\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    (total,k)=(0,1)\n    while k<=n:\n        (total,k)=(combiner(term(k),total),k+1)\n    return total\n"},{"Id":578,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":7,"tests":[{"expected":"25","output":"135","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    k=base\n    for i in range(1,n+1):\n        k=combiner(k,term(i))\n    return k\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    k=base       =>           \r\n    k=term(base) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = base\r\n    for i in range(1, n+1):\r\n        k = combiner(k, term(i))\r\n    return k","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = base\r\n    for i in range(1, n+1):\r\n        k = combiner(k, term(i))\r\n    return k","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[4,16,144]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[121,122,126,135]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[11,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[11,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    k = term(base)\r\n    for i in range(1, n+1):\r\n        k = combiner(k, term(i))\r\n    return k","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{"k":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[4,16,144]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[121,122,126,135]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[11,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[11,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"144\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"135\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k=base\n    for i in range(1,n+1):\n        k=combiner(k,term(i))\n    return k\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    k=term(base)\n    for i in range(1,n+1):\n        k=combiner(k,term(i))\n    return k\n"},{"Id":579,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def sequence(combiner,n,term):\n        if n==0:\n            return base\n        return combiner(term(n),sequence(combiner,n-1,term))\n    return sequence(combiner,n,term)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    if n == 1:             =>           \r\n        return term(1)     =>           \r\n        if n == 1:         =>           \r\n            return term(1) =>           \r\n    if n == 0:             <=           \r\n        return 1           <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def sequence(combiner, n, term):\r\n        if n==0:\r\n            return base\r\n        return combiner(term(n), sequence(combiner, n-1, term))\r\n    return sequence(combiner, n, term)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def sequence(combiner, n, term):\r\n        if n==0:\r\n            return base\r\n        return combiner(term(n), sequence(combiner, n-1, term))\r\n    return sequence(combiner, n, term)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def sequence(combiner, n, term):\r\n        if n==0:\r\n            return 0\r\n        return combiner(term(n), sequence(combiner, n-1, term))\r\n    return combiner(base, sequence(combiner, n, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\"))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))), InOrderSort(ast)))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def sequence(combiner, n, term):\n        if n == 0:\n            return 0\n        if n == 1:\n            return term(1)\n        return combiner(term(n), sequence(combiner, n - 1, term))\n    return combiner(base, sequence(combiner, n, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def sequence(combiner,n,term):\n        if n==0:\n            return 0\n        return combiner(term(n),sequence(combiner,n-1,term))\n    return combiner(base,sequence(combiner,n,term))\n"},{"Id":580,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n<=1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n<=1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\r\nfrom operator import add, mul","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), Tutor.synthesis.MagicK))))), Selected(\\x => Match(x, StartsWithParent(Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    if n == 1:\n    \treturn combiner(base, term(n))\n    else:\n    \treturn combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n\n\n\n\nfrom operator import add, mul\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\nfrom operator import add,mul\n"},{"Id":582,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":42,"tests":[{"expected":"15","output":"RecursionError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        base=combiner(term(n),base)\n        return accumulate(combiner,base,n-1,term)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        return accumulate(combiner, base, n-1, term) =>           \r\n        return accumulate(combiner, base, n, term)   <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        base = combiner(term(n), base)\r\n        return accumulate(combiner, base, n-1, term)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        base = combiner(term(n), base)\r\n        return accumulate(combiner, base, n-1, term)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18],[2,18,162,1458,13122,118098,1062882,9565938,86093442,774840978,6973568802,62762119218,564859072962,5083731656658,45753584909922,411782264189298,3706040377703682,33354363399333138,300189270593998242,2701703435345984178,5868586844404305986,218837978263024718418,1969541804367222465762,17725876239305002191858,159532886153745019726722,1435795975383705177540498,12922163778453346597864482,116299474006080119380780338,1046695266054721074427023042,9420257394492489669843207378,84782316550432407028588866402,763040848953891663257299797618,6867367640585024969315698178562,61806308765265224723841283607058,556256778887387022514571552463522,5006311009986483202631143972171698,45056799089878348823680295749545282,405511191808905139413122661745907538,3649600726280146254718103955713167842,32846406536521316292462935601418510578,295617658828691846632166420412766595202,2660558929458226619689497783714899356818,23945030365124039577205480053434094211362,215505273286116356194849320480906847902258,1939547459575047205753643884328161631120322,17455927136175424851782794958953454680082898,157103344225578823666045154630581092120746082,1413930098030209412994406391675229829086714738,12725370882271884716949657525077068461780432642,114528337940446962452546917725693616156023893778,1030755041464022662072922259531242545404215044002,9276795373176203958656300335781182908637935396018,83491158358585835627906703022030646177741418564162,751420425227272520651160327198275815599672767077458,6762783827045452685860442944784482340397054903697122,60865054443409074172743986503060341063573494133274098,547785489990681667554695878527543069572161447199466882,4930069409916135007992262906747887626149453024795201938,44370624689245215071930366160730988635345077223156817442,399335622203206935647373295446578897718105695008411356978,3594020599828862420826359659019210079462951255075702212802,32346185398459761787437236931172890715166561295681319915218,291115668586137856086935132380556016436499051661131879236962,2620041017275240704782416191425004147928491464950186913132658,23580369155477166343041745722825037331356423184551682218193922,212223322399294497087375711505425335982207808660965139963745298,1910009901593650473786381403548828023839870277948686259673707682,17190089114342854264077432631939452214558832501538176337063369138,154710802029085688376696893687455069931029492513843587033570322242,1392397218261771195390272043187095629379265432624592283302132900178]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26,25,23,20,16],[11,16,21,26,31,36,41,46,51,56,61,66,71,76,81,86,91,96,101,106,111,116,121,126,131,136,141,146,151,156,161,166,171,176,181,186,191,196,201,206,211,216,221,226,231,236,241,246,251,256,261,266,271,276,281,286,291,296,301,306,311,316,321,326,331,336,341,346,351,356]],"print accumulate(add, 11, 3, square)":[[11,20,24,25,24,20],[11,20,29,38,47,56,65,74,83,92,101,110,119,128,137,146,155,164,173,182,191,200,209,218,227,236,245,254,263,272,281,290,299,308,317,326,335,344,353,362,371,380,389,398,407,416,425,434,443,452,461,470,479,488,497,506,515,524,533,542,551,560,569,578,587,596,605,614,623,632]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15,14,12,9,5],[0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,120,125,130,135,140,145,150,155,160,165,170,175,180,185,190,195,200,205,210,215,220,225,230,235,240,245,250,255,260,265,270,275,280,285,290,295,300,305,310,315,320,325,330,335,340,345]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        base = combiner(term(n), base)\r\n        return accumulate(combiner, base, n, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return accumulate(combiner, base, n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return accumulate(combiner, base, n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return accumulate(combiner, base, n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return accumulate(combiner, base, n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return accumulate(combiner, base, n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return accumulate(combiner, base, n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    if n == 0:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,18,72,18],[2,18,162,1458,13122,118098,1062882,9565938,86093442,774840978,6973568802,62762119218,564859072962,5083731656658,45753584909922,411782264189298,3706040377703682,33354363399333138,300189270593998242,2701703435345984178,5868586844404305986,218837978263024718418,1969541804367222465762,17725876239305002191858,159532886153745019726722,1435795975383705177540498,12922163778453346597864482,116299474006080119380780338,1046695266054721074427023042,9420257394492489669843207378,84782316550432407028588866402,763040848953891663257299797618,6867367640585024969315698178562,61806308765265224723841283607058,556256778887387022514571552463522,5006311009986483202631143972171698,45056799089878348823680295749545282,405511191808905139413122661745907538,3649600726280146254718103955713167842,32846406536521316292462935601418510578,295617658828691846632166420412766595202,2660558929458226619689497783714899356818,23945030365124039577205480053434094211362,215505273286116356194849320480906847902258,1939547459575047205753643884328161631120322,17455927136175424851782794958953454680082898,157103344225578823666045154630581092120746082,1413930098030209412994406391675229829086714738,12725370882271884716949657525077068461780432642,114528337940446962452546917725693616156023893778,1030755041464022662072922259531242545404215044002,9276795373176203958656300335781182908637935396018,83491158358585835627906703022030646177741418564162,751420425227272520651160327198275815599672767077458,6762783827045452685860442944784482340397054903697122,60865054443409074172743986503060341063573494133274098,547785489990681667554695878527543069572161447199466882,4930069409916135007992262906747887626149453024795201938,44370624689245215071930366160730988635345077223156817442,399335622203206935647373295446578897718105695008411356978,3594020599828862420826359659019210079462951255075702212802,32346185398459761787437236931172890715166561295681319915218,291115668586137856086935132380556016436499051661131879236962,2620041017275240704782416191425004147928491464950186913132658,23580369155477166343041745722825037331356423184551682218193922,212223322399294497087375711505425335982207808660965139963745298,1910009901593650473786381403548828023839870277948686259673707682,17190089114342854264077432631939452214558832501538176337063369138,154710802029085688376696893687455069931029492513843587033570322242,1392397218261771195390272043187095629379265432624592283302132900178]],"print accumulate(add, 11, 5, identity)":[[11,16,20,23,25,26,25,23,20,16],[11,16,21,26,31,36,41,46,51,56,61,66,71,76,81,86,91,96,101,106,111,116,121,126,131,136,141,146,151,156,161,166,171,176,181,186,191,196,201,206,211,216,221,226,231,236,241,246,251,256,261,266,271,276,281,286,291,296,301,306,311,316,321,326,331,336,341,346,351,356]],"print accumulate(add, 11, 3, square)":[[11,20,24,25,24,20],[11,20,29,38,47,56,65,74,83,92,101,110,119,128,137,146,155,164,173,182,191,200,209,218,227,236,245,254,263,272,281,290,299,308,317,326,335,344,353,362,371,380,389,398,407,416,425,434,443,452,461,470,479,488,497,506,515,524,533,542,551,560,569,578,587,596,605,614,623,632]],"print accumulate(add, 0, 5, identity)":[[0,5,9,12,14,15,14,12,9,5],[0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,120,125,130,135,140,145,150,155,160,165,170,175,180,185,190,195,200,205,210,215,220,225,230,235,240,245,250,255,260,265,270,275,280,285,290,295,300,305,310,315,320,325,330,335,340,345]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":null,"print accumulate(add, 11, 5, identity)":null,"print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":null,"print accumulate(add, 0, 5, identity)":null},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else: \n        base = combiner(term(n),base)\n        return accumulate(combiner, base, n-1, term)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        base=combiner(term(n),base)\n        return accumulate(combiner,base,n,term)\n"},{"Id":584,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"(3, 9, 27)\n(2, 4, 8)\n(1, 1, 1)\n2\n72\n","print accumulate(add, 11, 5, identity)":"(5, 5, 10)\n(4, 4, 8)\n(3, 3, 6)\n(2, 2, 4)\n(1, 1, 2)\n11\n26\n","print accumulate(add, 11, 0, identity)":"11\n11\n","print accumulate(add, 11, 3, square)":"(3, 9, 12)\n(2, 4, 6)\n(1, 1, 2)\n11\n25\n","print accumulate(add, 0, 5, identity)":"(5, 5, 10)\n(4, 4, 8)\n(3, 3, 6)\n(2, 2, 4)\n(1, 1, 2)\n0\n15\n"},"group_id":4,"tests":[{"expected":"15","output":"TypeError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        print base\n        return base\n    else:\n        print(n,term(n),combiner(n,term(n)))\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n        print(base)                                                 <=           \r\n        print(n,term(n),combiner(n,term(n)))                        <=           \r\n        combiner(term(n),accumulate(combiner,base,n-1,term))        <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        print(base)\r\n        return base\r\n    else:\r\n        print(n, term(n), combiner(n, term(n)))\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        print(base)\r\n        return base\r\n    else:\r\n        print(n, term(n), combiner(n, term(n)))\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        print(base)\r\n        return base\r\n    else:\r\n        print(n, term(n), combiner(n, term(n)))\r\n        combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5 5 10","4 4 8","3 3 6","2 2 4","1 1 2","0","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    combiner(term(n),accumulate(combiner,base,n-1,term))","TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), Tutor.synthesis.MagicK)))), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast)))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"(3, 9, 27)\n(2, 4, 8)\n(1, 1, 1)\n2\n","print accumulate(add, 11, 5, identity)":"(5, 5, 10)\n(4, 4, 8)\n(3, 3, 6)\n(2, 2, 4)\n(1, 1, 2)\n11\n","print accumulate(add, 11, 0, identity)":"11\n11\n","print accumulate(add, 11, 3, square)":"(3, 9, 12)\n(2, 4, 6)\n(1, 1, 2)\n11\n","print accumulate(add, 0, 5, identity)":"(5, 5, 10)\n(4, 4, 8)\n(3, 3, 6)\n(2, 2, 4)\n(1, 1, 2)\n0\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n ==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        print base\n        return base\n    else:\n        print(n,term(n),combiner(n,term(n)))\n        combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":588,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":10,"tests":[{"expected":"72","output":"0","input":"accumulate(mul, 2, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return base                    =>           \r\n        return combiner(base, term(n)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return combiner(base, term(n))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":589,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":14,"tests":[{"expected":"15","output":"16","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if combiner(0,7)!=0:\n        count_choice=0\n    else:\n        count_choice=1\n    def counter(combiner,base,n,term,total,count):\n        if count<=n:\n            placeholder=int(term(count))\n            total=combiner(total,placeholder)\n            return counter(combiner,base,n,term,total,count+1)\n        else:\n            return total\n    return counter(combiner,base,n,term,base,count_choice)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                              SideIndicator\r\n-----------                                              -------------\r\n        total_choice = 0                                 =>           \r\n        total_choice = 1                                 =>           \r\n    return  counter(combiner,base,n,term,total_choice,1) =>           \r\n        count_choice = 0                                 <=           \r\n        count_choice = 1                                 <=           \r\n    return  counter(combiner,base,n,term,1,count_choice) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if combiner(0, 7)!=0:\r\n        count_choice = 0\r\n    else:\r\n        count_choice = 1\r\n    def counter(combiner, base, n, term, total, count):\r\n        if count<=n:\r\n            placeholder = int(term(count))\r\n            total = combiner(total, placeholder)\r\n            return counter(combiner, base, n, term, total, count+1)\r\n        else:\r\n            return total\r\n    return counter(combiner, base, n, term, base, count_choice)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if combiner(0, 7)!=0:\r\n        count_choice = 0\r\n    else:\r\n        count_choice = 1\r\n    def counter(combiner, base, n, term, total, count):\r\n        if count<=n:\r\n            placeholder = int(term(count))\r\n            total = combiner(total, placeholder)\r\n            return counter(combiner, base, n, term, total, count+1)\r\n        else:\r\n            return total\r\n    return counter(combiner, base, n, term, base, count_choice)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72,8,2],[1,4,36,4,1]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26,21,17,14,12,11],[1,2,4,7,11,16,11,7,4,2,1]],"print accumulate(add, 11, 0, identity)":[[11],[1]],"print accumulate(add, 11, 3, square)":[[11,12,16,25,16,12,11],[1,2,6,15,6,2,1]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15,10,6,3,1,0],[1,2,4,7,11,16,11,7,4,2,1]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if combiner(0, 7)!=0:\r\n        count_choice = 0\r\n    else:\r\n        count_choice = 1\r\n    def counter(combiner, base, n, term, total, count):\r\n        if count<=n:\r\n            placeholder = int(term(count))\r\n            total = combiner(total, placeholder)\r\n            return counter(combiner, base, n, term, total, count+1)\r\n        else:\r\n            return combiner(base, total)\r\n    return counter(combiner, base, n, term, 1, count_choice)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"any\"))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))))","sequence_comparison_diff":{"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72,8,2],[1,4,36,4,1]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26,21,17,14,12,11],[1,2,4,7,11,16,11,7,4,2,1]],"print accumulate(add, 11, 0, identity)":[[11],[1]],"print accumulate(add, 11, 3, square)":[[11,12,16,25,16,12,11],[1,2,6,15,6,2,1]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15,10,6,3,1,0],[1,2,4,7,11,16,11,7,4,2,1]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"27\n","print accumulate(add, 11, 0, identity)":"12\n","print accumulate(add, 11, 3, square)":"26\n","print accumulate(add, 0, 5, identity)":"16\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if combiner(0,7) != 0:\n        total_choice = 0\n    else:\n        total_choice = 1\n    def counter(combiner,base,n,term,total,count):\n        if count <= n:\n            placeholder = int(term(count))\n            total = combiner(total,placeholder)\n            return counter(combiner,base,n,term,total,count+1)\n        else:\n            return combiner(base,total)\n\n    return  counter(combiner,base,n,term,total_choice,1)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if combiner(0,7)!=0:\n        count_choice=0\n    else:\n        count_choice=1\n    def counter(combiner,base,n,term,total,count):\n        if count<=n:\n            placeholder=int(term(count))\n            total=combiner(total,placeholder)\n            return counter(combiner,base,n,term,total,count+1)\n        else:\n            return combiner(base,total)\n    return counter(combiner,base,n,term,1,count_choice)\n"},{"Id":590,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":3,"tests":[{"expected":"15","output":"0","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n        base= combiner(term(n),base) =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return accumulate(combiner, base, n-1, term)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK))))))), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))","sequence_comparison_diff":{},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"2\n","print accumulate(add, 11, 5, identity)":"11\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"11\n","print accumulate(add, 0, 5, identity)":"0\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        base= combiner(term(n),base)\n        return accumulate(combiner,base,n-1,term)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return accumulate(combiner,base,n-1,term)\n"},{"Id":592,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    def terms(func,m):\n        if m==n:\n            return func(m)\n        else:\n            return combiner(func(m),terms(func,m+1))\n    if n==0:\n        return base\n    return combiner(base,terms(term,1))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n <= 0:      =>           \r\n        return base =>           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    def terms(func, m):\r\n        if m==n:\r\n            return func(m)\r\n        else:\r\n            return combiner(func(m), terms(func, m+1))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, terms(term, 1))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    def terms(func, m):\r\n        if m==n:\r\n            return func(m)\r\n        else:\r\n            return combiner(func(m), terms(func, m+1))\r\n    if n==0:\r\n        return base\r\n    return combiner(base, terms(term, 1))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"m":{},"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def terms(func, m):\r\n        if m==n:\r\n            return func(m)\r\n        else:\r\n            return combiner(func(m), terms(func, m+1))\r\n    return combiner(base, terms(term, 1))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms","    return combiner(func(m), terms(func, m + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms","    return combiner(func(m), terms(func, m + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms","    return combiner(func(m), terms(func, m + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms","    return combiner(func(m), terms(func, m + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms","    return combiner(func(m), terms(func, m + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms","    return combiner(func(m), terms(func, m + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in terms","    if m == n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"m":{},"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def terms(func, m): # This function uses combiner to mesh the terms together\n        if m == n:\n            return func(m)\n        else:\n            return combiner(func(m), terms(func, m + 1))\n    if n <= 0:\n        return base\n    return combiner(base, terms(term, 1)) # This function ties the base to the series formed by terms(term, n)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def terms(func,m):\n        if m==n:\n            return func(m)\n        else:\n            return combiner(func(m),terms(func,m+1))\n    return combiner(base,terms(term,1))\n"},{"Id":593,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":58,"tests":[{"expected":"25","output":"221652553","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                                     SideIndicator\r\n-----------                                                                     -------------\r\n        return combiner(accumulate(combiner, base, n - 1, term), term(n))       =>           \r\n    return accumulate(add, 0, n, term)                                          =>           \r\n    return accumulate(mul, 1, n, term)                                          =>           \r\n        return combiner(term(accumulate(combiner, base, n - 1, term)), term(n)) <=           \r\n    return _______                                                              <=           \r\n    return _______                                                              <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,1,4,2,64,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[11,1,12,2,14,3,17,4,21,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[11,1,122,2,14888,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,6,4,10,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(term(accumulate(combiner, base, n-1, term)), term(n))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","221652553","","# Error: expected","#     25","# but got","#     221652553","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK), 1), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,1,4,2,64,3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[11,1,12,2,14,3,17,4,21,5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[11,1,122,2,14888,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,6,4,10,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"36864\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"221652553\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n - 1, term), term(n))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(term(accumulate(combiner,base,n-1,term)),term(n))\n"},{"Id":594,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    def accumulate_func(n):\n        if n==1:\n            return term(1)\n        else:\n            return combiner(term(n),accumulate_func(n-1))\n    return combiner(base,accumulate_func(n))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                      SideIndicator\r\n-----------                                                      -------------\r\n    return combiner(base, accumulate_func(n)) if n > 0 else base =>           \r\n    return combiner(base, accumulate_func(n))                    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def accumulate_func(n):\r\n        if (n==1):\r\n            return term(1)\r\n        else:\r\n            return combiner(term(n), accumulate_func(n-1))\r\n    return combiner(base, accumulate_func(n))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    def accumulate_func(n):\r\n        if (n==1):\r\n            return term(1)\r\n        else:\r\n            return combiner(term(n), accumulate_func(n-1))\r\n    return combiner(base, accumulate_func(n))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    def accumulate_func(n):\r\n        if (n==1):\r\n            return term(1)\r\n        else:\r\n            return combiner(term(n), accumulate_func(n-1))\r\n    return combiner(base, accumulate_func(n))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_func","    return combiner(term(n),accumulate_func(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_func","    return combiner(term(n),accumulate_func(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_func","    return combiner(term(n),accumulate_func(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_func","    return combiner(term(n),accumulate_func(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_func","    return combiner(term(n),accumulate_func(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_func","    return combiner(term(n),accumulate_func(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate_func","    if(n==1):","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def accumulate_func(n):\n        if(n==1):\n            return term(1)\n        else:\n            return combiner(term(n),accumulate_func(n-1))\n    return combiner(base, accumulate_func(n)) if n > 0 else base\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    def accumulate_func(n):\n        if n==1:\n            return term(1)\n        else:\n            return combiner(term(n),accumulate_func(n-1))\n    return combiner(base,accumulate_func(n))\n"},{"Id":595,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":26,"tests":[{"expected":"15","output":"5","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    x=base\n    i=1\n    while i<=n:\n        base=combiner(base,term(i))\n        i+=1\n    return base\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n        x = combiner(x, term(i))    =>           \r\n        x = combiner(base, term(i)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = base\r\n    i = 1\r\n    while (i<=n):\r\n        base = combiner(base, term(i))\r\n        i += 1\r\n    return base","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = base\r\n    i = 1\r\n    while (i<=n):\r\n        base = combiner(base, term(i))\r\n        i += 1\r\n    return base","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]},"x":{"print accumulate(mul, 2, 3, square)":[[2,1,2,3,2],[2,1,2,8,3,18]],"print accumulate(add, 11, 5, identity)":[[11,1,11,2,11,3,11,4,11,5,11],[11,1,12,2,13,3,14,4,15,5,16]],"print accumulate(add, 11, 3, square)":[[11,1,11,2,11,3,11],[11,1,12,2,15,3,20]],"print accumulate(add, 0, 5, identity)":[[0,1,0,2,0,3,0,4,0,5,0],[0,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    x = base\r\n    i = 1\r\n    while (i<=n):\r\n        x = combiner(base, term(i))\r\n        i += 1\r\n    return x","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))))","sequence_comparison_diff":{"base":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]},"x":{"print accumulate(mul, 2, 3, square)":[[2,1,2,3,2],[2,1,2,8,3,18]],"print accumulate(add, 11, 5, identity)":[[11,1,11,2,11,3,11,4,11,5,11],[11,1,12,2,13,3,14,4,15,5,16]],"print accumulate(add, 11, 3, square)":[[11,1,11,2,11,3,11],[11,1,12,2,15,3,20]],"print accumulate(add, 0, 5, identity)":[[0,1,0,2,0,3,0,4,0,5,0],[0,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"18\n","print accumulate(add, 11, 5, identity)":"16\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"20\n","print accumulate(add, 0, 5, identity)":"5\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    i = 1\n    while (i <= n):\n        x = combiner(x, term(i))\n        i += 1\n    return x\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    x=base\n    i=1\n    while i<=n:\n        x=combiner(base,term(i))\n        i+=1\n    return x\n"},{"Id":596,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":1,"tests":[{"expected":"15","output":"NameError","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    count=1\n    total=base\n    while count<=n:\n        total=combiner(total,term(count))\n        count+=1\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        total = combiner(total, term(count))  =>           \r\n        total = combinder(total, term(count)) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    total = base\r\n    while count<=n:\r\n        total = combiner(total, term(count))\r\n        count += 1\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    total = base\r\n    while count<=n:\r\n        total = combiner(total, term(count))\r\n        count += 1\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"count":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    count = 1\r\n    total = base\r\n    while count<=n:\r\n        total = combinder(total, term(count))\r\n        count += 1\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    total = combinder(total, term(count))","NameError: name 'combinder' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"count":{"print accumulate(mul, 2, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5,6],[1]],"print accumulate(add, 11, 3, square)":[[1,2,3,4],[1]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5,6],[1]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"","print accumulate(add, 11, 5, identity)":"","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"","print accumulate(add, 0, 5, identity)":""},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    total = base\n    while count <= n:\n        total = combiner(total, term(count))\n        count += 1\n\n    return total\n\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    count=1\n    total=base\n    while count<=n:\n        total=combinder(total,term(count))\n        count+=1\n    return total\n"},{"Id":597,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":14,"tests":[{"expected":"15","output":"16","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return combiner(term(1),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n == 1:                         =>           \r\n    elif n ==0:                        =>           \r\n        return combiner(term(0), base) =>           \r\n    if n == 0:                         <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return combiner(term(1), base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"27\n","print accumulate(add, 11, 0, identity)":"12\n","print accumulate(add, 11, 3, square)":"26\n","print accumulate(add, 0, 5, identity)":"16\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(term(1), base)\n    elif n ==0:\n        return combiner(term(0), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) \n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return combiner(term(1),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":599,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":21,"tests":[{"expected":"15","output":"9","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    total=base\n    for i in range(1,n+1):\n        total=combiner(accumulate(combiner,base,i-1,term),term(i))\n    return total\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        total = combiner(total, term(i))      =>           \r\n        total = combiner(term(i-1), term(i))  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1):\r\n        total = combiner(accumulate(combiner, base, i-1, term), term(i))\r\n    return total","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1):\r\n        total = combiner(accumulate(combiner, base, i-1, term), term(i))\r\n    return total","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,1,2,3,1,2,1,2,3],[1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,1,2,3,1,2,1,2,3,4,1,2,1,2,3,1,2,1,2,3,4,5,1,2,1,2,3,1,2,1,2,3,4,1,2,1,2,3,1,2,1,2,3,4,5],[1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,1,2,3,1,2,1,2,3],[1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,1,2,3,1,2,1,2,3,4,1,2,1,2,3,1,2,1,2,3,4,5,1,2,1,2,3,1,2,1,2,3,4,1,2,1,2,3,1,2,1,2,3,4,5],[1,2,3,4,5]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,2,8,72],[2,0,4,36]],"print accumulate(add, 11, 5, identity)":[[11,12,11,12,14,11,12,11,12,14,17,11,12,11,12,14,11,12,11,12,14,17,21,11,12,11,12,14,11,12,11,12,14,17,11,12,11,12,14,11,12,11,12,14,17,21,26],[11,1,3,5,7,9]],"print accumulate(add, 11, 3, square)":[[11,12,11,12,16,11,12,11,12,16,25],[11,1,5,13]],"print accumulate(add, 0, 5, identity)":[[0,1,0,1,3,0,1,0,1,3,6,0,1,0,1,3,0,1,0,1,3,6,10,0,1,0,1,3,0,1,0,1,3,6,0,1,0,1,3,0,1,0,1,3,6,10,15],[0,1,3,5,7,9]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,1,2,3,1,2,1,2,3,4,1,2,1,2,3,1,2,1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,1,2,3,1,2,1,2,3,4,1,2,1,2,3,1,2,1,2,3,4,5],[0,1,2,3,4,5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,0,3,1,0,1,3,2,0,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,0,5,1,0,1,5,2,0,2,1,0,1,2,5,3,0,3,1,0,1,3,2,0,2,1,0,1,2,3,5,4,0,4,1,0,1,4,2,0,2,1,0,1,2,4,3,0,3,1,0,1,3,2,0,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,0,3,1,0,1,3,2,0,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,0,5,1,0,1,5,2,0,2,1,0,1,2,5,3,0,3,1,0,1,3,2,0,2,1,0,1,2,3,5,4,0,4,1,0,1,4,2,0,2,1,0,1,2,4,3,0,3,1,0,1,3,2,0,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    total = base\r\n    for i in range(1, n+1):\r\n        total = combiner(term(i-1), term(i))\r\n    return total","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","9","","# Error: expected","#     15","# but got","#     9","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, StartsWithParent(Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))))","sequence_comparison_diff":{"i":{"print accumulate(mul, 2, 3, square)":[[1,2,1,2,3,1,2,1,2,3],[1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,1,2,3,1,2,1,2,3,4,1,2,1,2,3,1,2,1,2,3,4,5,1,2,1,2,3,1,2,1,2,3,4,1,2,1,2,3,1,2,1,2,3,4,5],[1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,1,2,3,1,2,1,2,3],[1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,1,2,3,1,2,1,2,3,4,1,2,1,2,3,1,2,1,2,3,4,5,1,2,1,2,3,1,2,1,2,3,4,1,2,1,2,3,1,2,1,2,3,4,5],[1,2,3,4,5]]},"total":{"print accumulate(mul, 2, 3, square)":[[2,8,2,8,72],[2,0,4,36]],"print accumulate(add, 11, 5, identity)":[[11,12,11,12,14,11,12,11,12,14,17,11,12,11,12,14,11,12,11,12,14,17,21,11,12,11,12,14,11,12,11,12,14,17,11,12,11,12,14,11,12,11,12,14,17,21,26],[11,1,3,5,7,9]],"print accumulate(add, 11, 3, square)":[[11,12,11,12,16,11,12,11,12,16,25],[11,1,5,13]],"print accumulate(add, 0, 5, identity)":[[0,1,0,1,3,0,1,0,1,3,6,0,1,0,1,3,0,1,0,1,3,6,10,0,1,0,1,3,0,1,0,1,3,6,0,1,0,1,3,0,1,0,1,3,6,10,15],[0,1,3,5,7,9]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,1,2,3],[0,1,2,3]],"print accumulate(add, 11, 5, identity)":[[1,2,1,2,3,1,2,1,2,3,4,1,2,1,2,3,1,2,1,2,3,4,5],[0,1,2,3,4,5]],"print accumulate(add, 11, 3, square)":[[1,2,1,2,3],[0,1,2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,1,2,3,1,2,1,2,3,4,1,2,1,2,3,1,2,1,2,3,4,5],[0,1,2,3,4,5]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,0,3,1,0,1,3,2,0,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,0,5,1,0,1,5,2,0,2,1,0,1,2,5,3,0,3,1,0,1,3,2,0,2,1,0,1,2,3,5,4,0,4,1,0,1,4,2,0,2,1,0,1,2,4,3,0,3,1,0,1,3,2,0,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,0,3,1,0,1,3,2,0,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,0,5,1,0,1,5,2,0,2,1,0,1,2,5,3,0,3,1,0,1,3,2,0,2,1,0,1,2,3,5,4,0,4,1,0,1,4,2,0,2,1,0,1,2,4,3,0,3,1,0,1,3,2,0,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"36\n","print accumulate(add, 11, 5, identity)":"9\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"13\n","print accumulate(add, 0, 5, identity)":"9\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        total = combiner(total, term(i)) \n    return total\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    total=base\n    for i in range(1,n+1):\n        total=combiner(term(i-1),term(i))\n    return total\n"},{"Id":601,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":50,"tests":[{"expected":"15","output":"Timeout","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    term_number=0\n    result=base\n    if add:\n        combiner==add\n    elif combiner==mul:\n        while term_number<n:\n            result*=term(term_number)\n        return result\n    def helper(a,n):\n        if n==0:\n            return a\n        else:\n            a=combiner(a,term(n))\n        return helper(a,n-1)\n    return helper(base,n)\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                                                                       SideIndicator\r\n-----------                                                                       -------------\r\n    return accumulate(add, 0, n, term)                                            =>           \r\n    return accumulate(mul, 1, n, term)                                            =>           \r\n    return accumulate(lambda a,x: combiner(a,x) if pred(x) else a, base, n, term) =>           \r\n    term_number = 0                                                               <=           \r\n    result = base                                                                 <=           \r\n    if combiner == add:                                                           <=           \r\n        while term_number < n:                                                    <=           \r\n            result += term(term_number)                                           <=           \r\n        return result                                                             <=           \r\n    elif combiner == mul:                                                         <=           \r\n        while term_number < n:                                                    <=           \r\n            result *= term(term_number)                                           <=           \r\n        return result                                                             <=           \r\n    return accumulate(add, lambda base: base , n, term  )                         <=           \r\n    return _______                                                                <=           \r\n    return _______                                                                <=           \r\n                                                                                  <=           \r\n                                                                                  <=           \r\n    \"*** YOUR CODE HERE ***\"                                                      <=           \r\n                                                                                  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    term_number = 0\r\n    result = base\r\n    if add:combiner==add\r\n    elif combiner==mul:\r\n        while term_number<n:\r\n            result *= term(term_number)\r\n        return result\r\n    def helper(a, n):\r\n        if n==0:\r\n            return a\r\n        else:\r\n            a = combiner(a, term(n))\r\n        return helper(a, n-1)\r\n    return helper(base, n)","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    term_number = 0\r\n    result = base\r\n    if add:combiner==add\r\n    elif combiner==mul:\r\n        while term_number<n:\r\n            result *= term(term_number)\r\n        return result\r\n    def helper(a, n):\r\n        if n==0:\r\n            return a\r\n        else:\r\n            a = combiner(a, term(n))\r\n        return helper(a, n-1)\r\n    return helper(base, n)","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"result":{"print accumulate(mul, 2, 3, square)":[[2],[2,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[0]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    term_number = 0\r\n    result = base\r\n    if combiner==add:\r\n        while term_number<n:\r\n            result += term(term_number)\r\n        return result\r\n    elif combiner==mul:\r\n        while term_number<n:\r\n            result *= term(term_number)\r\n        return result\r\n    def helper(a, n):\r\n        if n==0:\r\n            return a\r\n        else:\r\n            a = combiner(a, term(n))\r\n        return helper(a, n-1)\r\n    return helper(base, n)","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     15","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"any\"))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\"))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"any\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"result":{"print accumulate(mul, 2, 3, square)":[[2],[2,0]]},"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[0]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[0]],"print accumulate(add, 11, 3, square)":[[3,2,1],[0]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[0]]},"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":null,"print accumulate(add, 11, 5, identity)":null,"print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":null,"print accumulate(add, 0, 5, identity)":null},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(a,n):\n        if n == 0:\n            return a\n        else:\n            a = combiner(a, term(n))\n        return helper(a, n-1)\n    return helper(base, n)\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    term_number=0\n    result=base\n    if combiner==add:\n        while term_number<n:\n            result+=term(term_number)\n        return result\n    elif combiner==mul:\n        while term_number<n:\n            result*=term(term_number)\n        return result\n    def helper(a,n):\n        if n==0:\n            return a\n        else:\n            a=combiner(a,term(n))\n        return helper(a,n-1)\n    return helper(base,n)\n"},{"Id":602,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":54,"tests":[{"expected":"26","output":"0","input":"accumulate(add, 11, 5, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    prev_term=base\n    for x in range(1,n+1):\n        current_term=term(x)\n        prev_term=combiner(current_term,prev_term)\n    return prev_term\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    prev_term = base            =>           \r\n    for x in range (1, n+1):    =>           \r\n    prev_term = 0               <=           \r\n    for x in range (base, n+1): <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    prev_term = base\r\n    for x in range(1, n+1):\r\n        current_term = term(x)\r\n        prev_term = combiner(current_term, prev_term)\r\n    return prev_term","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    prev_term = base\r\n    for x in range(1, n+1):\r\n        current_term = term(x)\r\n        prev_term = combiner(current_term, prev_term)\r\n    return prev_term","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"current_term":{"print accumulate(mul, 2, 3, square)":[[1,4,9],[4,9]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]},"prev_term":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[0]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    prev_term = 0\r\n    for x in range(base, n+1):\r\n        current_term = term(x)\r\n        prev_term = combiner(current_term, prev_term)\r\n    return prev_term","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     26","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))))))","sequence_comparison_diff":{"current_term":{"print accumulate(mul, 2, 3, square)":[[1,4,9],[4,9]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[2,3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[0,1,2,3,4,5]]},"prev_term":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[0]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[0]],"print accumulate(add, 11, 0, identity)":[[11],[0]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"0\n","print accumulate(add, 11, 5, identity)":"0\n","print accumulate(add, 11, 0, identity)":"0\n","print accumulate(add, 11, 3, square)":"0\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    prev_term = base\n    for x in range (1, n+1):\n        current_term = term(x)\n        prev_term = combiner(current_term, prev_term)\n\n    return prev_term\n        \n \n    \n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    prev_term=0\n    for x in range(base,n+1):\n        current_term=term(x)\n        prev_term=combiner(current_term,prev_term)\n    return prev_term\n"},{"Id":603,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":7,"tests":[{"expected":"25","output":"135","input":"accumulate(add, 11, 3, square)   "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,11]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,11]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return term(base)\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{"print accumulate(mul, 2, 3, square)":[[3,2,1],[3,2,1,2]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,11]],"print accumulate(add, 11, 3, square)":[[3,2,1],[3,2,1,11]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1],[5,4,3,2,1,0]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"144\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"135\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return term(base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"},{"Id":604,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":17,"tests":[{"expected":"15","output":"25","input":"accumulate(add, 0, 5, identity)  "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    ans=base\n    for n in range(1,n+1):\n        ans=combiner(ans,term(n))\n    return ans\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n        ans = combiner(ans, term(i)); =>           \r\n        ans = combiner(ans, term(n)); <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    ans = base\r\n    for n in range(1, n+1):\r\n        ans = combiner(ans, term(n))\r\n    return ans","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    ans = base\r\n    for n in range(1, n+1):\r\n        ans = combiner(ans, term(n))\r\n    return ans","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,1,2,3,4,5],[5]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[5]]},"ans":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,18,162,1458]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,16,21,26,31,36]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,20,29,38]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,5,10,15,20,25]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    ans = base\r\n    for i in range(1, n+1):\r\n        ans = combiner(ans, term(n))\r\n    return ans","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, StartsWithTarget(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","sequence_comparison_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[5,1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[3,1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[5,1,2,3,4,5],[5]]},"x":{"print accumulate(mul, 2, 3, square)":[[1,2,3],[3]],"print accumulate(add, 11, 5, identity)":[[1,2,3,4,5],[5]],"print accumulate(add, 11, 3, square)":[[1,2,3],[3]],"print accumulate(add, 0, 5, identity)":[[1,2,3,4,5],[5]]},"ans":{"print accumulate(mul, 2, 3, square)":[[2,8,72],[2,18,162,1458]],"print accumulate(add, 11, 5, identity)":[[11,12,14,17,21,26],[11,16,21,26,31,36]],"print accumulate(add, 11, 3, square)":[[11,12,16,25],[11,20,29,38]],"print accumulate(add, 0, 5, identity)":[[0,1,3,6,10,15],[0,5,10,15,20,25]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"1458\n","print accumulate(add, 11, 5, identity)":"36\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"38\n","print accumulate(add, 0, 5, identity)":"25\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # end = base;\n    # while (n >= 0):\n    #     if (n == 0):\n    #         return end;\n    #     else:\n    #         end = combiner(end, term(n));\n    #         n -= 1;\n    # return end;\n    ans = base;\n    for i in range(1, n+1):\n        ans = combiner(ans, term(i));\n    return ans;\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    ans=base\n    for i in range(1,n+1):\n        ans=combiner(ans,term(n))\n    return ans\n"},{"Id":606,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject                    SideIndicator\r\n-----------                    -------------\r\n    if n == 0:                 =>           \r\n        return base            =>           \r\n    #if n == 1:                =>           \r\n        #return base + term(1) =>           \r\n    if n == 1:                 <=           \r\n        return base + term(1)  <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94,-95,-96,-97,-98,-99,-100,-101,-102,-103,-104,-105,-106,-107,-108,-109,-110,-111,-112,-113,-114,-115,-116,-117,-118,-119,-120,-121,-122,-123,-124,-125,-126,-127,-128,-129,-130,-131,-132,-133,-134,-135,-136,-137,-138,-139,-140,-141,-142,-143,-144,-145,-146,-147,-148,-149,-150,-151,-152,-153,-154,-155,-156,-157,-158,-159,-160,-161,-162]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return base+term(1)\r\n    else:\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, StartsWithParent(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, StartsWithParent(Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), Tutor.synthesis.MagicK)), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, StartsWithParent(Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), Tutor.synthesis.MagicK), 0), Selected(\\x => Match(x, StartsWithParent(Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast)))))))","sequence_comparison_diff":{"n":{"print accumulate(mul, 2, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 11, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]],"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94,-95,-96,-97,-98,-99,-100,-101,-102,-103,-104,-105,-106,-107,-108,-109,-110,-111,-112,-113,-114,-115,-116,-117,-118,-119,-120,-121,-122,-123,-124,-125,-126,-127,-128,-129,-130,-131,-132,-133,-134,-135,-136,-137,-138,-139,-140,-141,-142,-143,-144,-145,-146,-147,-148,-149,-150,-151,-152,-153,-154,-155,-156,-157,-158,-159,-160,-161,-162]],"print accumulate(add, 11, 3, square)":[[3,2,1,0,1,2,3],[3,2,1,2,3]],"print accumulate(add, 0, 5, identity)":[[5,4,3,2,1,0,1,2,3,4,5],[5,4,3,2,1,2,3,4,5]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"108\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    #if n == 1:\n        #return base + term(1)\n    else:\n        return combiner(accumulate(combiner, base, n - 1, term), term(n))\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return base+term(1)\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n"},{"Id":607,"augmented_tidy_SynthesizedAfter_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":"11\n","print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"group_id":2,"tests":[{"expected":"11","output":"RecursionError","input":"accumulate(add, 11, 0, identity) "}],"diff_lines":[],"tidy_SynthesizedAfter":"def accumulate(combiner,base,n,term):\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","studentId":0,"IsFixed":true,"GeneratedFix":null,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n                    <=           \r\n\r\n\r\n","synthesized_after":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","SynthesizedAfter":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==0:\r\n        return base\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","augmented_tidy_SynthesizedAfter":"REMOVED","dynamic_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"before":"\r\ndef accumulate(combiner, base, n, term):\r\n    if n==1:\r\n        return combiner(base, term(1))\r\n    else:\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""],"augmented_tidy_before":"REMOVED","UsedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, StartsWithParent(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\")))))))))), InOrderSort(ast)))))","sequence_comparison_diff":{"x":{},"n":{"print accumulate(add, 11, 0, identity)":[[0],[0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81]]}},"Time":0,"ErrorFlag":0,"augmented_tidy_before_testcase_to_output":{"print accumulate(mul, 2, 3, square)":"72\n","print accumulate(add, 11, 5, identity)":"26\n","print accumulate(add, 11, 0, identity)":null,"print accumulate(add, 11, 3, square)":"25\n","print accumulate(add, 0, 5, identity)":"15\n"},"after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #\n    # if n == 1 and base == 1:\n    #     return 1\n    # # if combiner == mul:\n    # #     return product(n, term) + base\n    # else:\n    #     a = combiner(base, term(n))\n    #\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","date":null,"is_fixed":false,"tidy_before":"def accumulate(combiner,base,n,term):\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n"}]}