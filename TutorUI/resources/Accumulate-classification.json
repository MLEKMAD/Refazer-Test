[[{"Id":1,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n        a = combiner(a, term(i))    =>           \r\n        a = combiner(base, term(i)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n\n\n    a = base\n    i = 1\n    while i <= n:\n    \ta = combiner(base, term(i))\n    \ti += 1\n    return a \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n\n\n    a = base\n    i = 1\n    while i <= n:\n    \ta = combiner(a, term(i))\n    \ti += 1\n    return a \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-a)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":2,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    return helper(n, 1) =>           \r\n    return helper(n, 2) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(j, k):\n    \tif j == 0:\n    \t\treturn base\n    \telif k == j:\n    \t\treturn combiner(base, term(k))\n    \telse:\n    \t\treturn combiner(term(k), helper(j, k+1))\n    return helper(n, 2)","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(j, k):\n    \tif j == 0:\n    \t\treturn base\n    \telif k == j:\n    \t\treturn combiner(base, term(k))\n    \telse:\n    \t\treturn combiner(term(k), helper(j, k+1))\n    return helper(n, 1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":57,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    while n>1: =>           \r\n    while n>0: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    value=term(1)\n    if n==0:\n        return base\n    while n>0:\n        value=combiner(value,term(n))\n        n-=1\n    return combiner(value, base)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    value=term(1)\n    if n==0:\n        return base\n    while n>1:\n        value=combiner(value,term(n))\n        n-=1\n    return combiner(value, base)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":65,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    counter = 1 =>           \r\n    counter = 0 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 0\n    while counter <= n:\n        num = term(counter)\n        base = combiner(base, num)\n        counter = counter + 1\n    return base\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    while counter <= n:\n        num = term(counter)\n        base = combiner(base, num)\n        counter = counter + 1\n    return base\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":96,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    for x in range(1, n + 1):          =>           \r\n    return accumulate(add, 0, n, term) =>           \r\n    return accumulate(mul, 1, n, term) =>           \r\n    for x in range(2, n + 1):          <=           \r\n    return _______                     <=           \r\n    return _______                     <=           \r\n    \"*** YOUR CODE HERE ***\"           <=           \r\n    \"*** YOUR CODE HERE ***\"           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    for x in range(2, n + 1):\n        base = combiner(base, term(x))\n    return base","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    for x in range(1, n + 1):\n        base = combiner(base, term(x))\n    return base","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":165,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    while n>=1: =>           \r\n    while n>=0: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total = base\n    while n>=0:\n        total = combiner(total,term(n))\n        n-=1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total = base\n    while n>=1:\n        total = combiner(total,term(n))\n        n-=1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":208,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, x = base, 1 =>           \r\n                       =>           \r\n    total, x = base, 0 <=           \r\n                       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, x = base, 0\n    while x <= n:\n        total, x = combiner(total, term(x)),x+1\n    return total\n    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, x = base, 1\n    while x <= n:\n        total, x = combiner(total, term(x)),x+1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":254,"diff":"\r\nInputObject                                     SideIndicator\r\n-----------                                     -------------\r\n        return combiner(base,first_sequence(1)) =>           \r\n        return combiner(base,first_sequence(0)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def first_sequence(i):\n        if i==n: \n            return term(i)\n        else:\n            return combiner(term(i), first_sequence(i+1))\n    if n==0:\n        return base\n    else:\n        return combiner(base,first_sequence(0))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def first_sequence(i):\n        if i==n: \n            return term(i)\n        else:\n            return combiner(term(i), first_sequence(i+1))\n    if n==0:\n        return base\n    else:\n        return combiner(base,first_sequence(1))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":324,"diff":"\r\nInputObject                                    SideIndicator\r\n-----------                                    -------------\r\n    acc, i = base, 1                           =>           \r\n        acc, i = combiner(acc, term(i)), i + 1 =>           \r\n    acc, i = base, 0                           <=           \r\n        acc, i = combiner(acc,term(i)), i + 1  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    acc, i = base, 0\n    while i <= n:\n        acc, i = combiner(acc,term(i)), i + 1\n    return acc\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    acc, i = base, 1\n    while i <= n:\n        acc, i = combiner(acc, term(i)), i + 1\n    return acc\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":342,"diff":"\r\nInputObject                                    SideIndicator\r\n-----------                                    -------------\r\n    for i in range(1, n+1):                    =>           \r\n    return accumulate(add, base, n, term)      =>           \r\n    return accumulate(mul,1, n, term)          =>           \r\n    for i in range(0, n+1):                    <=           \r\n        #return accumulate(add, base, n, term) <=           \r\n        #return accumulate(mul,1, n, term)     <=           \r\n    \"*** YOUR CODE HERE ***\"                   <=           \r\n    \"*** YOUR CODE HERE ***\"                   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(0, n+1):\n        total = combiner(total, term(i))\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        total = combiner(total, term(i))\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":357,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(base, accumulation_counter(combiner, 1, n, term)) =>           \r\n        return combiner(base, accumulation_counter(combiner, 0, n, term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    def accumulation_counter(combiner, counter, n, f):\n        if counter == n:\n            return f(n)\n        else: \n            return combiner(f(counter), accumulation_counter(combiner, (counter + 1), n, f))\n\n    if n == 0:\n        return base\n    else:\n        return combiner(base, accumulation_counter(combiner, 0, n, term))\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    def accumulation_counter(combiner, counter, n, f):\n        if counter == n:\n            return f(n)\n        else: \n            return combiner(f(counter), accumulation_counter(combiner, (counter + 1), n, f))\n\n    if n == 0:\n        return base\n    else:\n        return combiner(base, accumulation_counter(combiner, 1, n, term))\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":405,"diff":"\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n    if n> 1: =>           \r\n    if n> 0: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    base =  combiner(base,term(n))\n    if n> 0:\n        return accumulate(combiner, base, n-1, term)\n    else:\n        return base\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    base =  combiner(base,term(n))\n    if n> 1:\n        return accumulate(combiner, base, n-1, term)\n    else:\n        return base\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":419,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n        while counter>1: =>           \r\n        while counter>0: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulate_helper(n, term):\n        counter=n-1\n        listen = [base]\n        if counter < 0:\n            result = 0\n        else:\n            result = combiner(term(n), term(counter))\n        while counter>0:\n            counter-=1\n            x = term(counter)\n            result = combiner(x, result)\n        return result\n    result = accumulate_helper(n, term)\n    return combiner(base, result)\n    print(listen)","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulate_helper(n, term):\n        counter=n-1\n        listen = [base]\n        if counter < 0:\n            result = 0\n        else:\n            result = combiner(term(n), term(counter))\n        while counter>1:\n            counter-=1\n            x = term(counter)\n            result = combiner(x, result)\n        return result\n    result = accumulate_helper(n, term)\n    return combiner(base, result)\n    print(listen)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":434,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    i = 1   =>           \r\n    i = 0   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 0\n    combined = base\n    while i <= n:\n        combined = combiner(combined, term(i))\n        i += 1\n    return combined\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    combined = base\n    while i <= n:\n        combined = combiner(combined, term(i))\n        i += 1\n    return combined\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":490,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    a = 1   =>           \r\n    a = 0   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    a = 0\n    b = base\n    while a <= n:\n        b = combiner(b, term(a))\n        a += 1\n    return b\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    a = 1\n    b = base\n    while a <= n:\n        b = combiner(b, term(a))\n        a += 1\n    return b\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":495,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    while i > 1: =>           \r\n    while i > 0: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = n\n    total = term(n)\n    while i > 0:\n        i -= 1\n        total = combiner(total, term(i))\n    return combiner(total, base)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = n\n    total = term(n)\n    while i > 1:\n        i -= 1\n        total = combiner(total, term(i))\n    return combiner(total, base)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":499,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    i = 1   =>           \r\n    i = 0   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 0\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":3,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n<1:    =>           \r\n    if base<1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if base<1:\n        return base\n    def accumulate_helper(combiner, n, term, num):\n        if num==n:\n            return term(num)\n        else:\n            return combiner(term(num), accumulate_helper(combiner, n, term, num+1))\n\n    return combiner(base, accumulate_helper(combiner, n, term, 1))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n<1:\n        return base\n    def accumulate_helper(combiner, n, term, num):\n        if num==n:\n            return term(num)\n        else:\n            return combiner(term(num), accumulate_helper(combiner, n, term, num+1))\n\n    return combiner(base, accumulate_helper(combiner, n, term, 1))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":8,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(m), accumulate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else: \n        return combiner(term(m), accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else: \n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(m), accumulate(combiner, base, n-1, term))","NameError: name 'm' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":409,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    if term(n)==0:    =>           \r\n    if term(base)==0: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if term(base)==0:\n        return base\n    return combiner(base, accumulate(combiner, term(n), n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if term(n)==0:\n        return base\n    return combiner(base, accumulate(combiner, term(n), n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":4,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, k =base, 1  =>           \r\n    total, k ==base, 1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k ==base, 1\n    while k<=n:\n        total=combiner(total, term(k))\n        k+=1\n    return total\n    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k =base, 1\n    while k<=n:\n        total=combiner(total, term(k))\n        k+=1\n    return total\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(ConstNode(TupleExpressionNode-False, Children(ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0)))), SingleChild(ConstNode(TupleExpressionNode-False, Children(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), SingleChild(ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), 0)))))))), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(ExpressionStatementNode, TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    total, k ==base, 1","UnboundLocalError: local variable 'total' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":5,"diff":"\r\nInputObject                                                                                 SideIndicator\r\n-----------                                                                                 -------------\r\n            return combiner(term(n), term(n - 1)) * accumulate(combiner, base, n - 2, term) =>           \r\n    return accumulate(add, 0, n, term)                                                      =>           \r\n            return combiner(term(n), term(n - 1)) * accumulate(combiner, base, n - 1, term) <=           \r\n    return _______                                                                          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        if n < 1:\n            return base\n        else:\n            return combiner(term(n), term(n - 1)) + accumulate(combiner, base, n - 2, term)\n    elif combiner == mul:\n        if n == 1:\n            return base\n        else:\n            return combiner(term(n), term(n - 1)) * accumulate(combiner, base, n - 1, term)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        if n < 1:\n            return base\n        else:\n            return combiner(term(n), term(n - 1)) + accumulate(combiner, base, n - 2, term)\n    elif combiner == mul:\n        if n == 1:\n            return base\n        else:\n            return combiner(term(n), term(n - 1)) * accumulate(combiner, base, n - 2, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-2)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","288","","# Error: expected","#     72","# but got","#     288","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":6,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n    return combiner(accumulate(combiner, base, n-1, term), n)       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    return combiner(accumulate(combiner, base, n-1, term), n)","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    return combiner(accumulate(combiner, base, n-1, term), term(n))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)))))), 2), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":316,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n        total = combiner(total,term(n)) =>           \r\n        total = combiner(total,n)       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total = base\n    while 1 <= n:\n        total = combiner(total,n)\n        n = n-1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total = base\n    while 1 <= n:\n        total = combiner(total,term(n))\n        n = n-1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)))))), 2), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":335,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total = combiner(total, i)       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    total = base\n    i = 1\n    if n == 0:\n        return base\n    while i <= n:\n        total = combiner(total, i)\n        i += 1\n    return total\n        \n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    total = base\n    i = 1\n    if n == 0:\n        return base\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n        \n    \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)))))), 2), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":413,"diff":"\r\nInputObject                                     SideIndicator\r\n-----------                                     -------------\r\n        total = combiner(total, term(counter))  =>           \r\n        total = combiner(total, counter)        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1\n    while counter <= n:\n        total = combiner(total, counter)  \n        counter = counter + 1\n    return total","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1\n    while counter <= n:\n        total = combiner(total, term(counter)) \n        counter = counter + 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)))))), 2), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":421,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total = combiner(total, i)       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = base\n    if n == 0:\n        return total\n    while i <= n:\n        total = combiner(total, i)\n        i += 1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = base\n    if n == 0:\n        return total\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)))))), 2), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":528,"diff":"\r\nInputObject                                                                               SideIndicator\r\n-----------                                                                               -------------\r\n        total = combiner(total, term(k))                                                  =>           \r\n    def f(g, h):                                                                          =>           \r\n        return g                                                                          =>           \r\n    return accumulate(lambda y,x: combiner(y,x) if pred(x) else f(y, x), base, n, term)   =>           \r\n        total = combiner(total, k)                                                        <=           \r\n    return accumulate(combiner, base, n, term)                                            <=           \r\n                                                                                          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    lst = map(term,range(1, n+1))\n\n    total = base\n    k = 0\n    while k < n:\n        k += 1\n        total = combiner(total, k)\n    return total\n    \"\"\"def apply(f):\n        return map(f, lst)\n\n    def combine_option(j):\n        if combiner(1,4) == 5:\n            return base + sum(apply(term))\n        else:\n            return base * product(n, term)\n\n    return combine_option(1)\"\"\"\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    lst = map(term,range(1, n+1))\n\n    total = base\n    k = 0\n    while k < n:\n        k += 1\n        total = combiner(total, term(k))\n    return total\n    \"\"\"def apply(f):\n        return map(f, lst)\n\n    def combine_option(j):\n        if combiner(1,4) == 5:\n            return base + sum(apply(term))\n        else:\n            return base * product(n, term)\n\n    return combine_option(1)\"\"\"\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)))))), 2), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":574,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return accumulate(combiner, combiner(base, term(n)), n-1, term) =>           \r\n        return accumulate(combiner, combiner(base, n), n-1, term)       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, combiner(base, n), n-1, term)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)))))), 2), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":9,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    if combiner == add: =>           \r\n        k = 0           =>           \r\n        k = 1           =>           \r\n                        =>           \r\n    else:               =>           \r\n    k = base            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"if n < 1:\n        return base\n    else:\n        total = base\n        total = combiner(total, term(n))\n        return total\n        return accumulate(combiner, __, n - 1, term)\"\"\"\n\n    k = base\n    total = base\n    while k <= n:\n        total = combiner(total, term(k))\n        k +=1\n    return total\n\n\n    \"*** YOUR CODE HERE ***\"\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"if n < 1:\n        return base\n    else:\n        total = base\n        total = combiner(total, term(n))\n        return total\n        return accumulate(combiner, __, n - 1, term)\"\"\"\n\n    if combiner == add:\n        k = 0\n    else:\n        k = 1\n    \n    total = base\n    while k <= n:\n        total = combiner(total, term(k))\n        k +=1\n    return total\n\n\n    \"*** YOUR CODE HERE ***\"\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-combiner), SingleChild(LeafConstNode(NameExpressionNode-add)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-0))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), 0)))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","11","","# Error: expected","#     26","# but got","#     11","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":11,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return combiner(term(n), base)\n    return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(term(n), base)\n    return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\"))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":13,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner (term(n), accumulate(combiner, base, n-1,term))\n#combiner(combiner(base,term(n)), accumulate(combiner,base, n-1,term))\n'''combiner(base, term(n))'''\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner (term(n), accumulate(combiner, base, n-1,term))\n#combiner(combiner(base,term(n)), accumulate(combiner,base, n-1,term))\n'''combiner(base, term(n))'''\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\"))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner (term(n), accumulate(combiner, base, n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner (term(n), accumulate(combiner, base, n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner (term(n), accumulate(combiner, base, n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner (term(n), accumulate(combiner, base, n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner (term(n), accumulate(combiner, base, n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner (term(n), accumulate(combiner, base, n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":153,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n                    =>           \r\n                    =>           \r\n        return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    if n == 1:\n        return combiner(base, term(1))\n    base = combiner(base, term(n))\n    return accumulate(combiner, base, n-1, term)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    \n    if n == 1:\n        return combiner(base, term(1))\n    \n    base = combiner(base, term(n))\n    \n    return accumulate(combiner, base, n-1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\"))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":340,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\"))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","RecursionError: maximum recursion depth exceeded","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":12,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    return helper(0,base)              =>           \r\n    return combiner(helper(0,0), base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i,total):\n        if i == n:\n            return total\n        else:\n            total = combiner(total, term(i+1))\n            return helper(i+1 , total)\n    return combiner(helper(0,0), base)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i,total):\n        if i == n:\n            return total\n        else:\n            total = combiner(total, term(i+1))\n            return helper(i+1 , total)\n    return helper(0,base)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":14,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n        return accumulate(combiner,base,n-1,term)                   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"total=base\n    counter=1\n    while counter<=n:\n        total=combiner(term(counter),total)\n        counter=counter+1\n    return total\"\"\"\n    if n==0:\n        return base\n    else: \n        return accumulate(combiner,base,n-1,term)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"total=base\n    counter=1\n    while counter<=n:\n        total=combiner(term(counter),total)\n        counter=counter+1\n    return total\"\"\"\n    if n==0:\n        return base\n    else: \n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":130,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n                                                                        =>           \r\n                                                                        =>           \r\n        return accumulate(combiner, base, n-1, term)                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n\n    else:\n        return accumulate(combiner, base, n-1, term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":261,"diff":"\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n        return combiner(term(n), accumulate(combiner,base, n - 1, term)) =>           \r\n        return accumulate(combiner, base, n - 1, term)                   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, base, n - 1, term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner,base, n - 1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":15,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while n >= 1: =>           \r\n    while n > 1:  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total = base\n    while n > 1:\n        total = combiner(total, term(n))\n        n -= 1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total = base\n    while n >= 1:\n        total = combiner(total, term(n))\n        n -= 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1))))), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":207,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n        if n >= 1: =>           \r\n        if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        accumulation = accumulate(combiner, base, n-1, term)\n        if n == 1:\n            n = term(n)\n        return combiner(n, accumulation)","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        accumulation = accumulate(combiner, base, n-1, term)\n        if n >= 1:\n            n = term(n)\n        return combiner(n, accumulation)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1))))), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"BinaryExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":16,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return accumulate(combiner, combiner(base, term(n)), n-1, term) =>           \r\n                                                                        =>           \r\n        base += term(n)                                                 <=           \r\n        n -= 1                                                          <=           \r\n        return accumulate(combiner, base, n, term)                      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        base += term(n)\n        n -= 1\n        return accumulate(combiner, base, n, term)","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Target(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))))))))), 2), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","16","","# Error: expected","#     72","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":17,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    combiner = lambda f: f(x, y) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    combiner = lambda f: f(x, y)\n\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(LambdaExpressionNode, TChild(Node(FunctionDefinitionNode-<lambda$710>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(LambdaExpressionNode, TChild(Node(FunctionDefinitionNode-<lambda$710>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","TypeError: <lambda>() takes 1 positional argument but 2 were given","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":18,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    total = base                           =>           \r\n    b = 1                                  =>           \r\n    while b <= n:                          =>           \r\n        total = combiner(term(b), total)   =>           \r\n        b += 1                             =>           \r\n    return total                           =>           \r\n                                           =>           \r\n    result = base                          <=           \r\n    for i in range(base, n + 1):           <=           \r\n        result = combiner(result, term(i)) <=           \r\n    return result                          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result = base\n    for i in range(base, n + 1):\n        result = combiner(result, term(i))\n    return result ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    b = 1\n    while b <= n:\n        total = combiner(term(b), total)\n        b += 1\n    return total \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-b), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ForStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Target(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-b)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-b), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0))))), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-b)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 2), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-b), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-b), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)))), SingleChild(ReferenceNode(node, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Target(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","11","","# Error: expected","#     26","# but got","#     11","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":19,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n            return total * base =>           \r\n            return total + base <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        total, k = 0, 1\n        if term == identity:\n            while k <= n:\n                total, k = total + k, k + 1\n            return total + base\n        else:\n            while k <= n:\n                total, k = total + (k**2), k + 1\n            return total + base\n    else:\n        total, k = 1, 1\n        if term == identity:\n            while k <= n:\n                total, k = total * k, k + 1\n            return total * base\n        else:\n            while k <= n:\n                total, k = total * (k*k), k + 1\n            return total + base\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        total, k = 0, 1\n        if term == identity:\n            while k <= n:\n                total, k = total + k, k + 1\n            return total + base\n        else:\n            while k <= n:\n                total, k = total + (k**2), k + 1\n            return total + base\n    else:\n        total, k = 1, 1\n        if term == identity:\n            while k <= n:\n                total, k = total * k, k + 1\n            return total * base\n        else:\n            while k <= n:\n                total, k = total * (k*k), k + 1\n            return total * base\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":20,"diff":"\r\nInputObject                                            SideIndicator\r\n-----------                                            -------------\r\n        accumulation = combiner(accumulation, term(k)) =>           \r\n        combiner(accumulation, term(k))                <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    accumulation, k = base, 1\n    while k <= n:\n        combiner(accumulation, term(k))\n        k += 1\n    return accumulation\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    accumulation, k = base, 1\n    while k <= n:\n        accumulation = combiner(accumulation, term(k))\n        k += 1\n    return accumulation\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-accumulation), SingleChild(ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":21,"diff":"\r\nInputObject                                                                                                   SideIndicator\r\n-----------                                                                                                   -------------\r\n    if n == 0:                                                                                                =>           \r\n        new_base = term(n)                                                                                    =>           \r\n    return combiner(accumulate(combiner, new_base, n-1, term), base)                                          =>           \r\n    return accumulate(combiner, base, n, term) if pred(n) else filtered_accumulate(combiner, base, n-1, term) =>           \r\n        new_base = term(n)                                                                                    =>           \r\n        return combiner(accumulate(combiner, new_base, n-1, term), base)                                      =>           \r\n'''                                                                                                           =>           \r\n    def next_pong(i, j, next):                                                                                =>           \r\n        if i == n:                                                                                            =>           \r\n            return 0                                                                                          =>           \r\n    def switch_ping():                                                                                        =>           \r\n        return 0                                                                                              =>           \r\n        return 0                                                                                              =>           \r\n    if n == 1:                                                                                                =>           \r\n        print(start, end)                                                                                     =>           \r\n    else:                                                                                                     =>           \r\n        return 0                                                                                              =>           \r\n    i = 1                                                                                                     <=           \r\n    if i == n:                                                                                                <=           \r\n        new_base = term(i)                                                                                    <=           \r\n    return combiner(accumulate(combiner, new_base, i + 1, term), base)                                        <=           \r\n    return accumulate(combiner, base, n if pred(n) else 0, term)                                              <=           \r\n        x = term(n)                                                                                           <=           \r\n    return combiner(base, accumulate(combiner, x, n-1, term))'''                                              <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    '''iteratively\n    total, i = base, 1\n    while i <= n:\n        total, i = combiner(total, term(i)), i + 1\n    return total'''\n    i = 1\n    if i == n:\n        return base\n    else:\n        new_base = term(i)\n    return combiner(accumulate(combiner, new_base, i + 1, term), base)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    '''iteratively\n    total, i = base, 1\n    while i <= n:\n        total, i = combiner(total, term(i)), i + 1\n    return total'''\n    if n == 0:\n        return base\n    else:\n        new_base = term(n)\n    return combiner(accumulate(combiner, new_base, n-1, term), base)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate","    return combiner(accumulate(combiner, new_base, i + 1, term), base)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate","    return combiner(accumulate(combiner, new_base, i + 1, term), base)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate","    return combiner(accumulate(combiner, new_base, i + 1, term), base)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate","    return combiner(accumulate(combiner, new_base, i + 1, term), base)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate","    return combiner(accumulate(combiner, new_base, i + 1, term), base)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate","    return combiner(accumulate(combiner, new_base, i + 1, term), base)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 79, in accumulate","    if i == n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":22,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    i, total = 1, base                   =>           \r\n        total = combiner(term(i), total) =>           \r\n    i, total = 1, 1                      <=           \r\n        total = combiner(term(i)) + base <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i, total = 1, 1\n    while i <= n:\n        total = combiner(term(i)) + base\n        i += 1\n    return total \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i, total = 1, base\n    while i <= n:\n        total = combiner(term(i), total)\n        i += 1\n    return total \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 2), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    total = combiner(term(i)) + base","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":23,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, k = base, 1 =>           \r\n    total, k = 0, 1    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":88,"diff":"\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n    x = base =>           \r\n    x = 0    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = 0\n    for i in range (1, n+1):\n        x = combiner(x, term(i))\n    return x\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = base\n    for i in range (1, n+1):\n        x = combiner(x, term(i))\n    return x\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":106,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        total = base =>           \r\n        total = 1    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    if combiner ==add:\n        total = base\n        while i <= n:\n            x = combiner(total,term(i))\n            total = x\n            i+=1\n    else:\n        total = 1\n        while i <= n:\n            x = combiner(total,term(i))\n            total = x\n            i+=1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    if combiner ==add:\n        total = base\n        while i <= n:\n            x = combiner(total,term(i))\n            total = x\n            i+=1\n    else:\n        total = base\n        while i <= n:\n            x = combiner(total,term(i))\n            total = x\n            i+=1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","36","","# Error: expected","#     72","# but got","#     36","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":136,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, k = base, 1 =>           \r\n    total, k = 0, 1    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = 0, 1\n    while k <= n:\n        total = combiner(term (k), total)\n        k += 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = base, 1\n    while k <= n:\n        total = combiner(term (k), total)\n        k += 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":145,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return 0    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return 0\n    else: \n        return combiner(term(n), accumulate(combiner, base, n-1, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else: \n        return combiner(term(n), accumulate(combiner, base, n-1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":151,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    total = base =>           \r\n    total = 1    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total \n   ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = base\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total \n   ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":169,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    k, total = 1, base =>           \r\n    k, total = 1, 0    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k, total = 1, 0\n    while k<=n:\n        total, k = combiner(total, term(k)), k+1\n    return total\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k, total = 1, base\n    while k<=n:\n        total, k = combiner(total, term(k)), k+1\n    return total\n\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":240,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return 0    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner((accumulate(combiner, base, n-1, term)), term(n))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner((accumulate(combiner, base, n-1, term)), term(n))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","0","","# Error: expected","#     11","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":24,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n    if n == 0:      =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        total = combiner(base, term(n))\n        return accumulate(combiner, total, n-1, term)\n    #def combiner(x, y): # 2 ARGUMENT FUNCTION- WHAT ARE THE TWO ARGUMENTS?\n        #if add(x, y):\n            #return x + y\n        #elif mul(x, y):\n            #return x * y\n    #combiner(1, 2)\n    # mul(1, 2)\n    # add(1, 2)\n\n    #def total_comb(a, total):\n    #    if combiner == add:\n    #        if n == 0:\n    #            return base\n    #        if a == n:\n    #            val = combiner(total, base)\n    #            return val - 1\n    #        else:\n    #            return total_comb(a+1, combiner(total, term(a+1)))\n    #    if n == 0:\n    #        return base\n    #    if a == n:\n    #        return combiner(total, base)\n    #    else:\n    #        return total_comb(a+1, combiner(total, term(a+1)))\n    #return total_comb(0, 1)\n# FIND OUT THE BUGS\n\n# need to find out a way so that your total for add is returned -1 since\n# right now, if the function were add, the final return would have be 1 added\n# to the right answer\n\n# is there an easier way? to do this without having to write so many lines of code\n# is there an easier way to do the recursion\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        total = combiner(base, term(n))\n        return accumulate(combiner, total, n-1, term)\n    #def combiner(x, y): # 2 ARGUMENT FUNCTION- WHAT ARE THE TWO ARGUMENTS?\n        #if add(x, y):\n            #return x + y\n        #elif mul(x, y):\n            #return x * y\n    #combiner(1, 2)\n    # mul(1, 2)\n    # add(1, 2)\n\n    #def total_comb(a, total):\n    #    if combiner == add:\n    #        if n == 0:\n    #            return base\n    #        if a == n:\n    #            val = combiner(total, base)\n    #            return val - 1\n    #        else:\n    #            return total_comb(a+1, combiner(total, term(a+1)))\n    #    if n == 0:\n    #        return base\n    #    if a == n:\n    #        return combiner(total, base)\n    #    else:\n    #        return total_comb(a+1, combiner(total, term(a+1)))\n    #return total_comb(0, 1)\n# FIND OUT THE BUGS\n\n# need to find out a way so that your total for add is returned -1 since\n# right now, if the function were add, the final return would have be 1 added\n# to the right answer\n\n# is there an easier way? to do this without having to write so many lines of code\n# is there an easier way to do the recursion\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\"))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate","    return accumulate(combiner, total, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate","    return accumulate(combiner, total, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate","    return accumulate(combiner, total, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate","    return accumulate(combiner, total, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate","    return accumulate(combiner, total, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in accumulate","    return accumulate(combiner, total, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":128,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1: \n        return combiner(base, term(n)) \n    else: \n        return combiner((accumulate(combiner, base, n - 1, term)),term(n))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1: \n        return combiner(base, term(n)) \n    else: \n        return combiner((accumulate(combiner, base, n - 1, term)),term(n))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(LeafWildcard(\"SuiteStatementNode\"))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner((accumulate(combiner, base, n - 1, term)),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner((accumulate(combiner, base, n - 1, term)),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner((accumulate(combiner, base, n - 1, term)),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner((accumulate(combiner, base, n - 1, term)),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner((accumulate(combiner, base, n - 1, term)),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner((accumulate(combiner, base, n - 1, term)),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":477,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(base, term(1))\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(1))\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\"))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 67, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":517,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n==0:        =>           \r\n        return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulate_helper(x,newterm,k):\n        if k==n:\n            return newterm(x)\n        return combiner(newterm(k),accumulate_helper(x,newterm,k+1))\n    return combiner(base,accumulate_helper(n,term,1))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    def accumulate_helper(x,newterm,k):\n        if k==n:\n            return newterm(x)\n        return combiner(newterm(k),accumulate_helper(x,newterm,k+1))\n    return combiner(base,accumulate_helper(n,term,1))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\"))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper","    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper","    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper","    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper","    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper","    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate_helper","    return combiner(newterm(k),accumulate_helper(x,newterm,k+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate_helper","    if k==n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":521,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner, base, n-1, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner, base, n-1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\"))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 67, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":610,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #\n    # if n == 1 and base == 1:\n    #     return 1\n    # # if combiner == mul:\n    # #     return product(n, term) + base\n    # else:\n    #     a = combiner(base, term(n))\n    #\n\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #\n    # if n == 1 and base == 1:\n    #     return 1\n    # # if combiner == mul:\n    # #     return product(n, term) + base\n    # else:\n    #     a = combiner(base, term(n))\n    #\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(LeafWildcard(\"SuiteStatementNode\"))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":25,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        if i > n:                         =>           \r\n            return base                   =>           \r\n        if i == n:                        <=           \r\n            return combiner(base,term(i)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def help(base,i):\n        if i == n:\n            return combiner(base,term(i))\n        else:\n            return help(combiner(base,term(i)),i + 1)\n    return help(base,1)\n\n        \n\n    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def help(base,i):\n        if i > n:\n            return base\n        else:\n            return help(combiner(base,term(i)),i + 1)\n    return help(base,1)\n\n        \n\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help","    return help(combiner(base,term(i)),i + 1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help","    return help(combiner(base,term(i)),i + 1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help","    return help(combiner(base,term(i)),i + 1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help","    return help(combiner(base,term(i)),i + 1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help","    return help(combiner(base,term(i)),i + 1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in help","    return help(combiner(base,term(i)),i + 1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in help","    if i == n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":26,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    total, i = base, 1           =>           \r\n    return total                 =>           \r\n                                 =>           \r\n    total, i = 0, 1              <=           \r\n    return combiner(base, total) <=           \r\n                                 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, i = 0, 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return combiner(base, total)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, i = base, 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":497,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    total=base                  =>           \r\n    return total                =>           \r\n    total=0                     <=           \r\n    return combiner(base,total) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=0\n    while n>0:\n        total=combiner(total,term(n))\n        n-=1\n    return combiner(base,total)\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=base\n    while n>0:\n        total=combiner(total,term(n))\n        n-=1\n    return total\n    \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(LeafWildcard(\"AssignmentStatementNode\"), TChildren(Node(WhileStatementNode, TChildren(LeafWildcard(\"BinaryExpressionNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(LeafWildcard(\"AugmentedAssignStatementNode\"))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(LeafWildcard(\"AssignmentStatementNode\"), TChildren(Node(WhileStatementNode, TChildren(LeafWildcard(\"BinaryExpressionNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(LeafWildcard(\"AugmentedAssignStatementNode\"))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":555,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, k = base, 1 =>           \r\n    return total       =>           \r\n    total, k = 0, 1    <=           \r\n    return c(b, total) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    b = base\n    c = combiner\n    total, k = 0, 1\n    while k <= n:\n        total, k = c(total, term(k)), k + 1\n    return c(b, total)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    b = base\n    c = combiner\n    total, k = base, 1\n    while k <= n:\n        total, k = c(total, term(k)), k + 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":29,"diff":"\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n    if combiner == add:              =>           \r\n        return base + combined_terms =>           \r\n        return base * combined_terms =>           \r\n    else:                            =>           \r\n    return base + combined_terms     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    if combiner == add:\n        combined_terms = 0 \n    else:\n        combined_terms = 1\n    while count < (n+1):\n        combined_terms = combiner(combined_terms, term(count))\n        count += 1\n    return base + combined_terms\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    if combiner == add:\n        combined_terms = 0 \n    else:\n        combined_terms = 1\n    while count < (n+1):\n        combined_terms = combiner(combined_terms, term(count))\n        count += 1\n    if combiner == add:\n        return base + combined_terms\n    else:\n        return base * combined_terms\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-combiner), SingleChild(LeafConstNode(NameExpressionNode-add)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0)))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-base), SingleChild(LeafConstNode(NameExpressionNode-combined_terms))))))))))), 5), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":30,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        return combiner(base, 0) =>           \r\n        return 0                 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return combiner(1, base)\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return combiner(base, 0)\n    if n == 1:\n        return combiner(1, base)\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","0","","# Error: expected","#     11","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":31,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total = 1          =>           \r\n    total = base       =>           \r\n    total = term(1)    <=           \r\n    total = term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    count = 1\n    total = term(base)\n    while count <= n:\n        total = combiner(total, term(count))\n        count = count + 1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    count = 1\n    total = base\n    while count <= n:\n        total = combiner(total, term(count))\n        count = count + 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Skip(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":231,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total = base       =>           \r\n    total = term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = term(base)\n    for i in range(1, n+1):\n        total = combiner(total, term(i))\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        total = combiner(total, term(i))\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Skip(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":232,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total = base       =>           \r\n    total = term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = term(base)\n    for i in range(1, n+1):\n        total = combiner(total, term(i))\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        total = combiner(total, term(i))\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Skip(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":303,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        total = base       =>           \r\n        total = term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    initial = 0\n    if base > n:\n\t    initial = 0\n\t    total = base\n    else:\n\t    total = term(base)\n    for i in range(initial, n):\n\t    total = combiner(total, term(i+1))\n    return total","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    initial = 0\n    if base > n:\n\t    initial = 0\n\t    total = base\n    else:\n\t    total = base\n    for i in range(initial, n):\n\t    total = combiner(total, term(i+1))\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Skip(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","144","","# Error: expected","#     72","# but got","#     144","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":328,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total = base       =>           \r\n    total = term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = term(base)\n\n    for i in range(n):\n        total = combiner(total, term(increment(i)))\n    return total\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n\n    for i in range(n):\n        total = combiner(total, term(increment(i)))\n    return total\n    \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Skip(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":581,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    k=base       =>           \r\n    k=term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k=term(base)\n    for i in range(1,n+1):\n        k=combiner(k,term(i))\n    return k\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k=base\n    for i in range(1,n+1):\n        k=combiner(k,term(i))\n    return k\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Skip(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":32,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    k = 1                        =>           \r\n    return combiner(total, base) =>           \r\n    k = base                     <=           \r\n    return total                 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = base\n    if combiner == mul:\n        total = 1\n    else:\n        total = 0\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return total","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    if combiner == mul:\n        total = 1\n    else:\n        total = 0\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return combiner(total, base)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     26","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":33,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n            return base                     =>           \r\n            base = combiner(base, term(n))  =>           \r\n    if combiner==mul:                       <=           \r\n        total=1                             <=           \r\n        total=0                             <=           \r\n            return total                    <=           \r\n            total = combiner(base, term(n)) <=           \r\n    else:                                   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner==mul:\n        total=1\n    else:\n        total=0\n    def partial_total(combiner, base, n, term):\n        if n==0:\n            return total\n        else:\n            total = combiner(base, term(n))\n            return partial_total(combiner, base, n-1, term)\n    return partial_total(combiner, base, n, term)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def partial_total(combiner, base, n, term):\n        if n==0:\n            return base\n        else:\n            base = combiner(base, term(n))\n            return partial_total(combiner, base, n-1, term)\n    return partial_total(combiner, base, n, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(FunctionDefinitionNode-partial_total, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChildren(Node(FunctionDefinitionNode-partial_total, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in accumulate","    return partial_total(combiner, base, n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in partial_total","    return partial_total(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in partial_total","    return partial_total(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in partial_total","    return partial_total(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in partial_total","    return partial_total(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in partial_total","    return partial_total(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in partial_total","    return total","UnboundLocalError: local variable 'total' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":34,"diff":"\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n        total, k = combiner(total, term(k)), k + 1  =>           \r\n    return total                                    =>           \r\n        total, k = combiner (total, term(k)), k + 1 <=           \r\n    return combiner(total)                          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"if combiner == add or combiner == sub:\n        total, k = base, 1\n        while k <= n:\n            total, k = combiner (total, term(k)), k + 1\n        return combiner(total, base)\n    else:\n        total, k = 1, 1\n        while k <= n:\n            total, k = combiner (total, term(k)), k + 1\n        return combiner(total, base)\"\"\"\n\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner (total, term(k)), k + 1\n    return combiner(total)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"if combiner == add or combiner == sub:\n        total, k = base, 1\n        while k <= n:\n            total, k = combiner (total, term(k)), k + 1\n        return combiner(total, base)\n    else:\n        total, k = 1, 1\n        while k <= n:\n            total, k = combiner (total, term(k)), k + 1\n        return combiner(total, base)\"\"\"\n\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 85, in accumulate","    return combiner(total)","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":37,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        return base              =>           \r\n        return combiner(base, n) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return combiner(base, n)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":55,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        return base                      =>           \r\n        return combiner(base, term(n+1)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return combiner(base, term(n+1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":59,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return term(base)\n    else:\n        return (combiner(term(n),accumulate(combiner,base,n-1,term)))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        return (combiner(term(n),accumulate(combiner,base,n-1,term)))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":113,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    return total           =>           \r\n    return combiner(total) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    total = base\n    x = 1\n    while x <= n:\n        if combiner == mul:\n            total = mul(total, term(x))\n            x += 1\n        if combiner == add:\n            total = add(total, term(x))\n            x += 1\n    return combiner(total)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    total = base\n    x = 1\n    while x <= n:\n        if combiner == mul:\n            total = mul(total, term(x))\n            x += 1\n        if combiner == add:\n            total = add(total, term(x))\n            x += 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 79, in accumulate","    return combiner(total)","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":272,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n\t\"\"\"Return the result of combining the first N terms in a sequence.\tThe\n\tterms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n\ttwo-argument function.\tTreating COMBINER as if it were a binary operator,\n\tthe return value is\n\t\tBASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n\t>>> accumulate(add, 0, 5, identity)\t # 0 + 1 + 2 + 3 + 4 + 5\n\t15\n\t>>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n\t26\n\t>>> accumulate(add, 11, 0, identity) # 11\n\t11\n\t>>> accumulate(add, 11, 3, square)\t # 11 + 1^2 + 2^2 + 3^2\n\t25\n\t>>> accumulate(mul, 2, 3, square)\t# 2 * 1^2 * 2^2 * 3^2\n\t72\n\t\"\"\"\n\tif n == 0:\n\t\treturn term(base)\n\telse:\n\t\treturn combiner(term(n), accumulate(combiner, base, n-1, term))\n\t","after":"def accumulate(combiner, base, n, term):\n\t\"\"\"Return the result of combining the first N terms in a sequence.\tThe\n\tterms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n\ttwo-argument function.\tTreating COMBINER as if it were a binary operator,\n\tthe return value is\n\t\tBASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n\t>>> accumulate(add, 0, 5, identity)\t # 0 + 1 + 2 + 3 + 4 + 5\n\t15\n\t>>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n\t26\n\t>>> accumulate(add, 11, 0, identity) # 11\n\t11\n\t>>> accumulate(add, 11, 3, square)\t # 11 + 1^2 + 2^2 + 3^2\n\t25\n\t>>> accumulate(mul, 2, 3, square)\t# 2 * 1^2 * 2^2 * 3^2\n\t72\n\t\"\"\"\n\tif n == 0:\n\t\treturn base\n\telse:\n\t\treturn combiner(term(n), accumulate(combiner, base, n-1, term))\n\t","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)\t # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)\t # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":273,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return term(base)\n    return combiner(term(n),accumulate(combiner, base, n-1, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    return combiner(term(n),accumulate(combiner, base, n-1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":332,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return base                    =>           \r\n        return combiner(base, term(0)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return combiner(base, term(0))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":346,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return term(base)\n\n    else:\n        return combiner(term(n), accumulate(combiner, base, (n-1), term))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n\n    else:\n        return combiner(term(n), accumulate(combiner, base, (n-1), term))\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":352,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return term(base)\n    else:\n        return combiner(term(n), accumulate(combiner,base,n-1,term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner,base,n-1,term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":356,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    return total                 =>           \r\n    return combiner(base, total) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"The NEXT_TERM function was inspired from the use of product function \n    and after is the body of the accumulate funciton\"\"\" \n    i, total = 0, base \n\n    if n == 0: \n        return total \n    \n    while n > 0: \n        total = combiner(term(n), total)\n        i += 1 \n        n -= 1\n    return combiner(base, total)\n        ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"The NEXT_TERM function was inspired from the use of product function \n    and after is the body of the accumulate funciton\"\"\" \n    i, total = 0, base \n\n    if n == 0: \n        return total \n    \n    while n > 0: \n        total = combiner(term(n), total)\n        i += 1 \n        n -= 1\n    return total \n        ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","37","","# Error: expected","#     26","# but got","#     37","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":548,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return base                    =>           \r\n        return combiner(base, term(n)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":552,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return term(base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":561,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return term(base)\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":591,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return base                    =>           \r\n        return combiner(base, term(n)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":606,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        return base       =>           \r\n        return term(base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return term(base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":35,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n        return combiner(base,term(1)) =>           \r\n        return combiner(base,term(0)) =>           \r\n        return base + term(1)         <=           \r\n        return base + term(0)         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return base + term(1)\n    elif n == 0:\n        return base + term(0)\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return combiner(base,term(1))\n    elif n == 0:\n        return combiner(base,term(0))\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":36,"diff":"\r\nInputObject                                                          SideIndicator\r\n-----------                                                          -------------\r\n    counter = 1                                                      =>           \r\n    if combiner == mul:                                              =>           \r\n    while counter <= n:                                              =>           \r\n        total, counter = combiner(total, term(counter)), counter + 1 =>           \r\n    x = 1                                                            <=           \r\n    if x == mul:                                                     <=           \r\n    while x <= n:                                                    <=           \r\n        total, x = combiner(total, term(x)), x + 1                   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = 1\n    if x == mul:\n        total = 1\n    else:\n        total = 0\n    while x <= n:\n        total, x = combiner(total, term(x)), x + 1\n    return combiner(base, total)\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    if combiner == mul:\n        total = 1\n    else:\n        total = 0\n    while counter <= n:\n        total, counter = combiner(total, term(counter)), counter + 1\n    return combiner(base, total)\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-counter)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-counter)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-counter)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-counter)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-counter)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":38,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    if n==0:                             =>           \r\n        return combiner(base,term(n))    =>           \r\n    elif n==1:                           =>           \r\n        return combiner(base,term(n))    =>           \r\n    if n==1:                             <=           \r\n        return term(n)                   <=           \r\n     # elif n==1:                        <=           \r\n     #     return combiner(base,term(n)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==1:\n        return term(n)\n     # elif n==1:\n     #     return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return combiner(base,term(n))\n    elif n==1:\n        return combiner(base,term(n))\n    return combiner(term(n),accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))))))))))))))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":39,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    def iter_accumulate(x):             =>           \r\n    return iter_accumulate(1)           =>           \r\n    def iter_accumulate(x,increment):   <=           \r\n    return iter_accumulate(1,increment) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def iter_accumulate(x,increment):\n        if x > n:\n            return base\n        return combiner(term(x),iter_accumulate(increment(x)))\n    return iter_accumulate(1,increment)","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def iter_accumulate(x):\n        if x > n:\n            return base\n        return combiner(term(x),iter_accumulate(increment(x)))\n    return iter_accumulate(1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(FunctionDefinitionNode-iter_accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(Target(LeafWildcard(\"ParameterNode\")), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(FunctionDefinitionNode-iter_accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return iter_accumulate(1,increment)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in iter_accumulate","    return combiner(term(x),iter_accumulate(increment(x)))","TypeError: iter_accumulate() missing 1 required positional argument: 'increment'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":42,"diff":"\r\nInputObject                    SideIndicator\r\n-----------                    -------------\r\n    i, total = 1, base         =>           \r\n    index, total = 1, base     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    index, total = 1, base    \n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i, total = 1, base    \n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    while i <= n:","UnboundLocalError: local variable 'i' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":70,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        base = combiner(base, term(i)) =>           \r\n        base = combiner(base, term(n)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # y = term(n)\n    # x = n\n    # total = 0 \n    # if base == 0:\n    #     y = 0\n    #     while x > 0:\n    #         temp = combiner(y, term(x)) \n    #         total = total + temp\n    #         x -= 1\n    #     return total \n    # else:\n    #     while x > 0:\n    #         temp = combiner(base, term(x))\n    #         total = total + temp\n    #         x -= 1\n    #     return total \n    i = 1\n    while i <= n:\n        base = combiner(base, term(n))\n        i += 1\n    return base \n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # y = term(n)\n    # x = n\n    # total = 0 \n    # if base == 0:\n    #     y = 0\n    #     while x > 0:\n    #         temp = combiner(y, term(x)) \n    #         total = total + temp\n    #         x -= 1\n    #     return total \n    # else:\n    #     while x > 0:\n    #         temp = combiner(base, term(x))\n    #         total = total + temp\n    #         x -= 1\n    #     return total \n    i = 1\n    while i <= n:\n        base = combiner(base, term(i))\n        i += 1\n    return base \n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":95,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n        total=combiner(total,term(i)) =>           \r\n        total=combiner(total,term(n)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=base\n    i=0\n    while i<n:\n        i+=1\n        total=combiner(total,term(n))\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=base\n    i=0\n    while i<n:\n        i+=1\n        total=combiner(total,term(i))\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":289,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        answer = combiner(answer,term(i)) =>           \r\n        answer = combiner(answer,term(n)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    answer = base\n    for i in range(1,n+1):\n        answer = combiner(answer,term(n))\n    return answer\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    answer = base\n    for i in range(1,n+1):\n        answer = combiner(answer,term(i))\n    return answer\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":337,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    i = 1   =>           \r\n    x = 1   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result = base\n    x = 1\n\n    while i<=n:\n        result = combiner(result,term(i))\n        i += 1\n\n    return result\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result = base\n    i = 1\n\n    while i<=n:\n        result = combiner(result,term(i))\n        i += 1\n\n    return result\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    while i<=n:","UnboundLocalError: local variable 'i' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":500,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        x = y(x, term(i)) =>           \r\n        x = y(x, term(n)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    for i in range(1, n + 1):\n        y = combiner\n        x = y(x, term(n))\n    return x\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    for i in range(1, n + 1):\n        y = combiner\n        x = y(x, term(i))\n    return x\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":607,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n        ans = combiner(ans, term(i)); =>           \r\n        ans = combiner(ans, term(n)); <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # end = base;\n    # while (n >= 0):\n    #     if (n == 0):\n    #         return end;\n    #     else:\n    #         end = combiner(end, term(n));\n    #         n -= 1;\n    # return end;\n    ans = base;\n    for i in range(1, n+1):\n        ans = combiner(ans, term(n));\n    return ans;\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # end = base;\n    # while (n >= 0):\n    #     if (n == 0):\n    #         return end;\n    #     else:\n    #         end = combiner(end, term(n));\n    #         n -= 1;\n    # return end;\n    ans = base;\n    for i in range(1, n+1):\n        ans = combiner(ans, term(i));\n    return ans;\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":43,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(base, term(n)) =>           \r\n        return term(n)                 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n<=1:\n        return term(n)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n<=1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":44,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n        total, k = combiner(term(k), total), k + 1 =>           \r\n        total, k = combiner(term(k), k), k + 1     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(term(k), k), k + 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(term(k), total), k + 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":141,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(k)) =>           \r\n        total = combiner(base, term(k))  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k <=n:\n        total = combiner(base, term(k))\n        k+= 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k <=n:\n        total = combiner(total, term(k))\n        k+= 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":178,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total = combiner(c, term(i))     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i =1\n    while i<=n:\n        total = combiner(c, term(i))\n        i=i+1\n    return total \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i =1\n    while i<=n:\n        total = combiner(total, term(i))\n        i=i+1\n    return total \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    total = combiner(c, term(i))","NameError: name 'c' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":180,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n            total = combiner(total, term(k)) =>           \r\n            total = combiner(base, term(k))  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k <= n:\n        if n == 0:\n            return base\n        else:\n            total = combiner(base, term(k))\n            k = k + 1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k <= n:\n        if n == 0:\n            return base\n        else:\n            total = combiner(total, term(k))\n            k = k + 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":361,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    return total    =>           \r\n    return combiner <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x=1\n    total = base\n    if n==0:\n        return combiner(base, term(0))\n    while x!=n+1:\n        total = combiner(total, term(x))\n        x=x+1\n    return combiner\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x=1\n    total = base\n    if n==0:\n        return combiner(base, term(0))\n    while x!=n+1:\n        total = combiner(total, term(x))\n        x=x+1\n    return total\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","<built-in function add>","","# Error: expected","#     15","# but got","#     <built-in function add>","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":383,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n        total = combiner (total, k) =>           \r\n        total = combiner (base, k)  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1    \n    while counter <= n:\n        k = term (counter)\n        total = combiner (base, k)\n        counter = counter + 1\n    return total \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1    \n    while counter <= n:\n        k = term (counter)\n        total = combiner (total, k)\n        counter = counter + 1\n    return total \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":45,"diff":"\r\nInputObject                                                                         SideIndicator\r\n-----------                                                                         -------------\r\n    k = 1                                                                           =>           \r\n    total = base                                                                    =>           \r\n    while k <= n:                                                                   =>           \r\n        total = combiner(total, term(k))                                            =>           \r\n        k += 1                                                                      =>           \r\n    return total                                                                    =>           \r\n    if n == 0:                                                                      <=           \r\n        return base                                                                 <=           \r\n    if n == 1:                                                                      <=           \r\n        return combiner(base, term(n))                                              <=           \r\n    return combiner(base, combiner(term(n), accumulate(combiner, base, n-1, term))) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(n))\n    return combiner(base, combiner(term(n), accumulate(combiner, base, n-1, term)))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 1\n    total = base\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), 0), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(NameExpressionNode-n))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(NameExpressionNode-n)))), SingleChild(ConstNode(SuiteStatementNode, Children(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)))), SingleChild(ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))), Selected(\\x => Match(x, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), 0), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))), InOrderSort(ast))))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","70","","# Error: expected","#     26","# but got","#     70","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":46,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumalate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0 or n == 1:\n        return combiner(base, term(n)) \n    else:\n        return combiner(term(n), accumalate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0 or n == 1:\n        return combiner(base, term(n)) \n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-accumulate)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(LeafWildcard(\"ArgNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumalate(combiner, base, n-1, term))","NameError: name 'accumalate' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":550,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return accumulate(combiner, combiner(base, term(n)), n-1, term) =>           \r\n        return accumualte(combiner, combiner(base, term(n)), n-1, term) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumualte(combiner, combiner(base, term(n)), n-1, term)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-accumulate)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(LeafWildcard(\"ArgNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return accumualte(combiner, combiner(base, term(n)), n-1, term)","NameError: name 'accumualte' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":568,"diff":"\r\nInputObject                                             SideIndicator\r\n-----------                                             -------------\r\n        return accumulate(combiner, base, n - 1, term)  =>           \r\n        return accumulator(combiner, base, n - 1, term) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n#def accumulator(combiner, base, n, term):\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        base = combiner(base, term(n))\n        return accumulator(combiner, base, n - 1, term)\n\n#    return accumulator(combiner, base, n, term)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n#def accumulator(combiner, base, n, term):\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        base = combiner(base, term(n))\n        return accumulate(combiner, base, n - 1, term)\n\n#    return accumulator(combiner, base, n, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-accumulate)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(LeafWildcard(\"ArgNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return accumulator(combiner, base, n - 1, term)","NameError: name 'accumulator' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":48,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n        if combiner == mul: =>           \r\n        if term == mul:     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        if term == mul:\n            return combiner(base, term(n + 1))\n        return combiner(base, term(n))\n    else:\n        base = combiner(base, term(n))\n        return accumulate(combiner, base, n - 1, term)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        if combiner == mul:\n            return combiner(base, term(n + 1))\n        return combiner(base, term(n))\n    else:\n        base = combiner(base, term(n))\n        return accumulate(combiner, base, n - 1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":63,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumulate(add, base, n-1, term))      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    if n == 0:\n        return base\n    if n > 0:\n        return combiner(term(n), accumulate(add, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    if n == 0:\n        return base\n    if n > 0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","63","","# Error: expected","#     72","# but got","#     63","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":144,"diff":"\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n        return combiner( term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return cominer( term(n), accumulate(combiner, base, n-1, term))  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return cominer( term(n), accumulate(combiner, base, n-1, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner( term(n), accumulate(combiner, base, n-1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return cominer( term(n), accumulate(combiner, base, n-1, term))","NameError: name 'cominer' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":366,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        result = combiner(result,term(k)) =>           \r\n        result = combine(result,term(k))  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 1\n    result = base\n    while k<=n:\n        result = combine(result,term(k))\n        k += 1\n    return result\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 1\n    result = base\n    while k<=n:\n        result = combiner(result,term(k))\n        k += 1\n    return result\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    result = combine(result,term(k))","NameError: name 'combine' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":474,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n        return combine(accumulate(combiner, base, n-1, term), term(n))  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #def producer(i):\n        #if base == n: \n            #return combiner(base, base)\n        #if i == n:\n            #return combiner(term(i), base)\n    if n == 0:\n        return base\n    else:\n        return combine(accumulate(combiner, base, n-1, term), term(n))\n\n        #return combiner(term(i), producer(i+1))\n    #return producer(1)","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #def producer(i):\n        #if base == n: \n            #return combiner(base, base)\n        #if i == n:\n            #return combiner(term(i), base)\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\n        #return combiner(term(i), producer(i+1))\n    #return producer(1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate","    return combine(accumulate(combiner, base, n-1, term), term(n))","NameError: name 'combine' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":599,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        total = combiner(total, term(count))  =>           \r\n        total = combinder(total, term(count)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    total = base\n    while count <= n:\n        total = combinder(total, term(count))\n        count += 1\n\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    total = base\n    while count <= n:\n        total = combiner(total, term(count))\n        count += 1\n\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    total = combinder(total, term(count))","NameError: name 'combinder' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":49,"diff":"\r\nInputObject                        SideIndicator\r\n-----------                        -------------\r\n    for i in range(1, n+1):        =>           \r\n    base = combiner(base, term(1)) <=           \r\n    for i in range(2, n+1):        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    base = combiner(base, term(1))\n    for i in range(2, n+1):\n        base = combiner(base, term(i))\n    return base;\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    for i in range(1, n+1):\n        base = combiner(base, term(i))\n    return base;\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":50,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n==0:        =>           \r\n        return base =>           \r\n    elif n==1:      =>           \r\n    if n==1:        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==1:\n        return combiner(base,term(1))\n    return combiner(term(n),accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base,term(1))\n    return combiner(term(n),accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), 0), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"IfStatementNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n),accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    if n==1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":83,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n==0:        =>           \r\n        return base =>           \r\n    elif n==1:      =>           \r\n    if n==1:        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), 0), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"IfStatementNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    if n==1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":137,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n == 1:      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base,term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), 0), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"IfStatementNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":164,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n == 1:      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    if n == 1:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), 0), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"IfStatementNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":201,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n                    =>           \r\n    if n == 1:      <=           \r\n                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n        ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), 0), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"IfStatementNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":210,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n == 1:      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), 0), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"IfStatementNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":353,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n == 0:      =>           \r\n    if n == 1:      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1: \n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1: \n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), 0), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"IfStatementNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":400,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n == 1:      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n    \treturn combiner(base, term(n))\n    else:\n    \treturn combiner(term(n), accumulate(combiner, base, n-1, term)) \n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    elif n == 1:\n    \treturn combiner(base, term(n))\n    else:\n    \treturn combiner(term(n), accumulate(combiner, base, n-1, term)) \n    \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), 0), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"IfStatementNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":51,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n            return 0 =>           \r\n            return 1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def times(x):\n        if n==0:\n            return 1\n        if x==n:\n            return term(n)\n        else:\n            return combiner(term(x),times(increment(x)))\n    return combiner(base,times(1))\n    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def times(x):\n        if n==0:\n            return 0\n        if x==n:\n            return term(n)\n        else:\n            return combiner(term(x),times(increment(x)))\n    return combiner(base,times(1))\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":90,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":97,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"if combiner == mul:\n        return base * product(n, term)\n    elif combiner == add:\n        return base + summation(n, term)\"\"\"\n    if n == 1:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"if combiner == mul:\n        return base * product(n, term)\n    elif combiner == add:\n        return base + summation(n, term)\"\"\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":131,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":190,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":243,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n        if n == 0:            =>           \r\n    return counter(n)         =>           \r\n        if n == 1:            <=           \r\n    return counter(n)         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def counter(n):\n        if n == 1:\n            return base\n        else:\n            return combiner(term(n), counter(n-1))\n    return counter(n)        \n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def counter(n):\n        if n == 0:\n            return base\n        else:\n            return combiner(term(n), counter(n-1))\n    return counter(n)\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":358,"diff":"\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n    if n==0: =>           \r\n    if n==1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":377,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":395,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 0: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":52,"diff":"\r\nInputObject                                              SideIndicator\r\n-----------                                              -------------\r\n                                                         =>           \r\n        total = base                                     =>           \r\n    return helper_product(base, n, term)                 =>           \r\n        total = 0                                        <=           \r\n    return combiner(helper_product(base, n, term), base) <=           \r\n                                                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper_product (base, n, term):\n        total = 0\n        k = 1\n        while k <= n:\n            total = combiner(total, term(k))\n            k = k + 1\n        return total\n    \n    return combiner(helper_product(base, n, term), base)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper_product (base, n, term):\n        \n        total = base\n        k = 1\n        while k <= n:\n            total = combiner(total, term(k))\n            k = k + 1\n        return total\n    \n    return helper_product(base, n, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"CallExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":99,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    return comb(term(1),base)               =>           \r\n    return combiner(base , comb(term(1),1)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n ==0:\n        return base\n    def comb(k,ans):\n        if k == n+1:\n            return ans\n        else:\n            #print(ans)\n            ans = combiner(ans,term(k))\n            \n            return comb(k+1,ans)\n    return combiner(base , comb(term(1),1))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n ==0:\n        return base\n    def comb(k,ans):\n        if k == n+1:\n            return ans\n        else:\n            #print(ans)\n            ans = combiner(ans,term(k))\n            \n            return comb(k+1,ans)\n    return comb(term(1),base)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"CallExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":53,"diff":"\r\nInputObject                                                                         SideIndicator\r\n-----------                                                                         -------------\r\n    result, i = base, 1                                                             =>           \r\n    while i <= n:                                                                   =>           \r\n        result = combiner(result, term(i))                                          =>           \r\n        i += 1                                                                      =>           \r\n    return result                                                                   =>           \r\n    if n == 0:                                                                      <=           \r\n        return 1                                                                    <=           \r\n    return combiner(base, combiner(term(1), accumulate(combiner, base, n-1, term))) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return 1\n    return combiner(base, combiner(term(1), accumulate(combiner, base, n-1, term)))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result, i = base, 1\n    while i <= n:\n        result = combiner(result, term(i))\n        i += 1\n    return result\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-result)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-result), SingleChild(LeafConstNode(NameExpressionNode-i))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-base), SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), 0), 1), Selected(\\x => Match(x, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-result), SingleChild(LeafConstNode(NameExpressionNode-i)))), SingleChild(ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-base), SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0)))))))), Selected(\\x => Match(x, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), 0), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-result)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(NameExpressionNode-n)))), SingleChild(ConstNode(SuiteStatementNode, Children(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-result), SingleChild(ConstNode(CallExpressionNode, Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), 0), Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), 0), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)))))))), SingleChild(ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-result)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-result)))), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))))), InOrderSort(ast)))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","6","","# Error: expected","#     15","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":54,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    elif n == 0:                 =>           \r\n        return combiner(0, base) =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner (1, base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n    return ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner (1, base)\n    elif n == 0:\n        return combiner(0, base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n    return ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-0))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))))))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), TChild(LeafWildcard(\"ReturnStatementNode\")))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":56,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n == 0:                         =>           \r\n        return combiner(base, term(0)) =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 2\n    total = combiner(base, term(1))\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return combiner(base, term(0))\n    k = 2\n    total = combiner(base, term(1))\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n\n\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-0))))))))))))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":58,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n    while n+1 > i: =>           \r\n    while n > i:   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    while n > i:\n        base = combiner(base,term(i))\n        i +=1\n    return base\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    while n+1 > i:\n        base = combiner(base,term(i))\n        i +=1\n    return base\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-GreaterThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":60,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while k < n:  =>           \r\n    while k <= n: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #def more_term(combiner, n, term):\n     #   if n == 0:\n      #      return \n       # return combiner(term(n), more_term(combiner, n-1, term))\n    #return combiner(base, more_term(combiner, n, term)) \n    total = base \n    k = 0\n    while k <= n:\n        k = k + 1\n        total = combiner(total, term(k))\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #def more_term(combiner, n, term):\n     #   if n == 0:\n      #      return \n       # return combiner(term(n), more_term(combiner, n-1, term))\n    #return combiner(base, more_term(combiner, n, term)) \n    total = base \n    k = 0\n    while k < n:\n        k = k + 1\n        total = combiner(total, term(k))\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","21","","# Error: expected","#     15","# but got","#     21","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":61,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if k > 1:  =>           \r\n    if k >= 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = n\n    if k >= 1:\n        return combiner(term(k), accumulate(combiner, base, k - 1, term))\n    else:\n        return combiner(base, term(k))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = n\n    if k > 1:\n        return combiner(term(k), accumulate(combiner, base, k - 1, term))\n    else:\n        return combiner(base, term(k))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":66,"diff":"","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        result = base\n        while n != 0:\n            n -= 1\n            result = combiner(result, term(n))\n        return result\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        result = base\n        while n != 0:\n            result = combiner(result, term(n))\n            n -= 1\n        return result\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":67,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return combiner(accumulate(combiner,term(n),n-1,term),base) =>           \r\n        return combiner(accumulate(combiner,term(n),n-1,term))      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner,term(n),n-1,term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner,term(n),n-1,term),base)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(accumulate(combiner,term(n),n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(accumulate(combiner,term(n),n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(accumulate(combiner,term(n),n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(accumulate(combiner,term(n),n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(accumulate(combiner,term(n),n-1,term))","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":68,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(n, accumulate(combiner, base, n-1, term))       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, n)\n    else:\n        return combiner(n, accumulate(combiner, base, n-1, term))\n\n    # if combiner == add:\n    #     total = 0\n    # else:\n    #     total = 1\n    # if n == 0:\n    #     return combiner(base, 0)\n    # else:\n    #     while n > 0:\n    #         total = combiner(term(n), total)\n    #         n -= 1\n    # return combiner(base, total)\n        ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, n)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n    # if combiner == add:\n    #     total = 0\n    # else:\n    #     total = 1\n    # if n == 0:\n    #     return combiner(base, 0)\n    # else:\n    #     while n > 0:\n    #         total = combiner(term(n), total)\n    #         n -= 1\n    # return combiner(base, total)\n        ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":287,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(n, accumulate(combiner, base, n-1, term))       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(n, accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":294,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, (n-1), term)) =>           \r\n        return combiner(n, accumulate(combiner, base, (n-1), term))       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n<0:\n        return base\n    elif n==0:\n        return base\n    else:\n        return combiner(n, accumulate(combiner, base, (n-1), term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n<0:\n        return base\n    elif n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, (n-1), term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":348,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n                                                                    =>           \r\n        return combiner(n,accumulate(combiner,base,n-1,term))       <=           \r\n                                                                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # i, total = 1,base\n    # while i <= n:\n    #     total = combiner(total,term(i))\n    #     i += 1\n    # return total\n    if n==0:\n        return base\n    else:\n        return combiner(n,accumulate(combiner,base,n-1,term))\n        \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # i, total = 1,base\n    # while i <= n:\n    #     total = combiner(total,term(i))\n    #     i += 1\n    # return total\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":527,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(n, accumulate(combiner, base, n-1, term))       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(n, accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":72,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n==0:                           =>           \r\n    elif n==1:                         =>           \r\n        return combiner(base, term(n)) =>           \r\n    if n==1:                           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return combiner(base, term(n))\n    elif n==1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))))))))))))))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    if n==1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":73,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(term(n), base) =>           \r\n        return term(n) + base          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 1:\n        return term(n) + base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 1:\n        return combiner(term(n), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":216,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return combiner(together(1) , base) =>           \r\n    return together(1) + base           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def together (i):\n        if i < n:\n            return combiner(term(i) , together (i + 1))\n        else:\n            return term(n)\n\n    return together(1) + base\n\n\n    \n   \n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def together (i):\n        if i < n:\n            return combiner(term(i) , together (i + 1))\n        else:\n            return term(n)\n\n    return combiner(together(1) , base)\n\n\n    \n   \n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\"))))), TChild(LeafWildcard(\"NameExpressionNode\")))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\")))), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\")))), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":277,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(term(1), base) =>           \r\n        return term(1) + base          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return term(1) + base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\"))))), TChild(LeafWildcard(\"NameExpressionNode\")))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\")))), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\")))), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":355,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(term(n), base) =>           \r\n        return term(n) + base          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return 0 + base\n    elif n == 1:\n        return term(n) + base\n    else:\n        return combiner( term(n), accumulate(combiner, base, n - 1, term))\n\n    # def counter(k):\n    #     if k == 0:\n    #         return 0\n    #     elif k == 1:\n    #         return term(k)\n    #     elif k > 1:\n    #         return combiner( term(k), counter(k-1) )\n\n    #return combiner( base, counter(n) )\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return 0 + base\n    elif n == 1:\n        return combiner(term(n), base)\n    else:\n        return combiner( term(n), accumulate(combiner, base, n - 1, term))\n\n    # def counter(k):\n    #     if k == 0:\n    #         return 0\n    #     elif k == 1:\n    #         return term(k)\n    #     elif k > 1:\n    #         return combiner( term(k), counter(k-1) )\n\n    #return combiner( base, counter(n) )\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\"))))), TChild(LeafWildcard(\"NameExpressionNode\")))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\")))), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\")))), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":423,"diff":"\r\nInputObject                                             SideIndicator\r\n-----------                                             -------------\r\n    return combiner(times(n, 1 - combiner(1, 0)), base) =>           \r\n    return times(n, 1 - combiner(1, 0)) + base          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    def times(n, total):\n        if n != 0:\n            return times(n - 1, combiner(total, term(n)))\n        else:\n            return total\n    return times(n, 1 - combiner(1, 0)) + base\n\n\n\n\n\n\n\n\n\n    \"\"\"if n <= 1:\n        if term == triple:\n            return total + 2\n        else:\n            return total\n        else:\n            return times(n - 1, combiner(total, term(n)))\n    if n != 0:\n        return combiner(base, times(n, 1))\n    if base == 0 and combiner == mul:\n        return times(n, 1)\n    else:\n        return base\"\"\"\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    def times(n, total):\n        if n != 0:\n            return times(n - 1, combiner(total, term(n)))\n        else:\n            return total\n    return combiner(times(n, 1 - combiner(1, 0)), base)\n\n\n\n\n\n\n\n\n\n    \"\"\"if n <= 1:\n        if term == triple:\n            return total + 2\n        else:\n            return total\n        else:\n            return times(n - 1, combiner(total, term(n)))\n    if n != 0:\n        return combiner(base, times(n, 1))\n    if base == 0 and combiner == mul:\n        return times(n, 1)\n    else:\n        return base\"\"\"\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":448,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n    return combiner(combiner_helper(n), base) =>           \r\n    return combiner_helper(n) + base          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def combiner_helper(n):\n        if n == 0:\n            return 0\n        elif n == 1:\n            return term(n)\n        else:\n            return combiner(term(n), combiner_helper(n - 1))\n    return combiner_helper(n) + base\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def combiner_helper(n):\n        if n == 0:\n            return 0\n        elif n == 1:\n            return term(n)\n        else:\n            return combiner(term(n), combiner_helper(n - 1))\n    return combiner(combiner_helper(n), base)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":74,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    if n==0:                  =>           \r\n        return base           =>           \r\n    if n==1:                  <=           \r\n        return base + term(1) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==1:\n        return base + term(1)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    if n==1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":609,"diff":"\r\nInputObject                    SideIndicator\r\n-----------                    -------------\r\n    if n == 0:                 =>           \r\n        return base            =>           \r\n    #if n == 1:                =>           \r\n        #return base + term(1) =>           \r\n    if n == 1:                 <=           \r\n        return base + term(1)  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return base + term(1)\n    else:\n        return combiner(accumulate(combiner, base, n - 1, term), term(n))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    #if n == 1:\n        #return base + term(1)\n    else:\n        return combiner(accumulate(combiner, base, n - 1, term), term(n))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(accumulate(combiner, base, n - 1, term), term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":75,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    return total     =>           \r\n        return total <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    lst = map(term, range(1, n+1))\n\n    total = base\n    for value in lst:\n        total = combiner(total, value)\n        return total\n\n    \n    \"\"\"\n    def g(x):\n        if combiner(1, 4) == 5:\n            return base + sum(apply(term))\n        else:\n            return base * product(n, term)\n    return g(1)\n    \"\"\"\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    lst = map(term, range(1, n+1))\n\n    total = base\n    for value in lst:\n        total = combiner(total, value)\n    return total\n\n    \n    \"\"\"\n    def g(x):\n        if combiner(1, 4) == 5:\n            return base + sum(apply(term))\n        else:\n            return base * product(n, term)\n    return g(1)\n    \"\"\"\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ForStatementNode, Children(ReferenceNode(node, Node(ForStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), Children(ReferenceNode(node, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), 0))))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Target(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":76,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    if combiner == add:                  =>           \r\n        total = 0                        =>           \r\n        total = 1                        =>           \r\n    for i in range(1, n+1):              =>           \r\n        total = combiner(total, term(i)) =>           \r\n    return combiner(base, total)         =>           \r\n    else:                                =>           \r\n    return combiner(base + term(n))      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    return combiner(base + term(n))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        total = 0\n    else:\n        total = 1\n    for i in range(1, n+1):\n        total = combiner(total, term(i))\n    return combiner(base, total)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-combiner), SingleChild(LeafConstNode(NameExpressionNode-add)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(ConstantExpressionNode-0))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ForStatementNode, Children(LeafConstNode(NameExpressionNode-i), Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-range), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i))))))))))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))))))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    return combiner(base + term(n))","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":77,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    p=base                    =>           \r\n    for _ in range(1,n+1):    =>           \r\n        p=combiner(term(_),p) =>           \r\n    return p                  =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    p=base\n    for _ in range(1,n+1):\n        p=combiner(term(_),p)\n    return p","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-p), SingleChild(LeafConstNode(NameExpressionNode-base)))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ForStatementNode, Children(LeafConstNode(NameExpressionNode-_), Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-range), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-p), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-_)))))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-p)))))))))))))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-p))), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":78,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    if n == 0:        =>           \r\n        n_counter = 0 =>           \r\n        n_counter = 1 =>           \r\n    else:             =>           \r\n    n_counter = 1     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    n_counter = 1\n    accum_num = combiner(base, term(n_counter))\n    while n_counter < n:\n        n_counter += 1\n        accum_num = combiner(accum_num, term(n_counter))\n    return accum_num\n    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        n_counter = 0\n    else:\n        n_counter = 1\n    accum_num = combiner(base, term(n_counter))\n    while n_counter < n:\n        n_counter += 1\n        accum_num = combiner(accum_num, term(n_counter))\n    return accum_num\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-n_counter), SingleChild(LeafConstNode(ConstantExpressionNode-0))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":79,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    z=base  =>           \r\n    z=n     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    z=n\n    for x in range(1,n+1):\n        z=combiner(z,term(x))\n    return z","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    z=base\n    for x in range(1,n+1):\n        z=combiner(z,term(x))\n    return z","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","20","","# Error: expected","#     15","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":119,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    t, i = base, 1  =>           \r\n    t, i = start, 1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    t, i = start, 1\n    while i <= n:\n            t = combiner(t, term(i))\n            i += 1\n    return t\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    t, i = base, 1\n    while i <= n:\n            t = combiner(t, term(i))\n            i += 1\n    return t\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    t, i = start, 1","NameError: name 'start' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":200,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    t, i = base, 1  =>           \r\n    t, i = start, 1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    t, i = start, 1\n    while i <= n:\n        t = combiner(t, term(i))\n        i += 1\n    return t","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    t, i = base, 1\n    while i <= n:\n        t = combiner(t, term(i))\n        i += 1\n    return t","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    t, i = start, 1","NameError: name 'start' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":220,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n    return base    =>           \r\n    return counter <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    k = 1\n\n    while k<=n:\n\n        base, k = combiner(base,term(k)), k +1\n\n    return counter\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    k = 1\n\n    while k<=n:\n\n        base, k = combiner(base,term(k)), k +1\n\n    return base\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate","    return counter","NameError: name 'counter' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":222,"diff":"\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1,term)) =>           \r\n        return combiner(term(n), accumulate(combiner, n, n-1,term))    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, n, n-1,term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1,term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":229,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    result = base   =>           \r\n    result = start  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    result = start \n    while n > 0:\n            result = combiner(result, term(counter))\n            n -= 1\n            counter += 1\n    return result ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    result = base \n    while n > 0:\n            result = combiner(result, term(counter))\n            n -= 1\n            counter += 1\n    return result ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    result = start","NameError: name 'start' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":309,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    total = base  =>           \r\n    total = start <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = start\n    for i in range(1, n + 1, 1):\n        total = combiner(total, term(i))\n    return total","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n + 1, 1):\n        total = combiner(total, term(i))\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    total = start","NameError: name 'start' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":315,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    result=base     =>           \r\n    result=combiner <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result=combiner\n    for i in range (1, n+1):\n        result=combiner(result, term(i))\n    return result\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result=base\n    for i in range (1, n+1):\n        result=combiner(result, term(i))\n    return result\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    result=combiner(result, term(i))","TypeError: unsupported operand type(s) for +: 'builtin_function_or_method' and 'int'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":420,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n        base = combiner(term(n), base)  =>           \r\n        start = combiner(term(n), base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        start = combiner(term(n), base)\n        return accumulate(combiner, base, n-1, term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        base = combiner(term(n), base)\n        return accumulate(combiner, base, n-1, term)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":460,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    total, k = base, 1  =>           \r\n    total, k = start, 1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = start, 1\n    while k <= n:\n        total, k = combiner(term(k), total), k + 1\n    return total","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(term(k), total), k + 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    total, k = start, 1","NameError: name 'start' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":472,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return n    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return n\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":473,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    total, k = base, 1  =>           \r\n                        =>           \r\n    total, k = start, 1 <=           \r\n                        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = start, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k+1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k+1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    total, k = start, 1","NameError: name 'start' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":545,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return n    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return n\n    else:\n        return combiner( term(n), accumulate(combiner, base, n-1, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner( term(n), accumulate(combiner, base, n-1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":80,"diff":"\r\nInputObject                                             SideIndicator\r\n-----------                                             -------------\r\n            return combiner(term(n), helper(n-1, term)) =>           \r\n            return term(n)+helper(n-1, term)            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(n, term):\n        if n == 0:\n            return 0\n        elif n <= 1:\n            return 1\n        else:\n            return term(n)+helper(n-1, term)\n    return combiner(base, helper(n, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(n, term):\n        if n == 0:\n            return 0\n        elif n <= 1:\n            return 1\n        else:\n            return combiner(term(n), helper(n-1, term))\n    return combiner(base, helper(n, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(LeafWildcard(\"CallExpressionNode\")))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","28","","# Error: expected","#     72","# but got","#     28","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":173,"diff":"\r\nInputObject                                                                 SideIndicator\r\n-----------                                                                 -------------\r\n            return combiner(term(i), accumulate(combiner, base, n-1, term)) =>           \r\n            return term(i) + accumulate(combiner, base, n-1, term)          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i):\n        if n==0:\n            return base\n        else:\n            return term(i) + accumulate(combiner, base, n-1, term)\n    return helper(n)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i):\n        if n==0:\n            return base\n        else:\n            return combiner(term(i), accumulate(combiner, base, n-1, term))\n    return helper(n)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(LeafWildcard(\"CallExpressionNode\")))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","16","","# Error: expected","#     72","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":508,"diff":"\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n        return combiner(term(n),accumulate(combiner, base, n-1, term)) =>           \r\n        return term(n)+accumulate(combiner, base, n-1, term)           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return term(n)+accumulate(combiner, base, n-1, term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(LeafWildcard(\"CallExpressionNode\")))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","16","","# Error: expected","#     72","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":81,"diff":"\r\nInputObject                                                       SideIndicator\r\n-----------                                                       -------------\r\n    if n==0:                                                      =>           \r\n        return base                                               =>           \r\n        base = combiner(base, term(n))                            =>           \r\n    return accumulate(combiner, base, n-1, term)                  =>           \r\n    if combiner==mul:                                             <=           \r\n        if n==base:                                               <=           \r\n            return term(base)                                     <=           \r\n        else:                                                     <=           \r\n            return term(n)*accumulate(combiner, base, n-1, term)  <=           \r\n        if n==base:                                               <=           \r\n            return term(base)                                     <=           \r\n        else:                                                     <=           \r\n            return term(n)+ accumulate(combiner, base, n-1, term) <=           \r\n                                                                  <=           \r\n                                                                  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner==mul:\n        if n==base:\n            return term(base)\n        else:\n            return term(n)*accumulate(combiner, base, n-1, term)\n    else:\n        if n==base:\n            return term(base)\n        else:\n            return term(n)+ accumulate(combiner, base, n-1, term)\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        base = combiner(base, term(n))\n    return accumulate(combiner, base, n-1, term)\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-base), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0), 0), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), 0), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))))), InOrderSort(ast)))))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return term(n)+ accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return term(n)+ accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return term(n)+ accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return term(n)+ accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return term(n)+ accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return term(n)+ accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    if combiner==mul:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     26","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":82,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    counter=1                    =>           \r\n        while counter<=n:        =>           \r\n        return accumulateTotal   =>           \r\n    counter=0                    <=           \r\n        while counter<n:         <=           \r\n        return accumulateTotal+5 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    accumulateTotal=base\n    counter=0\n    if n==0:\n        return base\n    else:\n        while counter<n:\n            accumulateTotal= combiner(accumulateTotal, term(counter))\n            counter+=1\n        return accumulateTotal+5\n        \n        \n        \n        \n        \n    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    accumulateTotal=base\n    counter=1\n    if n==0:\n        return base\n    else:\n        while counter<=n:\n            accumulateTotal= combiner(accumulateTotal, term(counter))\n            counter+=1\n        return accumulateTotal\n        \n        \n        \n        \n        \n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","21","","# Error: expected","#     25","# but got","#     21","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":84,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        combiner(term(n), accumulate(combiner, base, n-1, term))        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\")))), 0)))), Selected(\\x => Match(x, Skip(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    combiner(term(n), accumulate(combiner, base, n-1, term))","TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":189,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    return helper(n) =>           \r\n    helper(n)        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i):\n        if n == 0:\n            return base\n        else:\n            return combiner(term(i), accumulate(combiner, base, n-1, term))\n    helper(n)\n\n    \"\"\"if n ==0:\n        return base\n    else:\n        total, i = base, 1\n        while i < n:\n            total = combiner(term(i), total)\n            i += 1\n    return combiner(term(n), total)\"\"\"\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i):\n        if n == 0:\n            return base\n        else:\n            return combiner(term(i), accumulate(combiner, base, n-1, term))\n    return helper(n)\n\n    \"\"\"if n ==0:\n        return base\n    else:\n        total, i = base, 1\n        while i < n:\n            total = combiner(term(i), total)\n            i += 1\n    return combiner(term(n), total)\"\"\"\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\")))), 0)))), Selected(\\x => Match(x, Skip(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    helper(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in helper","    return combiner(term(i), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    helper(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in helper","    return combiner(term(i), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    helper(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in helper","    return combiner(term(i), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    helper(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in helper","    return combiner(term(i), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    helper(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in helper","    return combiner(term(i), accumulate(combiner, base, n-1, term))","TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":522,"diff":"\r\nInputObject                                                                SideIndicator\r\n-----------                                                                -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))  =>           \r\n        combiner(term(n), accumulate(combiner, base, n - 1, term))         <=           \r\n\r\n\r\n","before":"def accumulate(combiner,  base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        combiner(term(n), accumulate(combiner, base, n - 1, term)) \n\n","after":"def accumulate(combiner,  base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"CallExpressionNode\")))), 0)))), Selected(\\x => Match(x, Skip(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"CallExpressionNode\")))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    combiner(term(n), accumulate(combiner, base, n - 1, term))","TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":86,"diff":"\r\nInputObject                                                                                    SideIndicator\r\n-----------                                                                                    -------------\r\n        return combiner(base, accumulate(combiner, term(n), n-1, term))                        =>           \r\n        return combiner(base, (combiner(term(n), accumulate(combiner, term(n-1), n-2, term)))) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n < 1:\n        return base\n    else:\n        return combiner(base, (combiner(term(n), accumulate(combiner, term(n-1), n-2, term))))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n < 1:\n        return base\n    else:\n        return combiner(base, accumulate(combiner, term(n), n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0), 2), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":87,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    for i in range(1, n + 1):           =>           \r\n    for i in range(base, base + n + 1): <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(base, base + n + 1):\n        total = combiner(total, term(i))\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n + 1):\n        total = combiner(total, term(i))\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","92","","# Error: expected","#     26","# but got","#     92","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":89,"diff":"\r\nInputObject                                    SideIndicator\r\n-----------                                    -------------\r\n    i = 1                                      =>           \r\n        product = combiner(product,term(i))    =>           \r\n    i = 0                                      <=           \r\n        product = combiner(product,term(base)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    product = base\n    i = 0\n    while i < n+1:\n    \tproduct = combiner(product,term(base))\n    \ti +=1\n    return product\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    product = base\n    i = 1\n    while i < n+1:\n    \tproduct = combiner(product,term(i))\n    \ti +=1\n    return product\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":91,"diff":"\r\nInputObject                                                           SideIndicator\r\n-----------                                                           -------------\r\n    def a(combiner,n,term):                                           =>           \r\n        if n == 1:                                                    =>           \r\n            return term(1)                                            =>           \r\n        else:                                                         =>           \r\n            return combiner(term(n), a(combiner, n-1, term))          =>           \r\n        return combiner(base, a(combiner,n,term))                     =>           \r\n        return combiner(base, combiner(term(n), combiner(n-1, term))) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    if n == 0:\n        return base\n    else:\n        return combiner(base, combiner(term(n), combiner(n-1, term)))\n\n\n\n    \"*** YOUR CODE HERE ***\"","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def a(combiner,n,term):\n        if n == 1:\n            return term(1)\n        else: \n            return combiner(term(n), a(combiner, n-1, term))\n    \n    if n == 0:\n        return base\n    else:\n        return combiner(base, a(combiner,n,term))\n\n\n\n    \"*** YOUR CODE HERE ***\"","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-a), 0), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0))), 1), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(FunctionDefinitionNode-a, Children(LeafConstNode(ParameterNode-combiner), Children(LeafConstNode(ParameterNode-n), Children(LeafConstNode(ParameterNode-term), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-a), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0))), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term)))))))))))))))))))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-a), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast)))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    return combiner(base, combiner(term(n), combiner(n-1, term)))","TypeError: unsupported operand type(s) for +: 'int' and 'function'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":92,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n        total=combiner(total,term(x)) =>           \r\n        total=term(total)             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x=1\n    total=base\n    while x<n+1:\n        total=term(total)\n        x+=1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x=1\n    total=base\n    while x<n+1:\n        total=combiner(total,term(x))\n        x+=1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-x)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))))))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":94,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    total = base     =>           \r\n        total = base <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    if n == 0:\n        return base\n        \n    while n > 0:\n        total = base\n        total = combiner(total ,term(n))\n        n =  n-1\n    return total","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    if n == 0:\n        return base\n    total = base    \n    while n > 0:\n        \n        total = combiner(total ,term(n))\n        n =  n-1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(NameExpressionNode-base)))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":98,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), term(n-1))                             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), term(n-1))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","9","","# Error: expected","#     15","# but got","#     9","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":447,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return combiner(term(n), term(n - 1))                             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    else:\n        return combiner(term(n), term(n - 1))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","9","","# Error: expected","#     15","# but got","#     9","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":553,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return combiner(term(n), term(n - 1))                             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), term(n - 1))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","9","","# Error: expected","#     15","# but got","#     9","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":101,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))   =>           \r\n        return combiner([term(n), accumulate(combiner, base, n-1, term)]) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if (n > 0):\n        return combiner([term(n), accumulate(combiner, base, n-1, term)])\n    else:\n        return base\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if (n > 0):\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    else:\n        return base\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ListExpressionNode, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(ListExpressionNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ListExpressionNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0))), 2), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(ListExpressionNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(ListExpressionNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(ListExpressionNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner([term(n), accumulate(combiner, base, n-1, term)])","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner([term(n), accumulate(combiner, base, n-1, term)])","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner([term(n), accumulate(combiner, base, n-1, term)])","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner([term(n), accumulate(combiner, base, n-1, term)])","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    return combiner([term(n), accumulate(combiner, base, n-1, term)])","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":102,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n    def helper(a,n):                         =>           \r\n        if n == 0:                           =>           \r\n            return a                         =>           \r\n        else:                                =>           \r\n            a = combiner(a, term(n))         =>           \r\n        return helper(a, n-1)                =>           \r\n    return helper(base, n)                   =>           \r\n    if n == 1:                               <=           \r\n        return term(1) + base                <=           \r\n    else:                                    <=           \r\n        return term(n) * combiner(n-1, term) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return term(1) + base\n    else: \n        return term(n) * combiner(n-1, term)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(a,n):\n        if n == 0:\n            return a \n        else:\n            a = combiner(a, term(n))\n        return helper(a, n-1)\n    return helper(base, n)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(LeafWildcard(\"NameExpressionNode\")))), 0)))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-a), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-a))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(LeafWildcard(\"NameExpressionNode\")))), 0)))))))))), 0), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-helper), 0), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-a))), 1), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(FunctionDefinitionNode-helper, Children(LeafConstNode(ParameterNode-a), Children(LeafConstNode(ParameterNode-n), SingleChild(ConstNode(SuiteStatementNode, Children(ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-a)))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-a), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-a))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(LeafWildcard(\"NameExpressionNode\")))), 0))))))))))))))), SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-helper), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-a))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-helper)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), InOrderSort(ast)))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return term(n) * combiner(n-1, term)","TypeError: unsupported operand type(s) for +: 'int' and 'function'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":105,"diff":"\r\nInputObject                                                                                SideIndicator\r\n-----------                                                                                -------------\r\n    \"\"\"def f(x):                                                                           =>           \r\n    return f(n)\"\"\"                                                                         =>           \r\n    s=base                                                                                 =>           \r\n    return s                                                                               =>           \r\n    return accumulate(lambda combiner:combiner if pred else lambda x,y,:x , base, n, term) =>           \r\n    def f(x):                                                                              <=           \r\n    return f(n)                                                                            <=           \r\n    \"\"\"\"s=base                                                                             <=           \r\n    return s\"\"\"                                                                            <=           \r\n    return _______                                                                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def f(x):\n        if x==1:\n            return base+term(1)\n        else: \n            return combiner(f(x-1),term(x))\n    return f(n)\n    \"\"\"\"s=base\n    for i in range(1,n+1):\n        s=combiner(s,term(i))\n    return s\"\"\"\n    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"def f(x):\n        if x==1:\n            return base+term(1)\n        else: \n            return combiner(f(x-1),term(x))\n    return f(n)\"\"\"\n    s=base\n    for i in range(1,n+1):\n        s=combiner(s,term(i))\n    return s\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ExpressionStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-def f(x):\n        if x==1:\n            return base+term(1)\n        else: \n            return combiner(f(x-1),term(x))\n    return f(n)))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-f, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-s), SingleChild(LeafConstNode(NameExpressionNode-base)))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-f, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-f, TChildren(Target(LeafWildcard(\"ParameterNode\")), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0)))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), 0), 2), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-range), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0)))))))), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-s)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-s), SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(FunctionDefinitionNode-f, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(FunctionDefinitionNode-f, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(FunctionDefinitionNode-f, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), 0), 2), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(FunctionDefinitionNode-f, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ForStatementNode, Children(LeafConstNode(NameExpressionNode-i), Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-range), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-s), SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0))))))))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(FunctionDefinitionNode-f, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-s)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-f, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), TChildren(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-f, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), TChildren(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-f, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-f, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast)))))))))))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f","    return combiner(f(x-1),term(x))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f","    return combiner(f(x-1),term(x))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f","    return combiner(f(x-1),term(x))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f","    return combiner(f(x-1),term(x))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f","    return combiner(f(x-1),term(x))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in f","    return combiner(f(x-1),term(x))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 79, in f","    if x==1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":107,"diff":"\r\nInputObject                                                                       SideIndicator\r\n-----------                                                                       -------------\r\n    if n == 0:                                                                    =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))           =>           \r\n        \"\"\"                                                                       =>           \r\n    total, k = base, 1                                                            =>           \r\n    return total\"\"\"                                                               =>           \r\n    return accumulate(lambda b,a: combiner(b,a) if pred(a) else b, base, n, term) =>           \r\n    \"\"\"if n == 0:                                                                 <=           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\"\"\"        <=           \r\n    total, k = start, 1                                                           <=           \r\n    return total                                                                  <=           \r\n    return accumulate(lambda b,a: combiner(b,a) if pred(b) else b, base, n, term) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\"\"\"\n    total, k = start, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k+1\n    return total  \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n        \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k+1\n    return total\"\"\"  \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0))))), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)))), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), 0), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)))))))), SingleChild(ConstNode(SuiteStatementNode, Children(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), SingleChild(ConstNode(ExpressionStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k+1\n    return total)))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast)))))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    total, k = start, 1","NameError: name 'start' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":108,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n        total = 0 =>           \r\n        total = 1 =>           \r\n    total = 1     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = 1\n    if combiner == add:\n        while i <= n:\n            total += term(i)\n            i += 1\n        total = total + base\n    elif combiner == mul:\n        while i <= n:\n            total = total * term(i)\n            i += 1\n        total = total * base\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    if combiner == add:\n        total = 0\n        while i <= n:\n            total += term(i)\n            i += 1\n        total = total + base\n    elif combiner == mul:\n        total = 1\n        while i <= n:\n            total = total * term(i)\n            i += 1\n        total = total * base\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), 0), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":109,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    i = 1                                 =>           \r\n    total = base                          =>           \r\n    while i <= n:                         =>           \r\n        total = combiner(total, term(i))  =>           \r\n        i += 1                            =>           \r\n    return total                          =>           \r\n    return ________                       =>           \r\n        return compsel(f, f)              =>           \r\n        return repeated(f, n-1)           =>           \r\n        return term(n)                    <=           \r\n    if n == 0:                            <=           \r\n        return base                       <=           \r\n        return combiner(base, term(n-1))  <=           \r\n    #i = 1                                <=           \r\n    #total = base                         <=           \r\n    #while i <= n:                        <=           \r\n    #    total = combiner(total, term(i)) <=           \r\n    #    i += 1                           <=           \r\n    #return total                         <=           \r\n    return accumulate(combiner, base, )   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    if n == 0:\n        return base\n    else:\n        return combiner(base, term(n-1))\n    #i = 1\n    #total = base\n    #while i <= n:\n    #    total = combiner(total, term(i))\n    #    i += 1\n    #return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    total = base\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-i), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(NameExpressionNode-base))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(NameExpressionNode-n))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(NameExpressionNode-n)))), SingleChild(ConstNode(SuiteStatementNode, Children(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), 0)))), SingleChild(ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 5), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))))))))))), InOrderSort(ast)))))))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","4","","# Error: expected","#     15","# but got","#     4","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":110,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n        k += 1 =>           \r\n        k +=k  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total = combiner(total, term(k))\n        k +=k\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","7","","# Error: expected","#     15","# but got","#     7","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":391,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    term_total = term(1) =>           \r\n    term_total = term(i) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    term_total = term(i)\n    i = 2\n    if n == 0:\n        term_total = 0\n    while i <= n:\n        term_total = combiner(term_total, term(i))\n        i = i + 1\n    return combiner(base, term_total)","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    term_total = term(1)\n    i = 2\n    if n == 0:\n        term_total = 0\n    while i <= n:\n        term_total = combiner(term_total, term(i))\n        i = i + 1\n    return combiner(base, term_total)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    term_total = term(i)","UnboundLocalError: local variable 'i' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":111,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n        if n == 0:      =>           \r\n            return base =>           \r\n        elif i == 0:    =>           \r\n        elif i >= n:    =>           \r\n        if i == 0:      <=           \r\n        elif i == n:    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def combine(i):\n        if i == 0:\n            return combiner(base, combine(i+1))\n        elif i == n:\n            return term(i)\n        else:\n            return combiner(term(i), combine(i+1))\n    return combine(0)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def combine(i):\n        if n == 0:\n            return base\n        elif i == 0:\n            return combiner(base, combine(i+1))\n        elif i >= n:\n            return term(i)\n        else:\n            return combiner(term(i), combine(i+1))\n    return combine(0)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine","    return combiner(term(i), combine(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine","    return combiner(term(i), combine(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine","    return combiner(term(i), combine(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine","    return combiner(term(i), combine(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine","    return combiner(term(i), combine(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in combine","    return combiner(term(i), combine(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in combine","    if i == 0:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":115,"diff":"\r\nInputObject                                                      SideIndicator\r\n-----------                                                      -------------\r\n    f = combiner                                                 =>           \r\n        return f(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return term(n) + accumulate(combiner, base, n-1, term)   <=           \r\n                                                                 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else: \n        return term(n) + accumulate(combiner, base, n-1, term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    f = combiner\n    if n == 0:\n        return base\n    else: \n        return f(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-f), SingleChild(LeafConstNode(NameExpressionNode-combiner)))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-f), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","16","","# Error: expected","#     72","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":116,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    total = base                  =>           \r\n        if n == 0:                <=           \r\n            n = n -1              <=           \r\n    total = combiner(total, base) <=           \r\n    total = 0                     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    k = 1\n    while k<=n:\n        if n == 0:\n            n = n -1\n        total = combiner(term(k), total)\n        k = k + 1\n    total = combiner(total, base)\n    return total \n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k<=n:\n        total = combiner(term(k), total)\n        k = k + 1\n    return total \n    \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":121,"diff":"\r\nInputObject                                            SideIndicator\r\n-----------                                            -------------\r\ndef accumulate(combiner, base, n, term):               =>           \r\ndef accumulate(combiner, base, n, term, pred=True):    <=           \r\n    elif pred(n) == False:                             <=           \r\n        return accumulate(combiner, base, n - 1, term) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term, pred=True):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif pred(n) == False:\n        return accumulate(combiner, base, n - 1, term)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(Target(Node(ParameterNode-pred, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(Node(ParameterNode-pred, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    elif pred(n) == False:","TypeError: 'bool' object is not callable","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":122,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n    if (n < 1):                                                         =>           \r\n        return accumulate(combiner, combiner(base, term(n)), n-1, term) =>           \r\n    if (n == 0):                                                        <=           \r\n        return combiner(n, accumulate(combiner, base, n-1, term))       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if (n == 0):\n        return base\n    else:\n        return combiner(n, accumulate(combiner, base, n-1, term)) \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if (n < 1):\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1))))), Selected(\\x => Match(x, Node(ParenthesisExpressionNode, TChild(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-accumulate)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)))))))))))), 2), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), 3), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), 4), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":124,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n <= 1: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(term(n), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 1:\n        return combiner(term(n), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\"))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":435,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n <= 1: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    if n == 1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n), accumulate(combiner,base,n-1,term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    if n <= 1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n), accumulate(combiner,base,n-1,term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\"))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":486,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n <= 1: =>           \r\n    if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <= 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\"))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":564,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n        if n <= 1: =>           \r\n        if n == 1: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def whatever(n):\n        if n == 1:\n            return term(n) \n        else:\n            return combiner(term(n), whatever(n-1))\n   \n    return combiner(base, whatever(n))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def whatever(n):\n        if n <= 1:\n            return term(n) \n        else:\n            return combiner(term(n), whatever(n-1))\n   \n    return combiner(base, whatever(n))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"CallExpressionNode\"))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever","    return combiner(term(n), whatever(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever","    return combiner(term(n), whatever(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever","    return combiner(term(n), whatever(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever","    return combiner(term(n), whatever(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever","    return combiner(term(n), whatever(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in whatever","    return combiner(term(n), whatever(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in whatever","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":125,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    for x in range(2, n + 1): =>           \r\n    for x in range(n):        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    \"\"\"\n    if n == 0:\n        return base\n\n    if n > 0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    \"\"\"\n    if n == 0:\n        return base\n    temp_term = 0\n    total = combiner(term(1), base)\n    for x in range(n):\n        if term(x):\n            temp_term = term(x)\n        total = combiner(temp_term, total)\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    \"\"\"\n    if n == 0:\n        return base\n\n    if n > 0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    \"\"\"\n    if n == 0:\n        return base\n    temp_term = 0\n    total = combiner(term(1), base)\n    for x in range(2, n + 1):\n        if term(x):\n            temp_term = term(x)\n        total = combiner(temp_term, total)\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-2))), 1), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","11","","# Error: expected","#     15","# but got","#     11","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":127,"diff":"\r\nInputObject                                                                 SideIndicator\r\n-----------                                                                 -------------\r\n    while n >= 1:                                                           =>           \r\n        n = n - 1                                                           =>           \r\n    total , counter =  10 , 1                                               =>           \r\n    while counter < n:                                                      =>           \r\n        total , counter  = total + n + 2 * (n-1) + 3 * (n-2) , counter + 1  =>           \r\n    return total                                                            =>           \r\n    while n <= 1:                                                           <=           \r\n        n = n + 1                                                           <=           \r\n                                                                            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n\n    total = base\n    \n    while n <= 1:\n        total = combiner(total, term(n))\n        n = n + 1\n    return total\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n\n    total = base\n    \n    while n >= 1:\n        total = combiner(total, term(n))\n        n = n - 1\n    return total\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":129,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    return total     =>           \r\n        return total <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n == 0 or n == 1:\n    #     return combiner(base, term(n))\n    # else:\n    #     return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n    total = base\n    a = 0\n    while a < n:\n        a +=1\n        total = combiner(total, term(a))\n        return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n == 0 or n == 1:\n    #     return combiner(base, term(n))\n    # else:\n    #     return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n    total = base\n    a = 0\n    while a < n:\n        a +=1\n        total = combiner(total, term(a))\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ReferenceNode(node, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), SingleChild(ConstNode(SuiteStatementNode, Children(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0))))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":132,"diff":"\r\nInputObject                    SideIndicator\r\n-----------                    -------------\r\n    if combiner == add:        =>           \r\n        i = 0                  =>           \r\n    if combiner == mul:        =>           \r\n        i = 1                  =>           \r\n            return i           =>           \r\n            return term(n + 1) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(n, term):\n        if n == 0:\n            return term(n + 1)\n        return combiner(term(n), helper(n - 1, term))\n    return combiner(helper(n, term), base)\n\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        i = 0\n    if combiner == mul:\n        i = 1\n    def helper(n, term):\n        if n == 0:\n            return i\n        return combiner(term(n), helper(n - 1, term))\n    return combiner(helper(n, term), base)\n\n\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-combiner), SingleChild(LeafConstNode(NameExpressionNode-add)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-0))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-combiner), SingleChild(LeafConstNode(NameExpressionNode-mul)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":134,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(term(x), total) =>           \r\n        total = combiner(term, total)    <=           \r\n                                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for x in range(1, n+1):\n        total = combiner(term, total)\n\n    return total\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for x in range(1, n+1):\n        total = combiner(term(x), total)\n    return total\n    \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-x)))))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    total = combiner(term, total)","TypeError: unsupported operand type(s) for +: 'function' and 'int'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":135,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    for i in range(1, n+1):      =>           \r\n    for i in range(base+1, n+1): <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    accum = base\n    if (base > n):\n        accum = base\n        base = 0\n    for i in range(base+1, n+1):\n        accum = combiner(accum,term(i))\n    return accum\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    accum = base\n    if (base > n):\n        accum = base\n        base = 0\n    for i in range(1, n+1):\n        accum = combiner(accum,term(i))\n    return accum\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","18","","# Error: expected","#     72","# but got","#     18","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":138,"diff":"\r\nInputObject                                               SideIndicator\r\n-----------                                               -------------\r\n#    if n == 0:                                           =>           \r\n#        return base                                      =>           \r\n#    def accu_helper(i):                                  =>           \r\n#        if i == 1:                                       =>           \r\n#            return term(1)                               =>           \r\n#        else:                                            =>           \r\n#            return combiner(term(i), accu_helper(i - 1)) =>           \r\n#    return combiner(base, accu_helper(n - 1))            =>           \r\n    if n == 0:                                            <=           \r\n        return base                                       <=           \r\n    def accu_helper(i):                                   <=           \r\n        if i == 1:                                        <=           \r\n            return term(1)                                <=           \r\n        else:                                             <=           \r\n            return combiner(term(i), accu_helper(i - 1))  <=           \r\n    return combiner(base, accu_helper(n - 1))             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    def accu_helper(i):\n        if i == 1:\n            return term(1)\n        else:\n            return combiner(term(i), accu_helper(i - 1))\n    return combiner(base, accu_helper(n - 1))\n\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n#    if n == 0:\n#        return base\n#    def accu_helper(i):\n#        if i == 1:\n#            return term(1)\n#        else:\n#            return combiner(term(i), accu_helper(i - 1))\n#    return combiner(base, accu_helper(n - 1))\n\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChildren(Node(FunctionDefinitionNode-accu_helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(FunctionDefinitionNode-accu_helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Target(Node(FunctionDefinitionNode-accu_helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(FunctionDefinitionNode-accu_helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(FunctionDefinitionNode-accu_helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))), TChildren(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(FunctionDefinitionNode-accu_helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":139,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\ndef helper(i, total): <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n\ndef helper(i, total):\n    total = base\n    current = 1\n    while current<= n :\n        total = combiner(total, term(current))\n        current +=1\n    return total\n\n\n \n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n\n    total = base\n    current = 1\n    while current<= n :\n        total = combiner(total, term(current))\n        current +=1\n    return total\n\n\n \n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(PythonAstNode, TChild(Target(Node(SuiteStatementNode, TChildren(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(FunctionDefinitionNode-accumulate, Children(ReferenceNode(node, Node(FunctionDefinitionNode-accumulate, TChildren(Target(LeafWildcard(\"ParameterNode\")), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0), Children(ReferenceNode(node, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(Target(LeafWildcard(\"ParameterNode\")), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0), Children(ReferenceNode(node, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(Target(LeafWildcard(\"ParameterNode\")), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0), Children(ReferenceNode(node, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(Target(LeafWildcard(\"ParameterNode\")), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0), SingleChild(ConstNode(SuiteStatementNode, Children(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), 0), Children(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0), Children(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0), Children(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0), Children(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0), SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)))))))))))))), 0), Selected(\\x => Match(x, Node(PythonAstNode, TChild(Target(Node(SuiteStatementNode, TChildren(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Target(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(PythonAstNode, TChild(Target(Node(SuiteStatementNode, TChildren(Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":140,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        if n==0:     =>           \r\n            return 0 =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def after_base(combiner, n, term, i):\n        if i==n:\n            return term(n)\n        return combiner(term(i), after_base(combiner, n, term, i+1))\n    return combiner(base, after_base(combiner, n, term, 1))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def after_base(combiner, n, term, i):\n        if n==0:\n            return 0\n        if i==n:\n            return term(n)\n        return combiner(term(i), after_base(combiner, n, term, i+1))\n    return combiner(base, after_base(combiner, n, term, 1))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-0)))))))))), 0), Selected(\\x => Match(x, Node(FunctionDefinitionNode-after_base, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base","    return combiner(term(i), after_base(combiner, n, term, i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base","    return combiner(term(i), after_base(combiner, n, term, i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base","    return combiner(term(i), after_base(combiner, n, term, i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base","    return combiner(term(i), after_base(combiner, n, term, i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base","    return combiner(term(i), after_base(combiner, n, term, i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in after_base","    return combiner(term(i), after_base(combiner, n, term, i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in after_base","    if i==n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":142,"diff":"\r\nInputObject                                                           SideIndicator\r\n-----------                                                           -------------\r\n        x = combiner(x, term(y))                                      =>           \r\n    return accumulate(combiner, base, lambda n : pred(n)==True, term) =>           \r\n        if pred(term(y))==True:                                       <=           \r\n            x = combiner(x, term(y))                                  <=           \r\n    return accumulate(combiner, base, n, term)                        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    y = n\n    while y >=1:\n        if pred(term(y))==True:\n            x = combiner(x, term(y))\n        y -= 1\n    return x\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    y = n\n    while y >=1:\n        x = combiner(x, term(y))\n        y -= 1\n    return x\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), 0), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    if pred(term(y))==True:","NameError: name 'pred' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":147,"diff":"\r\nInputObject                                                                SideIndicator\r\n-----------                                                                -------------\r\n    total=base                                                             =>           \r\n            return totaler(combiner,base,n-1,term,combiner(total,term(n))) =>           \r\n    total=1                                                                <=           \r\n            return totaler(combiner,base,n-1,term,total*term(n))           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=1\n    def totaler(combiner,base,n,term,total):\n        if n>0:\n            return totaler(combiner,base,n-1,term,total*term(n))\n        else:\n            return total\n    return totaler(combiner,base,n,term,total)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=base\n    def totaler(combiner,base,n,term,total):\n        if n>0:\n            return totaler(combiner,base,n-1,term,combiner(total,term(n)))\n        else:\n            return total\n    return totaler(combiner,base,n,term,total)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)))))))), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","120","","# Error: expected","#     15","# but got","#     120","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":149,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        if n == 1:         =>           \r\n            return term(1) =>           \r\n        if n == 0:         <=           \r\n            return 1       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    def term_recursion(n):\n        if n == 0:\n            return 1\n        else:\n            return combiner(term(n), term_recursion(n - 1))\n    return combiner(base, term_recursion(n))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    def term_recursion(n):\n        if n == 1:\n            return term(1)\n        else:\n            return combiner(term(n), term_recursion(n - 1))\n    return combiner(base, term_recursion(n))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0)))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":152,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    total = base                  =>           \r\n    return total                  =>           \r\n    total = term(i)               <=           \r\n    return combiner(base, total)  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = term(i)\n    while i <= n:\n        if n == 0:\n            return base\n        total = combiner(total, term(i))\n        i = i + 1\n    return combiner(base, total) \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = base\n    while i <= n:\n        if n == 0:\n            return base\n        total = combiner(total, term(i))\n        i = i + 1\n    return total \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":154,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        combiner(total, term(i))         <=           \r\n                                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        combiner(total, term(i))\n    return total\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        total = combiner(total, term(i))\n    return total\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0))))), Selected(\\x => Match(x, Skip(Target(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":396,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(n)) =>           \r\n        combiner(total, term(n))         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n\n    if n == 0:\n    \treturn combiner(base)\n    else:\n\t\tcombiner(term(n), term(n - 1))\n\n\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # def addition(n, term):\n    # \tif n == 0:\n    # \t\treturn 0\n    # \telse:\n    # \t\t# print(term(n) + addition(n-1, term))\n    # \t\treturn term(n) + addition(n-1, term)\n    total = base\n    while n > 0:\n    \tcombiner(total, term(n))\n    \tn -= 1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n\n    if n == 0:\n    \treturn combiner(base)\n    else:\n\t\tcombiner(term(n), term(n - 1))\n\n\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # def addition(n, term):\n    # \tif n == 0:\n    # \t\treturn 0\n    # \telse:\n    # \t\t# print(term(n) + addition(n-1, term))\n    # \t\treturn term(n) + addition(n-1, term)\n    total = base\n    while n > 0:\n    \ttotal = combiner(total, term(n))\n    \tn -= 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0))))), Selected(\\x => Match(x, Skip(Target(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":155,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    for i in range(1,n+1): =>           \r\n    for i in range(1,n):   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1,n):\n        total=combiner(total, term(i))\n    return total","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1,n+1):\n        total=combiner(total, term(i))\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":156,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    while y<=n: =>           \r\n    while x<=n: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = base\n    y = 1\n    while x<=n:\n        x = combiner(x,term(y))\n        y += 1\n    return x\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = base\n    y = 1\n    while y<=n:\n        x = combiner(x,term(y))\n        y += 1\n    return x\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-y)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","6","","# Error: expected","#     15","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":157,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n            return combiner(base, func(x)) =>           \r\n            return base + func(x)          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    def helper(func, x, combiner):\n        if n == 0:\n            return base\n        elif x == n:\n            return base + func(x)\n        else:\n            return combiner(func(x), helper(term, x + 1, combiner)) \n    return helper(term, 1, combiner) \n   \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    def helper(func, x, combiner):\n        if n == 0:\n            return base\n        elif x == n:\n            return combiner(base, func(x))\n        else:\n            return combiner(func(x), helper(term, x + 1, combiner)) \n    return helper(term, 1, combiner) \n   \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","44","","# Error: expected","#     72","# but got","#     44","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":227,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(base, term(n)) =>           \r\n        return base + term(n)          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    if n == 1:\n        return base + term(n)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":467,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return combiner(base, term(n)) =>           \r\n        return base + term(n)          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0 or n==1:\n        return base + term(n)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0 or n==1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":590,"diff":"\r\nInputObject                                                      SideIndicator\r\n-----------                                                      -------------\r\n        return combiner(base, accumulator(combiner, n, term, 1)) =>           \r\n        return base + accumulator(combiner, n, term, 1)          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n    BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    \"\"\"\n    accumulate(add, 11, 0, identity) # 11\n    \"\"\"\n\n    def accumulator(combiner, n, term, i):\n        if(i==n):\n            return term(i)\n        else:\n            return combiner(term(i), accumulator(combiner, n, term, i+1))\n\n    if(n==0):\n        return base\n    else:\n        return base + accumulator(combiner, n, term, 1)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n    BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    \"\"\"\n    accumulate(add, 11, 0, identity) # 11\n    \"\"\"\n\n    def accumulator(combiner, n, term, i):\n        if(i==n):\n            return term(i)\n        else:\n            return combiner(term(i), accumulator(combiner, n, term, i+1))\n\n    if(n==0):\n        return base\n    else:\n        return combiner(base, accumulator(combiner, n, term, 1))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":158,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    total = base        =>           \r\n    return total        =>           \r\n    total = 0           <=           \r\n    return base + total <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 0\n    for i in range(0, n):\n        total = combiner(total, term(i + 1))\n    return base + total","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = base\n    for i in range(0, n):\n        total = combiner(total, term(i + 1))\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","2","","# Error: expected","#     72","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":159,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n    total, i = base, 1                       =>           \r\n        total = combiner(total, term(i))     =>           \r\n    return total                             =>           \r\n    total, i = 1, 0                          <=           \r\n        total = combiner(term(i), term(i+1)) <=           \r\n        total = combiner(total, term(n))     <=           \r\n    return combiner(base, total)             <=           \r\n    else:                                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #term and n: the same arguments as in summation and product\n    #combiner: two-argument function that specifies how the furrent term combined previous accu terms\n    #base: value specifies start of accu\n    total, i = 1, 0\n    while i <= n:\n        total = combiner(term(i), term(i+1))\n        i = increment(i)\n    else:\n        total = combiner(total, term(n))\n    return combiner(base, total)","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #term and n: the same arguments as in summation and product\n    #combiner: two-argument function that specifies how the furrent term combined previous accu terms\n    #base: value specifies start of accu\n    total, i = base, 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i = increment(i)\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"ConstantExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), 1), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":160,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        return base                    =>           \r\n        return 0                       <=           \r\n    if n == 1:                         <=           \r\n        return combiner(base, term(n)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return combiner(base, term(n))\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","0","","# Error: expected","#     11","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":161,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    i = 1         =>           \r\n    result = base =>           \r\n    i = base      <=           \r\n    result = 0    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = base\n    result = 0\n    while i <= n:\n         result = combiner(result, term(i))\n         i += 1\n    return result\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    result = base\n    while i <= n:\n         result = combiner(result, term(i))\n         i += 1\n    return result\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     26","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":163,"diff":"\r\nInputObject                                                                                   SideIndicator\r\n-----------                                                                                   -------------\r\n    k=1                                                                                       =>           \r\n    while k<=n:                                                                               =>           \r\n        base = combiner(base, term(k))                                                        =>           \r\n        k +=1                                                                                 =>           \r\n    n=1                                                                                       <=           \r\n    while n<=k:                                                                               <=           \r\n        base = combiner(base, term(n))                                                        <=           \r\n        n +=1                                                                                 <=           \r\n    return accumulate((lambda combiner: combiner if pred(combiner) else None), base, n, term) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    n=1\n    while n<=k:\n        base = combiner(base, term(n))\n        n +=1\n    return base","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k=1\n    while k<=n:\n        base = combiner(base, term(k))\n        k +=1\n    return base","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    while n<=k:","NameError: name 'k' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":166,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    while n >= 0:                        =>           \r\n        if n == 0:                       =>           \r\n            return end                   =>           \r\n        else:                            =>           \r\n            end = combiner(end, term(n)) =>           \r\n            n -=1                        =>           \r\n    if n == 0:                           <=           \r\n        return end                       <=           \r\n    elif n > 0:                          <=           \r\n        end = combiner(end, term(n))     <=           \r\n        n -=1                            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    end = base\n    if n == 0:\n        return end\n    elif n > 0:\n        end = combiner(end, term(n))\n        n -=1\n    return end","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    end = base\n    while n >= 0:\n        if n == 0:\n            return end\n        else:\n            end = combiner(end, term(n))\n            n -=1\n    return end","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":168,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    elif n == 1: <=           \r\n        return 1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    elif n == 1:\n    \treturn 1\n    else:\n    \treturn combiner(base, accumulate(combiner, term(n), n - 1, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    else:\n    \treturn combiner(base, accumulate(combiner, term(n), n - 1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","13","","# Error: expected","#     15","# but got","#     13","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":171,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        total, k = combiner(term(k), total), k + 1   =>           \r\n        total, k = combiner * total * term(k), k + 1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner * total * term(k), k + 1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(term(k), total), k + 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total)))))))), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    total, k = combiner * total * term(k), k + 1","TypeError: unsupported operand type(s) for *: 'builtin_function_or_method' and 'int'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":174,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total = combiner(term(i))        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 1\n    while i <= n:\n        total = combiner(term(i))\n        i += 1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 1), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    total = combiner(term(i))","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":175,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n        k += 1 =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k  = base, 1\n    while k <= n:\n        total = combiner(total, term(k))\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k  = base, 1\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     15","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":177,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return base + accumulate(combiner, base, n - 1, term)             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    else:\n    \treturn base + accumulate(combiner, base, n - 1, term)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    else:\n    \treturn combiner(term(n), accumulate(combiner, base, n - 1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":488,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    return base + accumulate(combiner, base, n-1, term)             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 0:\n        return base\n    return base + accumulate(combiner, base, n-1, term) \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":183,"diff":"\r\nInputObject                                                                             SideIndicator\r\n-----------                                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))                 =>           \r\n    if pred == false:                                                                   =>           \r\n        return base                                                                     =>           \r\n        return accumulate(lambda a, b: combiner(a, b) if pred(a) else b, base, n, term) =>           \r\n    else:                                                                               =>           \r\n        return combiner(term(base), accumulate(combiner, base, n+1, term))              <=           \r\n    return accumulate(lambda a, b: combiner(a, b) if pred(a) else b, base, n, term)     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(base), accumulate(combiner, base, n+1, term))        \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))        \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner, base, n+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner, base, n+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner, base, n+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner, base, n+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner, base, n+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner, base, n+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    if n == 0:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":184,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    72      =>           \r\n    73      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    73\n    \"\"\"\n    def accumulater(i):\n        if n == 0:\n            return base\n        if i < n:\n            return combiner(term(i), accumulater(i+1))\n        elif i == n:\n            return combiner(term(i), base)\n        return n\n    return accumulater(1)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulater(i):\n        if n == 0:\n            return base\n        if i < n:\n            return combiner(term(i), accumulater(i+1))\n        elif i == n:\n            return combiner(term(i), base)\n        return n\n    return accumulater(1)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    )), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","72","","# Error: expected","#     73","# but got","#     72","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":221,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    72      =>           \r\n            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    \n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = base\n    for num in range(1, n + 1):\n        total = combiner(total, term(num))\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = base\n    for num in range(1, n + 1):\n        total = combiner(total, term(num))\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    )), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","72","","# Error: expected","#     ","# but got","#     72","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":252,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    25      =>           \r\n    225     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    225\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\" \n    total = base\n    if n == 0: \n            return base  \n    while n >= 1:\n            total = combiner(total,term(n))\n            n -= 1\n    return total  \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\" \n    total = base\n    if n == 0: \n            return base  \n    while n >= 1:\n            total = combiner(total,term(n))\n            n -= 1\n    return total  \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    )), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25","","# Error: expected","#     225","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":567,"diff":"\r\nInputObject                                                      SideIndicator\r\n-----------                                                      -------------\r\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2  =>           \r\n    >>> accumulate(add, 11, 3, square)   t# 11 + 1^2 + 2^2 + 3^2 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   t# 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    total = term(k)\n    if n == 0:\n        return base\n    while k < n:\n        k, total = k + 1, combiner(total,term(k+1))\n    return combiner(base, total)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    total = term(k)\n    if n == 0:\n        return base\n    while k < n:\n        k, total = k + 1, combiner(total,term(k+1))\n    return combiner(base, total)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    )), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   t# 11 + 1^2 + 2^2 + 3^2","Traceback (most recent call last):","    accumulate(add, 11, 3, square)   t# 11 + 1^2 + 2^2 + 3^2","                                     ^","SyntaxError: invalid syntax","","# Error: expected","#     25","# but got","#     SyntaxError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":185,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    while i != n + 1: =>           \r\n    while i != n:     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    i, total = 1, base\n    while i != n:\n        total = combiner(term(i), total)\n        i+=1\n    return total\n\n\n    '''def helper(combiner, n, term):\n        if n == 2:\n            return combiner(term(2), term(1))\n        else:\n            value = helper(combiner, n - 1, term)\n            return combiner(term(n), value)\n    return combiner(helper(combiner, n, term), base)'''\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    i, total = 1, base\n    while i != n + 1:\n        total = combiner(term(i), total)\n        i+=1\n    return total\n\n\n    '''def helper(combiner, n, term):\n        if n == 2:\n            return combiner(term(2), term(1))\n        else:\n            value = helper(combiner, n - 1, term)\n            return combiner(term(n), value)\n    return combiner(helper(combiner, n, term), base)'''\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":186,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n    total=base                                =>           \r\n        total = combiner(total,term(counter)) =>           \r\n    return total                              =>           \r\n    total=0                                   <=           \r\n        total = combiner(base,term(counter))  <=           \r\n    return combiner(total,base)               <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\" \n    if n == 0:\n        return base\n\n    total=0\n    counter = 1\n\n    while counter <=n:\n        total = combiner(base,term(counter))\n        counter+=1\n\n    return combiner(total,base)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\" \n    if n == 0:\n        return base\n\n    total=base\n    counter = 1\n\n    while counter <=n:\n        total = combiner(total,term(counter))\n        counter+=1\n\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":187,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    tot = base                          =>           \r\n    i = 1                               =>           \r\n    while i <= n:                       =>           \r\n        tot = combiner(tot, term(i))    =>           \r\n        i+=1                            =>           \r\n    tot = term(base);                   <=           \r\n    base += 1                           <=           \r\n    while base <= n:                    <=           \r\n        tot = combiner(tot, term(base)) <=           \r\n        base+=1                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    tot = term(base);\n    base += 1\n    while base <= n:\n        tot = combiner(tot, term(base))\n        base+=1\n    return tot\n    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    tot = base\n    i = 1\n    while i <= n:\n        tot = combiner(tot, term(i))\n        i+=1\n    return tot\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-i), SingleChild(ReferenceNode(node, Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast)))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","11","","# Error: expected","#     26","# but got","#     11","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":188,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n        if n == 0:      =>           \r\n            return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def combine(combiner, n, term):\n        if n == 1:\n            return combiner(base, term(n))\n        else:\n            return combiner(term(n), combine(combiner, n-1, term))\n        \n    return combine(combiner, n, term)\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def combine(combiner, n, term):\n        if n == 1:\n            return combiner(base, term(n))\n        if n == 0:\n            return base\n        else:\n            return combiner(term(n), combine(combiner, n-1, term))\n        \n    return combine(combiner, n, term)\n    \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ReferenceNode(node, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), 0))), 0), Selected(\\x => Match(x, Node(FunctionDefinitionNode-combine, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), SingleChild(ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), 0)))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-combine, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-combine, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine","    return combiner(term(n), combine(combiner, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine","    return combiner(term(n), combine(combiner, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine","    return combiner(term(n), combine(combiner, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine","    return combiner(term(n), combine(combiner, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine","    return combiner(term(n), combine(combiner, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in combine","    return combiner(term(n), combine(combiner, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in combine","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":191,"diff":"\r\nInputObject                                                                                                             SideIndicator\r\n-----------                                                                                                             -------------\r\n    if n == 0:                                                                                                          =>           \r\n        return base                                                                                                     =>           \r\n    elif n == 1:                                                                                                        =>           \r\n        return combiner(term(1), base)                                                                                  =>           \r\n    else:                                                                                                               =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))                                                 =>           \r\n    return accumulate(add, 0, n, term)                                                                                  =>           \r\n    return accumulate(mul, 1, n, term)                                                                                  =>           \r\n    return accumulate(lambda a, b: combiner(a, b) if pred(a) else b, base, n, term)                                     =>           \r\n    if n == 1:                                                                                                          =>           \r\n        return f                                                                                                        =>           \r\n    elif n == 0:                                                                                                        =>           \r\n        return identity                                                                                                 =>           \r\n    else:                                                                                                               =>           \r\n        return compose1(f, repeated(f, n-1))                                                                            =>           \r\n    if n <= 3:                                                                                                          =>           \r\n        return n                                                                                                        =>           \r\n    else:                                                                                                               =>           \r\n        return g(n - 1) + 2 * g(n - 2) + 3 * g(n - 3)                                                                   =>           \r\n    if n <= 3:                                                                                                          =>           \r\n        return n                                                                                                        =>           \r\n        n_minus_1, n_minus_2, n_minus_3  = 3, 2, 1                                                                      =>           \r\n        k = 4                                                                                                           =>           \r\n        while k <= n:                                                                                                   =>           \r\n            n_minus_1, n_minus_2, n_minus_3 = n_minus_2, n_minus_1, n_minus_1 + 2*n_minus_2+ 3*n_minus_3                =>           \r\n            k = k + 1                                                                                                   =>           \r\n    return n_minus_1                                                                                                    =>           \r\n    def move(k, i, forward):                                                                                            =>           \r\n        if k == n:                                                                                                      =>           \r\n            return i                                                                                                    =>           \r\n        elif forward:                                                                                                   =>           \r\n            return change(k+1, i+1, forward) #it is looking for the k(th) term in the sequence, i moves between 0 and 7 =>           \r\n        else:                                                                                                           =>           \r\n            return change(k+1, i-1, forward)#if forward is true, i will be reduced                                      =>           \r\n    def change(k, i, forward):                                                                                          =>           \r\n        if k % 7 == 0 or has_seven(k):                                                                                  =>           \r\n            return move(k, i, not forward) #move down                                                                   =>           \r\n        else:                                                                                                           =>           \r\n            return move(k, i, forward) #move forward                                                                    =>           \r\n                                                                                                                        =>           \r\n    if n < 7:                                                                                                           =>           \r\n        return n                                                                                                        =>           \r\n    else:                                                                                                               =>           \r\n        return move(7,7, False)                                                                                         =>           \r\n    else:                                                                                                               =>           \r\nfrom math import *                                                                                                      =>           \r\n    def count(n, m):                                                                                                    =>           \r\n        if m == 1:                                                                                                      =>           \r\n            return 1                                                                                                    =>           \r\n        if n < 0:                                                                                                       =>           \r\n            return 0                                                                                                    =>           \r\n        with_m = count(n - m, m)                                                                                        =>           \r\n        without_m = count(n, m//2)                                                                                      =>           \r\n        return with_m + without_m                                                                                       =>           \r\n    return count(amount, 2**highest_power(amount))                                                                      =>           \r\n#this question was done using John Denero's Fall 2015 Lecture on recursion (lec 7), where he showed how yo sol          =>           \r\n    if n == 1:                                                                                                          =>           \r\n        return print_move(start,end)                                                                                    =>           \r\n    if start == 1 or end == 1:                                                                                          =>           \r\n        if start == 2 or end == 2:                                                                                      =>           \r\n            middle = 3                                                                                                  =>           \r\n    if start == 3 or end == 3:                                                                                          =>           \r\n        if start == 2 or end == 2:                                                                                      =>           \r\n            middle = 1                                                                                                  =>           \r\n    if start == 3 or end == 3:                                                                                          =>           \r\n        if start == 1 or end == 1:                                                                                      =>           \r\n            middle = 2                                                                                                  =>           \r\n    def move():                                                                                                         =>           \r\n        move_stack(n-1, start, middle)                                                                                  =>           \r\n        print_move(start, end)                                                                                          =>           \r\n        move_stack(n-1, middle, end)                                                                                    =>           \r\n    return move()                                                                                                       =>           \r\n                                                                                                                        =>           \r\n                                                                                                                        =>           \r\n    return _______                                                                                                      <=           \r\n    return _______                                                                                                      <=           \r\n    return _______                                                                                                      <=           \r\n    \"*** YOUR CODE HERE ***\"                                                                                            <=           \r\n    \"*** YOUR CODE HERE ***\"                                                                                            <=           \r\n    \"*** YOUR CODE HERE ***\"                                                                                            <=           \r\n    \"*** YOUR CODE HERE ***\"                                                                                            <=           \r\n    \"*** YOUR CODE HERE ***\"                                                                                            <=           \r\n    \"*** YOUR CODE HERE ***\"                                                                                            <=           \r\n    \"*** YOUR CODE HERE ***\"                                                                                            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0: \n        return base \n    elif n == 1: \n        return combiner(term(1), base)\n    else: \n        return combiner(term(n), accumulate(combiner, base, n-1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":192,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        b,k = combiner(b,term(k)), k+1    =>           \r\n        b,k = combiner(base,term(k)), k+1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k,b = 1, base\n    while k <= n:\n        b,k = combiner(base,term(k)), k+1\n    return b\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k,b = 1, base\n    while k <= n:\n        b,k = combiner(b,term(k)), k+1\n    return b\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-b)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":507,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        a = combiner(a, term(b)) =>           \r\n        a = combiner(a, term(i)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    a, b = base, 1\n    while b <= n:\n        a = combiner(a, term(i))\n        b = b + 1\n    return a\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    a, b = base, 1\n    while b <= n:\n        a = combiner(a, term(b))\n        b = b + 1\n    return a\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-b)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    a = combiner(a, term(i))","NameError: name 'i' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":193,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total = combiner(total, f(i))    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = base         \n    i = 1                  \n    while i <= n:\n        total = combiner(total, f(i))\n        i = i + 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = base         \n    i = 1                  \n    while i <= n:\n        total = combiner(total, term(i))\n        i = i + 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    total = combiner(total, f(i))","NameError: name 'f' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":225,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total = combiner(total, f(i))    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 1\n    while i <= n:\n        total = combiner(total, f(i))\n        i += 1\n    return total\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    total = combiner(total, f(i))","NameError: name 'f' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":194,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        return combiner(a,base) =>           \r\n        return a                <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    a = 0\n    while n > 1:\n        b = combiner(term(n),term(n-1))\n        a += b\n        n -= 2\n    if n == 1 : \n        a = combiner(a,combiner(base, term(1)))\n    if n == 0:\n        return a\n    return a\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    a = 0\n    while n > 1:\n        b = combiner(term(n),term(n-1))\n        a += b\n        n -= 2\n    if n == 1 : \n        a = combiner(a,combiner(base, term(1)))\n    if n == 0:\n        return combiner(a,base)\n    return a\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","0","","# Error: expected","#     11","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":195,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    while k <= n:                       =>           \r\n    return total                        =>           \r\n    if k <= n:                          <=           \r\n        return combiner(total, term(k)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    if k <= n:\n        total =  combiner(total, term(k))\n        k += 1\n        return combiner(total, term(k))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total =  combiner(total, term(k))\n        k += 1\n    return total\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), 0), SingleChild(ConstNode(SuiteStatementNode, Children(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), 0), SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), 0))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), 0), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","3","","# Error: expected","#     15","# but got","#     3","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":197,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    total = base                         =>           \r\n        total = combiner(total, term(i)) =>           \r\n    total = 0                            <=           \r\n        total = combiner(base, term(i))  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        total = combiner(base, term(i))\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n + 1):\n        total = combiner(total, term(i))\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":198,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    k=1          =>           \r\n    while k<n+1: =>           \r\n    k=0          <=           \r\n    while k<n:   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    k=0\n    partial_total=base\n    while k<n:\n        partial_total= combiner(partial_total,term(k))\n        k+=1\n    return partial_total\n\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    k=1\n    partial_total=base\n    while k<n+1:\n        partial_total= combiner(partial_total,term(k))\n        k+=1\n    return partial_total\n\n\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":199,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        total = combiner (total, term(k)) =>           \r\n                                          =>           \r\n        total = combiner (total, term(n)) <=           \r\n                                          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k , total = 1 , base \n    while n + 1 > k:\n        total = combiner (total, term(n))\n        k += 1\n    return total\n    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k , total = 1 , base \n    while n + 1 > k:\n        total = combiner (total, term(k))\n        k += 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":402,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        result = combiner(result, term(k)) =>           \r\n        result = combiner(result, term(n)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\"\"\"\n    result = base\n    k = 1\n    while k <= n:\n        result = combiner(result, term(n))\n        k += 1\n    return result\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\"\"\"\n    result = base\n    k = 1\n    while k <= n:\n        result = combiner(result, term(k))\n        k += 1\n    return result\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":202,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    '''number = 1                          =>           \r\n    for i in [1,n]:                        =>           \r\n    return combiner(base, number)'''       =>           \r\n    number = base                          =>           \r\n    for i in range(1, n+1):                =>           \r\n        number = combiner(number, term(i)) =>           \r\n    return number                          =>           \r\n                                           =>           \r\n                                           =>           \r\n    number = 1                             <=           \r\n    for i in [0, n]:                       <=           \r\n    return combiner(base, number)          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    number = 1\n    for i in [0, n]:\n        i += 1\n        number *= term(i)\n    return combiner(base, number)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n\n    '''number = 1\n    for i in [1,n]:\n        i += 1\n        number *= term(i)\n    return combiner(base, number)'''\n\n    number = base\n    for i in range(1, n+1):\n        number = combiner(number, term(i))\n    return number\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ExpressionStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-number = 1\n    for i in [1,n]:\n        i += 1\n        number *= term(i)\n    return combiner(base, number)))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ListExpressionNode, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-range), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(ListExpressionNode, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ListExpressionNode, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ListExpressionNode, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-number), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)))))))))), 0), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ListExpressionNode, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ListExpressionNode, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ListExpressionNode, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ListExpressionNode, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","6","","# Error: expected","#     15","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":203,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        total = combiner(total, term(k))  =>           \r\n        total = combiner(total + term(k)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k <= n:\n        total = combiner(total + term(k))\n        k += 1\n    return total","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 1), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    total = combiner(total + term(k))","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":205,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    return total(n) =>           \r\n    return total(1) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def total(m):\n        if m==0:\n            return base \n        else:\n            return combiner(term(m), total(m-1))\n    return total(1)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def total(m):\n        if m==0:\n            return base \n        else:\n            return combiner(term(m), total(m-1))\n    return total(n)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":217,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(1), accumulate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n\n    else:\n        return combiner(term(1), accumulate(combiner, base, n-1, term))\n\n\n    \n ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n    \n ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":524,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while x <= n: =>           \r\n                  =>           \r\n    while x <= 1: <=           \r\n                  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    total = base\n    x = 1\n    while x <= 1:\n        total = combiner(total, term(x))\n        x = x + 1\n    return total\n    \n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    total = base\n    x = 1\n    while x <= n:\n        total = combiner(total, term(x))\n        x = x + 1\n    return total\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":206,"diff":"\r\nInputObject                                                                SideIndicator\r\n-----------                                                                -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))    =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term(n))) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term(n)))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 101, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term(n)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 101, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term(n)))","TypeError: 'int' object is not callable","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":209,"diff":"\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n            return combiner(term(i), counter(i+1))  =>           \r\n    if n == 0:                                      =>           \r\n        return base                                 =>           \r\n    else:                                           =>           \r\n        return combiner(base, counter(1))           =>           \r\n            return combiner(term(i), counter(i+1))  <=           \r\n    return combiner(base, counter(1))               <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def counter(i):\n        \n        if i == n:\n            return term(i)\n        else:\n            return combiner(term(i), counter(i+1)) \n    return combiner(base, counter(1))   ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def counter(i):\n        \n        if i == n:\n            return term(i)\n        else:\n            return combiner(term(i), counter(i+1))\n    if n == 0:\n        return base\n    else:         \n        return combiner(base, counter(1))   ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-counter, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), 0)))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-counter, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-counter, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-counter, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter","    return combiner(term(i), counter(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter","    return combiner(term(i), counter(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter","    return combiner(term(i), counter(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter","    return combiner(term(i), counter(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter","    return combiner(term(i), counter(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in counter","    return combiner(term(i), counter(i+1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in counter","    if i == n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":212,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    return sum_function(n) =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def sum_function(n):\n        if n == 0:\n            return base\n        else:\n            n = n - 1\n            return combiner(term(n+1),sum_function(n))\n            \n        ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def sum_function(n):\n        if n == 0:\n            return base\n        else:\n            n = n - 1\n            return combiner(term(n+1),sum_function(n))\n    return sum_function(n)\n            \n        ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-sum_function), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(FunctionDefinitionNode-sum_function, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":214,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n            return base =>           \r\n        return base     =>           \r\n            return 0    <=           \r\n        return 0        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        if combiner == add:\n            return 0\n        return 0\n    else:\n        return combiner(term(n), accumulate(combiner,base,n-1,term))\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        if combiner == add:\n            return base\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner,base,n-1,term))\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":215,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n      return combiner (accumulate(combiner, base, n-1, term), term(n))  =>           \r\n      return accumulate(combiner, base, n-1, term)                      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #create a list that has all the values until n (including n)\n    \n    if n <= 0:\n      return base\n    else:\n      return accumulate(combiner, base, n-1, term) \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #create a list that has all the values until n (including n)\n    \n    if n <= 0:\n      return base\n    else:\n      return combiner (accumulate(combiner, base, n-1, term), term(n)) \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":506,"diff":"\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n        return combiner(accumulate(combiner, base, n-1,term), term(n)) =>           \r\n        return accumulate(combiner, base, n-1,term)                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, base, n-1,term)\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1,term), term(n))\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":562,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n        # (base, term(n))                                               =>           \r\n        return accumulate(combiner, base, n-1, term)                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, base, n-1, term)\n    # def base_sequence(combiner, n, term):\n    #     if n < 2:\n    #         return term (n)\n    #     else:\n    #         return combiner(term(n), base_sequence(combiner, n-1, term))\n    # return combiner(base, base_sequence(combiner, n, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n        # (base, term(n))\n    # def base_sequence(combiner, n, term):\n    #     if n < 2:\n    #         return term (n)\n    #     else:\n    #         return combiner(term(n), base_sequence(combiner, n-1, term))\n    # return combiner(base, base_sequence(combiner, n, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":223,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        elif n ==1:        =>           \r\n            return term(1) =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper_func1(n, term):\n        if n == 0:\n            return term(0)\n        else:\n            return combiner(term(n), helper_func1(n-1, term))\n    return combiner(base, helper_func1(n, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper_func1(n, term):\n        if n == 0:\n            return term(0)\n        elif n ==1:\n            return term(1)\n        else:\n            return combiner(term(n), helper_func1(n-1, term))\n    return combiner(base, helper_func1(n, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":228,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        if n == 0:                     =>           \r\n            return base                =>           \r\n        if i >= n:                     =>           \r\n    return help(1, term)               =>           \r\n    return accumulate(add, 0, n, term) =>           \r\n    return accumulate(mul, 1, n, term) =>           \r\n        if i == n:                     <=           \r\n    return help(0, term)               <=           \r\n    return _______                     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def help(i, term):\n        if i == n:\n            return combiner(base, term(i))\n        return combiner(term(i), help(i + 1, term))\n    return help(0, term)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def help(i, term):\n        if n == 0:\n            return base\n        if i >= n:\n            return combiner(base, term(i))\n        return combiner(term(i), help(i + 1, term))\n    return help(1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 0), Selected(\\x => Match(x, Node(FunctionDefinitionNode-help, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":230,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n        return combiner(term(n),accumulate(n-1))                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n),accumulate(n-1))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n),accumulate(n-1))","TypeError: accumulate() missing 3 required positional arguments: 'base', 'n', and 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":425,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumulate(n-1))                       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(n-1))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n), accumulate(n-1))","TypeError: accumulate() missing 3 required positional arguments: 'base', 'n', and 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":547,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return combiner(term(n), accumulate(n - 1))                       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(n - 1))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(term(n), accumulate(n - 1))","TypeError: accumulate() missing 3 required positional arguments: 'base', 'n', and 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":233,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    for i in range(1,n+1): =>           \r\n    for i in range(1,n-1): <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"def prtii(combiner,n,term):\n        if n <= 1:\n            return term(n)\n        return combiner(term(n), prtii(combiner, n-1, term))\n    return combiner(base, prtii(combiner,n,term))\"\"\"\n    total=base\n    for i in range(1,n-1):\n        total=combiner(total, term(i))\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"def prtii(combiner,n,term):\n        if n <= 1:\n            return term(n)\n        return combiner(term(n), prtii(combiner, n-1, term))\n    return combiner(base, prtii(combiner,n,term))\"\"\"\n    total=base\n    for i in range(1,n+1):\n        total=combiner(total, term(i))\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","6","","# Error: expected","#     15","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":234,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n        total, i = combiner(total, term(i)), i + 1 =>           \r\n        total = combiner(total, term(i))           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0: return base\n\n    total, i = base, 1\n    while i <= n:\n        total = combiner(total, term(i))\n    return total\n    \"\"\"if n == 1:\n        return combiner(term(n), base)\n    elif n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\"\"\"\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0: return base\n\n    total, i = base, 1\n    while i <= n:\n        total, i = combiner(total, term(i)), i + 1\n    return total\n    \"\"\"if n == 1:\n        return combiner(term(n), base)\n    elif n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\"\"\"\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(TupleExpressionNode-False, Children(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0), SingleChild(LeafConstNode(NameExpressionNode-i)))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(TupleExpressionNode-False, Children(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0), SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     15","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":236,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return base                                                     =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n                                                                        =>           \r\n        return                                                          <=           \r\n        return combiner(base, accumulate(combiner, base, n-1, term))    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return\n    else:\n        return combiner(base, accumulate(combiner, base, n-1, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-base), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(LeafWildcard(\"ReturnStatementNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(base, accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(base, accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(base, accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(base, accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner(base, accumulate(combiner, base, n-1, term))","TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":237,"diff":"\r\nInputObject                                                 SideIndicator\r\n-----------                                                 -------------\r\n    return reduce(combiner, map(term, range(1, n+1)), base) =>           \r\n                                                            =>           \r\n    \"*** YOUR CODE HERE ***\"                                <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    return reduce(combiner, map(term, range(1, n+1)), base)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-reduce), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-map), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-range), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))))))))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":238,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    return combiner(n, term(accumulate(combiner, base, n-1, term))) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    return combiner(n, term(accumulate(combiner, base, n-1, term)))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), 0)))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0), 2), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","221592999","","# Error: expected","#     25","# but got","#     221592999","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":241,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        return combiner(base, term(1))       =>           \r\n        return combiner(term(base), term(1)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return term(base)\n    elif n == 1:\n        return combiner(term(base), term(1))\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return term(base)\n    elif n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\"))))))), TChild(LeafWildcard(\"ArgNode\"))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\")))))), TChild(LeafWildcard(\"ArgNode\"))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ArgNode\"))))), 0), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\")))))), TChild(LeafWildcard(\"ArgNode\"))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":344,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    return combiner(base, helper())       =>           \r\n    return combiner(term(base), helper()) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i=1):\n        if i > n:\n            if combiner == mul:\n                return 1\n            else:\n                return 0\n        return combiner(term(i), helper(i+1))\n    return combiner(term(base), helper())\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i=1):\n        if i > n:\n            if combiner == mul:\n                return 1\n            else:\n                return 0\n        return combiner(term(i), helper(i+1))\n    return combiner(base, helper())\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"CallExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"CallExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"CallExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":407,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n    return accumulate_combiner(base, n)       =>           \r\n    return accumulate_combiner(term(base), n) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def accumulate_combiner(x, num):\n        if num == 0:\n            return x\n        else:\n            return accumulate_combiner(combiner(x, term(num)), num-1)\n    return accumulate_combiner(term(base), n)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def accumulate_combiner(x, num):\n        if num == 0:\n            return x\n        else:\n            return accumulate_combiner(combiner(x, term(num)), num-1)\n    return accumulate_combiner(base, n)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(LeafWildcard(\"ArgNode\"))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(LeafWildcard(\"ArgNode\"))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(LeafWildcard(\"ArgNode\"))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":596,"diff":"\r\nInputObject                                                                     SideIndicator\r\n-----------                                                                     -------------\r\n        return combiner(accumulate(combiner, base, n - 1, term), term(n))       =>           \r\n    return accumulate(add, 0, n, term)                                          =>           \r\n    return accumulate(mul, 1, n, term)                                          =>           \r\n        return combiner(term(accumulate(combiner, base, n - 1, term)), term(n)) <=           \r\n    return _______                                                              <=           \r\n    return _______                                                              <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(accumulate(combiner, base, n - 1, term)), term(n))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n - 1, term), term(n))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\"))))))), TChild(LeafWildcard(\"ArgNode\"))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\")))))), TChild(LeafWildcard(\"ArgNode\"))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ArgNode\"))))), 0), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\")))))), TChild(LeafWildcard(\"ArgNode\"))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","221652553","","# Error: expected","#     25","# but got","#     221652553","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":242,"diff":"\r\nInputObject                                                                 SideIndicator\r\n-----------                                                                 -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))     =>           \r\n    return _______                                                          =>           \r\n        if pred(n):                                                         <=           \r\n            return combiner(term(n), accumulate(combiner, base, n-1, term)) <=           \r\n    if not pred(n):                                                         <=           \r\n        return base                                                         <=           \r\n        return accumulate(combiner, base, n, term)                          <=           \r\n    else:                                                                   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n>0:\n        if pred(n):\n            return combiner(term(n), accumulate(combiner, base, n-1, term))\n    else:\n        return base\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n>0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    else:\n        return base\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), 0), 1), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if pred(n):","NameError: name 'pred' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":245,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n        if n >= 1 :   =>           \r\n        if n == True: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    result = base\n    while k <= n:\n        if n == True:\n            result = combiner(result, term(k))\n        k += 1\n    return result\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    result = base\n    while k <= n:\n        if n >= 1 :\n            result = combiner(result, term(k))\n        k += 1\n    return result\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":246,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    total, a = base, 1            =>           \r\n    return total                  =>           \r\n    total, a = 1, 1               <=           \r\n    return combiner(base,total-1) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, a = 1, 1\n    while a <= n:\n        total, a = combiner(total,term(a)), a+1\n    return combiner(base,total-1)","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, a = base, 1\n    while a <= n:\n        total, a = combiner(total,term(a)), a+1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"ConstantExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","70","","# Error: expected","#     72","# but got","#     70","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":247,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    elif(n == 0):      =>           \r\n        return term(n) =>           \r\n    elif(i == n):      <=           \r\n        return term(i) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if(n == 0):\n        return base\n    elif(i == n):\n        return term(i)\n    elif(combiner == mul):\n        return combiner(base, combiner(term(n), accumulate(combiner, 1, n - 1, term)))\n    else:\n        return combiner(base, combiner(term(n), accumulate(combiner, 0, n - 1, term)))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if(n == 0):\n        return base\n    elif(n == 0):\n        return term(n)\n    elif(combiner == mul):\n        return combiner(base, combiner(term(n), accumulate(combiner, 1, n - 1, term)))\n    else:\n        return combiner(base, combiner(term(n), accumulate(combiner, 0, n - 1, term)))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    elif(i == n):","NameError: name 'i' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":248,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        base=combiner(base,term(count))  =>           \r\n    return base                          =>           \r\n        final=combiner(base,term(count)) <=           \r\n    return final                         <=           \r\n    final=base                           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"count=1\n    final=base\n    if n==0:\n        return base\n    while count< n+1:\n        if combiner==add:\n            final+=term(count)\n            count+=1\n        elif combiner==mul:\n            final*=term(count)\n            count+=1\n    return final\"\"\"\n\n    count=1\n    final=base\n    while count< n+1:\n        final=combiner(base,term(count))\n        count+=1\n    return final\n\n    \n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"count=1\n    final=base\n    if n==0:\n        return base\n    while count< n+1:\n        if combiner==add:\n            final+=term(count)\n            count+=1\n        elif combiner==mul:\n            final*=term(count)\n            count+=1\n    return final\"\"\"\n\n    count=1\n    while count< n+1:\n        base=combiner(base,term(count))\n        count+=1\n    return base \n\n    \n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":249,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        finalResult = combiner(finalResult,term(i))  =>           \r\n        finalProduct = combiner(finalResult,term(i)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = n\n    if combiner == mul:\n        finalResult = 1\n    elif combiner == add:\n        finalResult = 0\n    \n    while i != 0:\n        finalProduct = combiner(finalResult,term(i))\n        i -= 1\n    return combiner(finalResult, base)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = n\n    if combiner == mul:\n        finalResult = 1\n    elif combiner == add:\n        finalResult = 0\n    \n    while i != 0:\n        finalResult = combiner(finalResult,term(i))\n        i -= 1\n    return combiner(finalResult, base)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-finalResult)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":250,"diff":"\r\nInputObject                                                SideIndicator\r\n-----------                                                -------------\r\n    def count_comber(x):                                   =>           \r\n            return base                                    =>           \r\n            return combiner(term(x), count_comber(x+1))    =>           \r\n    return count_comber(1)                                 =>           \r\n    def count_comber(x, b):                                <=           \r\n            return combiner(base, b)                       <=           \r\n            return combiner(term(x), count_comber(x+1, b)) <=           \r\n    return count_comber(1, 0)                              <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def count_comber(x, b):\n        if x == n+1:\n            return combiner(base, b)\n        else:\n            return combiner(term(x), count_comber(x+1, b))\n    return count_comber(1, 0)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def count_comber(x):\n        if x == n+1:\n            return base\n        else:\n            return combiner(term(x), count_comber(x+1))\n    return count_comber(1)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(FunctionDefinitionNode-count_comber, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(Target(LeafWildcard(\"ParameterNode\")), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(FunctionDefinitionNode-count_comber, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":251,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n        x = combiner(x, term(y))  =>           \r\n        x *= combiner(x, term(y)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x, y = base, 1\n    while y <= n:\n        x *= combiner(x, term(y))\n        y += 1\n    return x\n    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x, y = base, 1\n    while y <= n:\n        x = combiner(x, term(y))\n        y += 1\n    return x\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0), SingleChild(ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":253,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    if n == 0:                           =>           \r\n        return base                      =>           \r\n        total = combiner(term(n), total) =>           \r\n    if n == 1:                           <=           \r\n        return 1                         <=           \r\n        total = combiner(term(n), base)  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    if n == 1:\n        return 1\n    else:\n        total = combiner(term(n), base)\n        return accumulate(combiner, total, n-1, term)","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    if n == 0:\n        return base\n    else:\n        total = combiner(term(n), total)\n        return accumulate(combiner, total, n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":255,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n        n -= 1 =>           \r\n        n += 1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result = base\n    while n > 0:\n        result =  combiner(result, term(n))\n        n += 1\n    return result\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result = base\n    while n > 0:\n        result =  combiner(result, term(n))\n        n -= 1\n    return result\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatementNode-Subtract, Children(ReferenceNode(node, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))), TChild(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     15","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":573,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n        n -= 1 =>           \r\n        n += 1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    while n > 0:\n        x = combiner(term(n), x)\n        n += 1\n    return x\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    while n > 0:\n        x = combiner(term(n), x)\n        n -= 1\n    return x\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatementNode-Subtract, Children(ReferenceNode(node, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))), TChild(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     15","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":257,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        amount = combiner(amount, term(x)) =>           \r\n        combiner(amount, term(x))          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    amount = base\n    x = 1\n    while x <= n:\n        combiner(amount, term(x))\n        x +=1\n    return amount\n\n    \"\"\"if n<1:\n        return base\n    else:\n        return combiner(n, accumulate(combiner, base, n-1, term))\"\"\"\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    amount = base\n    x = 1\n    while x <= n:\n        amount = combiner(amount, term(x))\n        x +=1\n    return amount\n\n    \"\"\"if n<1:\n        return base\n    else:\n        return combiner(n, accumulate(combiner, base, n-1, term))\"\"\"\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-amount), SingleChild(ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":258,"diff":"\r\nInputObject                                                           SideIndicator\r\n-----------                                                           -------------\r\n    if n == 0:                                                        =>           \r\n        return base                                                   =>           \r\n    return accumulate(combiner, combiner(term(n), base), n - 1, term) =>           \r\n    return k                                                          =>           \r\n    def helper(combiner, n, term):                                    <=           \r\n        current, next = term(1), term(2)                              <=           \r\n        while n > 0:                                                  <=           \r\n            total += term(n)                                          <=           \r\n            n -= 1                                                    <=           \r\n            return total                                              <=           \r\n    return combiner(base, helper(combiner, n, term))                  <=           \r\n    outcomes = []                                                     <=           \r\n        k = 1                                                         <=           \r\n        outcomes.append(k)                                            <=           \r\n    return outcomes[n + 1]                                            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n == 0: \n    #     return base \n    # if combiner == mul:\n    #     total = 1\n    # if combiner == add:\n    #     total = 0\n    # counter = 1\n    # while counter <= n: \n    #     total = combiner(total, term(counter))\n    #     counter += 1 \n    # return combiner(base, total)   \n    def helper(combiner, n, term):\n        current, next = term(1), term(2) \n        while n > 0: \n            total += term(n)\n            n -= 1\n            return total\n    return combiner(base, helper(combiner, n, term)) \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n == 0: \n    #     return base \n    # if combiner == mul:\n    #     total = 1\n    # if combiner == add:\n    #     total = 0\n    # counter = 1\n    # while counter <= n: \n    #     total = combiner(total, term(counter))\n    #     counter += 1 \n    # return combiner(base, total)   \n    if n == 0:\n        return base\n    return accumulate(combiner, combiner(term(n), base), n - 1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Equals, Children(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Target(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)))), SingleChild(ReferenceNode(node, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)))), SingleChild(ReferenceNode(node, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0))))))), Selected(\\x => Match(x, Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), 0), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-accumulate)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)))))), 1), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), 3), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast)))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 87, in accumulate","    return combiner(base, helper(combiner, n, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 84, in helper","    total += term(n)","UnboundLocalError: local variable 'total' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":259,"diff":"\r\nInputObject                                                        SideIndicator\r\n-----------                                                        -------------\r\n            return term(n) + accumulate(combiner, base, n-1, term) =>           \r\n            return term(n) * accumulate(combiner, base, n-1, term) =>           \r\n            return n + accumulate(combiner, base, n-1, term)       <=           \r\n            return n * accumulate(combiner, base, n-1, term)       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        if combiner == add:\n            return n + accumulate(combiner, base, n-1, term)\n        else:\n            return n * accumulate(combiner, base, n-1, term)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        if combiner == add:\n            return term(n) + accumulate(combiner, base, n-1, term)\n        else:\n            return term(n) * accumulate(combiner, base, n-1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":260,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    k = 1                                =>           \r\n    total = base                         =>           \r\n    if n == 0:                           =>           \r\n        return base                      =>           \r\n    while k <= n:                        =>           \r\n        total = combiner(total, term(k)) =>           \r\n        k += 1                           =>           \r\n    total = start                        <=           \r\n    for i in range(n):                   <=           \r\n        total = combiner(total, f(i+1))  <=           \r\n                                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = start\n    for i in range(n):\n        total = combiner(total, f(i+1))\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 1\n    total = base\n    if n == 0:\n        return base\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ForStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Target(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-k), SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0))))), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-k), SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)))), SingleChild(ReferenceNode(node, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Target(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    total = start","NameError: name 'start' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":262,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n    total, x = term(1), 1                    =>           \r\n    while x < n :                            =>           \r\n        total = combiner(total, term(x + 1)) =>           \r\n        x += 1                               =>           \r\n    if n == 0:                               =>           \r\n        total = 0                            =>           \r\n    return combiner(base, total)             =>           \r\n                                             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, x = term(1), 1\n    while x < n :\n        total = combiner(total, term(x + 1))\n        x += 1\n    if n == 0:\n        total = 0\n    return combiner(base, total)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(NameExpressionNode-x)))), SingleChild(ConstNode(TupleExpressionNode-False, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-LessThan, Children(LeafConstNode(NameExpressionNode-x), SingleChild(LeafConstNode(NameExpressionNode-n)))), SingleChild(ConstNode(SuiteStatementNode, Children(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-x), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))))))))))), SingleChild(ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-x), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(ConstantExpressionNode-0))))))))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))))))))), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":263,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(base, accumulate(combiner, base, n-1, term))    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(base, accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":264,"diff":"\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))  =>           \r\n        new_base = combiner(base, term(n))                               <=           \r\n        return combiner(base, accumulate(combiner, new_base, n-1, term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        new_base = combiner(base, term(n))\n        return combiner(base, accumulate(combiner, new_base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0), Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0))))))), 0), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","41","","# Error: expected","#     15","# but got","#     41","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":265,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    if n > 1:        =>           \r\n    elif n == 1:     =>           \r\n        return base  =>           \r\n    if n != 1:       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n != 1:\n        output = accumulate(combiner, base, n-1, term)\n        return combiner(output, term(n))\n    else:\n        return combiner(base, term(1))\n\n    \"\"\"\n    if n == 1:\n        return term(1)\n    elif n \n    else: \n        output = combiner(output, term(n))\n        return combiner(output, accumulate(combiner, base, n-1, term))\n    \"\"\"\n\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n > 1:\n        output = accumulate(combiner, base, n-1, term)\n        return combiner(output, term(n))\n    elif n == 1:\n        return combiner(base, term(1))\n    else:\n        return base \n\n    \"\"\"\n    if n == 1:\n        return term(1)\n    elif n \n    else: \n        output = combiner(output, term(n))\n        return combiner(output, accumulate(combiner, base, n-1, term))\n    \"\"\"\n\n\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-NotEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), 0)))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base))))), 2), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    output = accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    output = accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    output = accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    output = accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    output = accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    output = accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    if n != 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":266,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    return combiner(result, base) =>           \r\n    return result + base          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        result = 0\n    else:\n        counter = 2\n        result = term(1)\n        while counter <= n:\n            result = combiner(result, term(counter))\n            counter += 1\n    return result + base\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        result = 0\n    else:\n        counter = 2\n        result = term(1)\n        while counter <= n:\n            result = combiner(result, term(counter))\n            counter += 1\n    return combiner(result, base)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":380,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    return combiner(base, total) =>           \r\n    return base + total          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    if combiner == add:\n        total = 0\n    elif combiner == mul:\n        total = 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return base + total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    if combiner == add:\n        total = 0\n    elif combiner == mul:\n        total = 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return combiner(base, total)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":268,"diff":"\r\nInputObject                                                           SideIndicator\r\n-----------                                                           -------------\r\n    # mapped = (list(map(lambda x: term(x), list(range(1, n + 1))))   =>           \r\n    # count = 0                                                       =>           \r\n    # accu_res = base                                                 =>           \r\n    # while count < len(mapped):                                      =>           \r\n    #     accu_res = combiner(accu_res, mapped[count])                =>           \r\n    #     count += 1                                                  =>           \r\n    # return accu_res                                                 =>           \r\n    mapped = (list(map(lambda x: term(x), list(range(1, n + 1)))))    =>           \r\n    count = 0                                                         =>           \r\n    while count < len(mapped):                                        =>           \r\n            accu_res = combiner(accu_res, mapped[count])              =>           \r\n            count += 1                                                =>           \r\n                                                                      =>           \r\n    mapped = (list(map(lambda x: term(x), list(range(1, n + 1)))), 0) <=           \r\n    i = 0                                                             <=           \r\n    while i < len(mapped):                                            <=           \r\n        accu_res = combiner(accu_res, mapped[0])                      <=           \r\n        i += 1                                                        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    mapped = (list(map(lambda x: term(x), list(range(1, n + 1)))), 0)\n    i = 0 \n    accu_res = base\n    while i < len(mapped):\n        accu_res = combiner(accu_res, mapped[0])\n        i += 1\n    return accu_res\n    \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # mapped = (list(map(lambda x: term(x), list(range(1, n + 1))))\n    # count = 0 \n    # accu_res = base\n    # while count < len(mapped):\n    #     accu_res = combiner(accu_res, mapped[count])\n    #     count += 1\n    # return accu_res\n    mapped = (list(map(lambda x: term(x), list(range(1, n + 1)))))\n    count = 0 \n    accu_res = base\n    while count < len(mapped):\n    \t\taccu_res = combiner(accu_res, mapped[count])\n    \t\tcount += 1\n    return accu_res\n    \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(FunctionDefinitionNode-<lambda$3970>, Children(ReferenceNode(node, Node(FunctionDefinitionNode-<lambda$3969>, TChildren(Target(LeafWildcard(\"ParameterNode\")), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0), SingleChild(ReferenceNode(node, Node(FunctionDefinitionNode-<lambda$3969>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0))))), Selected(\\x => Match(x, Node(LambdaExpressionNode, TChild(Target(Node(FunctionDefinitionNode-<lambda$3969>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(LambdaExpressionNode, TChild(Node(FunctionDefinitionNode-<lambda$3969>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))))), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(LambdaExpressionNode, TChild(Node(FunctionDefinitionNode-<lambda$3969>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ParenthesisExpressionNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-list), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-map), Children(ConstNode(ArgNode, SingleChild(ConstNode(LambdaExpressionNode, SingleChild(ConstNode(FunctionDefinitionNode-<lambda$3970>, Children(ReferenceNode(node, Node(FunctionDefinitionNode-<lambda$3969>, TChildren(Target(LeafWildcard(\"ParameterNode\")), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0), SingleChild(ReferenceNode(node, Node(FunctionDefinitionNode-<lambda$3969>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-list), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-range), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))))))))))))))))))), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(LambdaExpressionNode, TChild(Node(FunctionDefinitionNode-<lambda$3969>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-count)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-count)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-count)), Selected(\\x => Match(x, Node(IndexExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-count)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast)))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 79, in accumulate","    accu_res = combiner(accu_res, mapped[0])","TypeError: unsupported operand type(s) for +: 'int' and 'list'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":275,"diff":"\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n    if n == 0:                                      =>           \r\n        return base                                 =>           \r\n        return combiner(base, accumulate_helper(1)) =>           \r\n    else:                                           =>           \r\n    return combiner(base, accumulate_helper(0))     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulate_helper(num):\n        if num == n:\n            return term(num)\n        else:\n            return combiner(term(num),accumulate_helper(num+1))\n    return combiner(base, accumulate_helper(0))\n    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulate_helper(num):\n        if num == n:\n            return term(num)\n        else:\n            return combiner(term(num),accumulate_helper(num+1))\n    if n == 0:\n        return base\n    else:\n        return combiner(base, accumulate_helper(1))\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-accumulate_helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), 0)))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-accumulate_helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-accumulate_helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-accumulate_helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":276,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n == 0:                         =>           \r\n        return combiner(term(0), base) =>           \r\n    elif n == 1:                       =>           \r\n    if n == 1:                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return combiner(term(0), base)\n    elif n == 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-0)))))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":278,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    return total =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for k in range(1, n + 1):\n        total = combiner(total, term(k))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for k in range(1, n + 1):\n        total = combiner(total, term(k))\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":279,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        if k == n+1: =>           \r\n        if k == n:   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(k,total=base):\n        if n==1:\n            return base + 1\n        if k == n:\n            return total\n        if k >= 1: \n            total = combiner(total,term(k))\n            return helper(k+1,total)\n    return helper(1,base)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(k,total=base):\n        if n==1:\n            return base + 1\n        if k == n+1:\n            return total\n        if k >= 1: \n            total = combiner(total,term(k))\n            return helper(k+1,total)\n    return helper(1,base)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":280,"diff":"\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n        return combiner(total, base) =>           \r\n        return total                 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    index = 1\n    total = term(index)\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(n), base)\n    else:\n        next_term = lambda index: term(index+1)\n        while index < n:\n            total = combiner(total, next_term(index))\n            index +=1\n        return total\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    index = 1\n    total = term(index)\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(n), base)\n    else:\n        next_term = lambda index: term(index+1)\n        while index < n:\n            total = combiner(total, next_term(index))\n            index +=1\n        return combiner(total, base)\n\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(FunctionDefinitionNode-<lambda$4711>, Children(ReferenceNode(node, Node(FunctionDefinitionNode-<lambda$4710>, TChildren(Target(LeafWildcard(\"ParameterNode\")), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), 0), SingleChild(ReferenceNode(node, Node(FunctionDefinitionNode-<lambda$4710>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), 0))))), Selected(\\x => Match(x, Node(LambdaExpressionNode, TChild(Target(Node(FunctionDefinitionNode-<lambda$4710>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(LambdaExpressionNode, TChild(Node(FunctionDefinitionNode-<lambda$4710>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(LambdaExpressionNode, TChild(Node(FunctionDefinitionNode-<lambda$4710>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":281,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        x = combiner(x,term(i)) =>           \r\n    return x                    =>           \r\n                                =>           \r\n        t = combiner(t,term(i)) <=           \r\n    return t                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x,i = base, 1\n    while i <= n:\n        t = combiner(t,term(i))\n        i += 1\n    return t","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x,i = base, 1\n    while i <= n:\n        x = combiner(x,term(i))\n        i += 1\n    return x\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-x)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-x)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-x)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    t = combiner(t,term(i))","UnboundLocalError: local variable 't' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":282,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return combiner(n, accumulate(combiner, base, n - 1, term))       <=           \r\n    \"*** YOUR CODE HERE ***\"                                              <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(n, accumulate(combiner, base, n - 1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":283,"diff":"\r\nInputObject                                            SideIndicator\r\n-----------                                            -------------\r\n    return accumulater(combiner, base, n, term, total) =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    def accumulater(combiner, base, n, term, total):\n        if n > 0:\n            total = combiner(total, term(n))\n            return accumulater(combiner, base, n-1, term, total)\n        else:\n            return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    def accumulater(combiner, base, n, term, total):\n        if n > 0:\n            total = combiner(total, term(n))\n            return accumulater(combiner, base, n-1, term, total)\n        else:\n            return total\n    return accumulater(combiner, base, n, term, total)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulater), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total)))))))))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(FunctionDefinitionNode-accumulater, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":286,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    while n>k:  =>           \r\n    while n>=k: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total=combiner(base,term(n))\n    k=1\n    while n>=k:\n        total=combiner(total, term(n-1))\n        n-=1\n    return total\n    \"\"\"if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(base,accumulate(combiner,base,n-1,term))\n    k=1\n    total=base+term(k)\n    if n==0:\n        return base\n    while k<n:\n        total=combiner(total, term(k+1))\n        k+=1\n    return total\"\"\"    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total=combiner(base,term(n))\n    k=1\n    while n>k:\n        total=combiner(total, term(n-1))\n        n-=1\n    return total\n    \"\"\"if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        return combiner(base,accumulate(combiner,base,n-1,term))\n    k=1\n    total=base+term(k)\n    if n==0:\n        return base\n    while k<n:\n        total=combiner(total, term(k+1))\n        k+=1\n    return total\"\"\"    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":288,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n            if term == identity:  =>           \r\n                base *= i         =>           \r\n            elif term == square:  =>           \r\n                base *= square(i) =>           \r\n            if term == identity:  =>           \r\n                base += i         =>           \r\n            elif term == square:  =>           \r\n                base += square(i) =>           \r\n            base *= i             <=           \r\n            base += i             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = base\n    for i in range(1, n+1):\n        if combiner == mul:\n            base *= i\n        elif combiner == add:\n            base += i\n    return base\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = base\n    for i in range(1, n+1):\n        if combiner == mul:\n            if term == identity:\n                base *= i\n            elif term == square:\n                base *= square(i)\n        elif combiner == add:\n            if term == identity:\n                base += i\n            elif term == square:\n                base += square(i)\n    return base\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-square), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(SuiteStatementNode, SingleChild(ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-term), SingleChild(LeafConstNode(NameExpressionNode-identity)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AugmentedAssignStatementNode-Multiply, Children(LeafConstNode(NameExpressionNode-base), SingleChild(LeafConstNode(NameExpressionNode-i))))))))), SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-term), SingleChild(LeafConstNode(NameExpressionNode-square)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AugmentedAssignStatementNode-Multiply, Children(LeafConstNode(NameExpressionNode-base), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-square), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))))))))))))))))), 1), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-square), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(SuiteStatementNode, SingleChild(ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-term), SingleChild(LeafConstNode(NameExpressionNode-identity)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-base), SingleChild(LeafConstNode(NameExpressionNode-i))))))))), SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-term), SingleChild(LeafConstNode(NameExpressionNode-square)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-base), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-square), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))))))))))))))))), 1), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":290,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    if n==1:                  <=           \r\n        return term(n) + base <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    if n==1:\n        return term(n) + base\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":291,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return base                                                     =>           \r\n        return combiner(term(n),accumulate(combiner, base, n-1, term))  =>           \r\n    return accumulate(add, 1, n, term)                                  =>           \r\n        return combiner(n, term)                                        <=           \r\n        return accumulate(combiner, base, n-1, term)                    <=           \r\n    return _______                                                      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return combiner(n, term)\n    else:\n        return accumulate(combiner, base, n-1, term) \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term)) \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return accumulate(combiner, base, n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(n, term)","TypeError: unsupported operand type(s) for +: 'int' and 'function'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":292,"diff":"\r\nInputObject                                                                   SideIndicator\r\n-----------                                                                   -------------\r\ndef accumulate(combiner, base, n, term):###############                       =>           \r\n    total, i = base, 1                                                        =>           \r\n    while i <= n:                                                             =>           \r\n        total, i = combiner(total, term(i)) , i+1                             =>           \r\n    return total                                                              =>           \r\ndef summation_using_accumulate(n, term):##############                        =>           \r\ndef filtered_accumulate(combiner, base, pred, n, term):###################### =>           \r\ndef accumulate(combiner, base, n, term):                                      <=           \r\n    ret = 1                                                                   <=           \r\n    for i in range(1, n + 1, 1):                                              <=           \r\n        ret = combiner(ret, term(i))                                          <=           \r\n    return ret                                                                <=           \r\ndef summation_using_accumulate(n, term):                                      <=           \r\ndef filtered_accumulate(combiner, base, pred, n, term):                       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    ret = 1\n    for i in range(1, n + 1, 1):\n        ret = combiner(ret, term(i))\n    return ret\n","after":"def accumulate(combiner, base, n, term):###############\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, i = base, 1\n    while i <= n:\n        total, i = combiner(total, term(i)) , i+1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(NameExpressionNode-i)))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-base), SingleChild(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ForStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-i), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0))))), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(NameExpressionNode-i)))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(TupleExpressionNode-False, Children(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0), SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-i), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(NameExpressionNode-i)))), SingleChild(ConstNode(TupleExpressionNode-False, Children(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0), SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))))))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":295,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n        base = combiner(base, term(n)) =>           \r\n    return base                        =>           \r\n        num = combiner(base, term(n))  <=           \r\n    return num                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while n >= 1:\n        num = combiner(base, term(n))\n        n -= 1\n    return num\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while n >= 1:\n        base = combiner(base, term(n))\n        n -= 1\n    return base\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":296,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n            total = total + term(c) =>           \r\n        total = total + base        =>           \r\n            combiner(total,term(c)) <=           \r\n        combiner(total,base)        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    c = 1\n    if combiner==add:\n        total = 0\n        while c <= n:\n            combiner(total,term(c))\n            c = c + 1\n        combiner(total,base)\n    else:\n        total = 1\n        while c <= n:\n            total = total * term(c)\n            c = c + 1\n        total = total * base\n    return total","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    c = 1\n    if combiner==add:\n        total = 0\n        while c <= n:\n            total = total + term(c)\n            c = c + 1\n        total = total + base\n    else:\n        total = 1\n        while c <= n:\n            total = total * term(c)\n            c = c + 1\n        total = total * base\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0))))), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)))))))), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0))))), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)))))))), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Target(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), 2), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":297,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, k = base, 1 =>           \r\n    total, k = 1       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    '''    if n==0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n    '''\n\n    total, k = 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    '''    if n==0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n    '''\n\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-base), SingleChild(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    total, k = 1","TypeError: 'int' object is not iterable","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":298,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n                                                                    =>           \r\n        return base                                                 =>           \r\n        return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n    result = combiner(base,term(n))                                 <=           \r\n        return result                                               <=           \r\n        return combiner(result,accumulate(combiner,base,n-1,term))  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result = combiner(base,term(n))\n    \n    if n==0:\n    \treturn result\n\n    else:\n    \treturn combiner(result,accumulate(combiner,base,n-1,term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    \n    if n==0:\n    \treturn base\n\n    else:\n    \treturn combiner(term(n),accumulate(combiner,base,n-1,term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","81","","# Error: expected","#     26","# but got","#     81","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":299,"diff":"\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n    if n==0:                                                           =>           \r\n        return base                                                    =>           \r\n        return combiner(term(n),accumulate(combiner, base, n-1, term)) =>           \r\n    else:                                                              =>           \r\n    def accumulateHelp(count):                                         <=           \r\n        if count==n+1:                                                 <=           \r\n            return base                                                <=           \r\n        return combiner(term(count), accumulateHelp(count+1))          <=           \r\n    return accumulateHelp(0)                                           <=           \r\n                                                                       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulateHelp(count):\n        if count==n+1:\n            return base\n        return combiner(term(count), accumulateHelp(count+1))\n\n    return accumulateHelp(0)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 1), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulateHelp, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0), 0), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulateHelp, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(IfStatementNode, Children(ReferenceNode(node, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))))))))))))), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulateHelp, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(FunctionDefinitionNode-accumulateHelp, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-accumulateHelp, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(FunctionDefinitionNode-accumulateHelp, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))), 0), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-accumulateHelp, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-accumulateHelp, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-accumulateHelp, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), InOrderSort(ast)))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":300,"diff":"\r\nInputObject                                                 SideIndicator\r\n-----------                                                 -------------\r\n        if n == 0:                                          =>           \r\n            return 0                                        =>           \r\n    return combiner(term_combiner(combiner, 1, term), base) =>           \r\n    return combiner(term_combiner(combiner, 0, term), base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    term_counter = 0\n    def term_combiner(combiner, term_counter, term):\n        if term_counter == n:\n            return term(term_counter)\n        return combiner(term_combiner(combiner, term_counter+1, term), term(term_counter))\n    return combiner(term_combiner(combiner, 0, term), base)","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    term_counter = 0\n    def term_combiner(combiner, term_counter, term):\n        if n == 0:\n            return 0\n        if term_counter == n:\n            return term(term_counter)\n        return combiner(term_combiner(combiner, term_counter+1, term), term(term_counter))\n    return combiner(term_combiner(combiner, 1, term), base)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-0)))))))))), 0), Selected(\\x => Match(x, Node(FunctionDefinitionNode-term_combiner, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":301,"diff":"\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n    if n<2:  =>           \r\n    if n==0: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n    \n    \n    \n    \n    \n        \n        ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n<2:\n        return combiner(term(n),base)\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n    \n    \n    \n    \n    \n        \n        ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-2)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-2))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":302,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n    if n == 0:                                                            =>           \r\n        return base                                                       =>           \r\n        return accumulate(combiner, combiner(base, term(n)), n - 1, term) =>           \r\n    else:                                                                 =>           \r\n                                                                          =>           \r\n    def accumulator(x, total):                                            <=           \r\n        if x > n:                                                         <=           \r\n            return total                                                  <=           \r\n        else:                                                             <=           \r\n            return accumulator(x + 1, combiner(total, term(x)))           <=           \r\n    return accumulator(2, combiner(base, term(1)))                        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulator(x, total):\n        if x > n:\n            return total\n        else:\n            return accumulator(x + 1, combiner(total, term(x)))\n    return accumulator(2, combiner(base, term(1)))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n - 1, term)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-GreaterThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-accumulate)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), 3), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(FunctionDefinitionNode-accumulator, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-accumulator, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), 0), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-accumulator, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-accumulator, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-accumulator, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))))))))))), InOrderSort(ast)))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":304,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while k <= n: =>           \r\n    while k < n:  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\" \n    k = 1\n    total = base\n    if n == 0:\n        return base\n    while k < n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\" \n    k = 1\n    total = base\n    if n == 0:\n        return base\n    while k <= n:\n        total, k = combiner(total, term(k)), k + 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(LeafWildcard(\"SuiteStatementNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":437,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    while count <= n: =>           \r\n                      =>           \r\n    while count < n:  <=           \r\n                      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    count = 1\n    answer = base\n\n    while count < n:\n        answer = combiner(answer, term(count) )\n        count +=1\n        \n    return answer\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    count = 1\n    answer = base\n\n    while count <= n:\n        answer = combiner(answer, term(count) )\n        count +=1\n\n    return answer\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(LeafWildcard(\"SuiteStatementNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":305,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    if combiner == add:          =>           \r\n        return base + helper(1)  =>           \r\n        return base * helper(1)  =>           \r\n    else:                        =>           \r\n    return base * helper(1)      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(k):\n        if combiner == add:\n            if n == 0: \n                return 0\n            elif k < n: \n                return term(k) + helper(k + 1) \n            else:\n                return term(k) \n        if combiner == mul:\n            if n == 0:\n                return 0\n            elif k < n:\n                return term(k) * helper(k + 1)\n            else: \n                return term(k)\n    return base * helper(1) \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(k):\n        if combiner == add:\n            if n == 0: \n                return 0\n            elif k < n: \n                return term(k) + helper(k + 1) \n            else:\n                return term(k) \n        if combiner == mul:\n            if n == 0:\n                return 0\n            elif k < n:\n                return term(k) * helper(k + 1)\n            else: \n                return term(k)\n    if combiner == add:\n        return base + helper(1)\n    else:\n        return base * helper(1) \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-combiner), SingleChild(LeafConstNode(NameExpressionNode-add)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-base), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-helper), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), 0)))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":306,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n    i = 1                                    =>           \r\n    while i <= n:                            =>           \r\n        total = combiner(total,  term(i))    =>           \r\n        i += 1                               =>           \r\n    while base <= n:                         <=           \r\n        total = combiner(total,  term(base)) <=           \r\n        base += 1                            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    while base <= n:\n        total = combiner(total,  term(base))\n        base += 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 1\n    while i <= n:\n        total = combiner(total,  term(i))\n        i += 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","11","","# Error: expected","#     26","# but got","#     11","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":307,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n    elif n==0:      =>           \r\n                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==1:\n        return combiner(base,term(1))\n    else:\n        \n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==1:\n        return combiner(base,term(1))\n    elif n==0:\n        return base\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner,base,n-1,term),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner,base,n-1,term),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner,base,n-1,term),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner,base,n-1,term),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner,base,n-1,term),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(accumulate(combiner,base,n-1,term),term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    if n==1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":308,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    return combiner(term(n)), accumulate(combiner, base, n-1, term) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n == 0:\n        return base\n    return combiner(term(n)), accumulate(combiner, base, n-1, term)\n\n    # if n == 0 and combiner == mul:\n    #     return combiner(term(1), base)\n    # elif n == 0:\n    #     return combiner(term(0), base)\n    # return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n    # if n == 0 and combiner == mul:\n    #     return combiner(term(1), base)\n    # elif n == 0:\n    #     return combiner(term(0), base)\n    # return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0), Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner(term(n)), accumulate(combiner, base, n-1, term)","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":310,"diff":"\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n    if n == 1:                                                           =>           \r\n        return product(n-1, term) * term(n)                              =>           \r\n    return product(n, identity)                                          =>           \r\n        return base                                                      =>           \r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))  =>           \r\n    return accumulate(add, 0, n, term)                                   =>           \r\n    return accumulate(mul, 1, n, term)                                   =>           \r\n    return accumulate(combiner, base, n, term)                           =>           \r\n    def z(x):                                                            =>           \r\n        return compose1(f,f)(x)                                          =>           \r\n    if n == 0:                                                           =>           \r\n        return z(n)                                                      =>           \r\n    return z(n-1) + z(n)                                                 =>           \r\n    else:                                                                =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n                                                                         =>           \r\n    return _______                                                       <=           \r\n        return combiner(accumulate(combiner, base, n-1, term))           <=           \r\n    return _______                                                       <=           \r\n    return _______                                                       <=           \r\n    return _______                                                       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return term(n)\n    else:\n        return combiner(accumulate(combiner, base, n-1, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n)) \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), 2), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(accumulate(combiner, base, n-1, term))","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":312,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        elif n == 0:       =>           \r\n            return term(0) =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(combiner, n, term):\n        if n == 1:\n            return term(1)\n        return combiner(term(n), helper(combiner, n - 1, term))\n    return combiner(base, helper(combiner, n, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(combiner, n, term):\n        if n == 1:\n            return term(1)\n        elif n == 0:\n            return term(0)\n        return combiner(term(n), helper(combiner, n - 1, term))\n    return combiner(base, helper(combiner, n, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-0))))))))))))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper","    return combiner(term(n), helper(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper","    return combiner(term(n), helper(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper","    return combiner(term(n), helper(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper","    return combiner(term(n), helper(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper","    return combiner(term(n), helper(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in helper","    return combiner(term(n), helper(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in helper","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":313,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return base                                                     =>           \r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))     =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    combiner(term(n),term(n-1))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n    combiner(term(n),term(n-1))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), 0), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), 0), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":317,"diff":"\r\nInputObject                                     SideIndicator\r\n-----------                                     -------------\r\n            result = combiner(result, term(x))  =>           \r\n            result += combiner(result, term(x)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = base\n    if n > 0:\n        for x in range(1, n + 1):\n            result += combiner(result, term(x))\n    return result","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = base\n    if n > 0:\n        for x in range(1, n + 1):\n            result = combiner(result, term(x))\n    return result","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(ReferenceNode(node, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0), SingleChild(ReferenceNode(node, Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0))))), Selected(\\x => Match(x, Skip(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","57","","# Error: expected","#     15","# but got","#     57","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":426,"diff":"\r\nInputObject                                     SideIndicator\r\n-----------                                     -------------\r\n            total = combiner(total,term(next))  =>           \r\n            total += combiner(total,term(next)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n==0:\n    #     return base\n    # else:\n    #     return combiner(term(n),accumulate(combiner,base,n-1,term))\n    if n==0:\n        return base\n    else:\n        total, next = base,1\n        while next<=n:\n            total += combiner(total,term(next))\n            next+=1\n        return total\n\n        ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n==0:\n    #     return base\n    # else:\n    #     return combiner(term(n),accumulate(combiner,base,n-1,term))\n    if n==0:\n        return base\n    else:\n        total, next = base,1\n        while next<=n:\n            total = combiner(total,term(next))\n            next+=1\n        return total\n\n        ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(ReferenceNode(node, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0), SingleChild(ReferenceNode(node, Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0))))), Selected(\\x => Match(x, Skip(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","57","","# Error: expected","#     15","# but got","#     57","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":439,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n        s = combiner(s, term(i))  =>           \r\n        s += combiner(s, term(i)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    s = base\n    for i in range(1, n + 1):\n        s += combiner(s, term(i))\n    return s\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    s = base\n    for i in range(1, n + 1):\n        s = combiner(s, term(i))\n    return s\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(ReferenceNode(node, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0), SingleChild(ReferenceNode(node, Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0))))), Selected(\\x => Match(x, Skip(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","57","","# Error: expected","#     15","# but got","#     57","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":318,"diff":"\r\nInputObject                                       SideIndicator\r\n-----------                                       -------------\r\n        if(i == n):                               =>           \r\n    if(n == 0):                                   =>           \r\n        return base                               =>           \r\n        return combiner(base, take_term(1, term)) =>           \r\n    else:                                         =>           \r\n        if(i == 0):                               <=           \r\n            return 0                              <=           \r\n        elif(i == n):                             <=           \r\n    return combiner(base, take_term(1, term))     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def take_term(i, function):\n        if(i == 0):\n            return 0\n        elif(i == n):\n            return function(i)\n        else:\n            return combiner(function(i), take_term(i + 1, function))\n    \n    return combiner(base, take_term(1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def take_term(i, function):\n        if(i == n):\n            return function(i)\n        else:\n            return combiner(function(i), take_term(i + 1, function))\n    \n    if(n == 0):\n        return base\n    else:\n        return combiner(base, take_term(1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(ParenthesisExpressionNode, SingleChild(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-take_term, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), 0)))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-take_term, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-take_term, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-take_term, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term","    return combiner(function(i), take_term(i + 1, function))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term","    return combiner(function(i), take_term(i + 1, function))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term","    return combiner(function(i), take_term(i + 1, function))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term","    return combiner(function(i), take_term(i + 1, function))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term","    return combiner(function(i), take_term(i + 1, function))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in take_term","    return combiner(function(i), take_term(i + 1, function))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in take_term","    if(i == 0):","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":319,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        return base                          =>           \r\n        while n >= 1:                        =>           \r\n            total = combiner(total, term(n)) =>           \r\n    if n == 0:                               =>           \r\n            n -= 1                           =>           \r\n    else:                                    =>           \r\n    while n >= 0:                            <=           \r\n        total = combiner(total, term(n))     <=           \r\n        n -= 1                               <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** LULU'S CODE HERE ***\"\n    \n    \n    # def combiner_func(combiner, n, term):\n    #     if n == 0:\n    #         return term(0)\n    #     elif n == 1:\n    #         return term(1)\n    #     else:\n    #         return combiner(term(n), combiner_func(combiner, n-1, term))\n\n    # return combiner(base, combiner_func(combiner, n, term))\n    total = base\n    while n >= 0:\n        total = combiner(total, term(n))\n        n -= 1\n\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** LULU'S CODE HERE ***\"\n    \n    \n    # def combiner_func(combiner, n, term):\n    #     if n == 0:\n    #         return term(0)\n    #     elif n == 1:\n    #         return term(1)\n    #     else:\n    #         return combiner(term(n), combiner_func(combiner, n-1, term))\n\n    # return combiner(base, combiner_func(combiner, n, term))\n    total = base\n    if n == 0:\n        return base\n    else:\n        while n >= 1:\n            total = combiner(total, term(n))\n            n -= 1\n\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":322,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        elif n == 0: =>           \r\n            return 0 =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def terms(n):\n        if n == 1:\n            return term(1)\n        else:\n            return combiner(term(n), terms(n-1))\n    return combiner(base, terms(n))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def terms(n):\n        if n == 1:\n            return term(1)\n        elif n == 0:\n            return 0\n        else:\n            return combiner(term(n), terms(n-1))\n    return combiner(base, terms(n))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-0)))))))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms","    return combiner(term(n), terms(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms","    return combiner(term(n), terms(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms","    return combiner(term(n), terms(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms","    return combiner(term(n), terms(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms","    return combiner(term(n), terms(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in terms","    return combiner(term(n), terms(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in terms","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":323,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    k = base                                                        =>           \r\n    for i in range (1, n + 1):                                      =>           \r\n        k = combiner(k, term(i))                                    =>           \r\n    return k                                                        =>           \r\n    if n == base:                                                   <=           \r\n        return term(base)                                           <=           \r\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == base:\n        return term(base)\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = base\n    for i in range (1, n + 1):\n        k = combiner(k, term(i))\n    return k\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-k), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1))))), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i))))))), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ForStatementNode, Children(LeafConstNode(NameExpressionNode-i), Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-range), Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-k), SingleChild(ConstNode(CallExpressionNode, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-k)))), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))), InOrderSort(ast))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    if n == base:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     26","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":325,"diff":"\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n        return combiner(term(n), accumulate(combiner,base,(n-1),term)) =>           \r\n        sum(term(n), accumulate(combiner,base,(n-1),term))             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        sum(term(n), accumulate(combiner,base,(n-1),term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner,base,(n-1),term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), 0)))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    sum(term(n), accumulate(combiner,base,(n-1),term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    sum(term(n), accumulate(combiner,base,(n-1),term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    sum(term(n), accumulate(combiner,base,(n-1),term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    sum(term(n), accumulate(combiner,base,(n-1),term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    sum(term(n), accumulate(combiner,base,(n-1),term))","TypeError: 'int' object is not iterable","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":326,"diff":"\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n        return combiner( accumulate(combiner, base, n-1, term), term(n)) =>           \r\n        return combiner( accumulate(combiner, base, n-1, term, term(n))) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term, k =1):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner( accumulate(combiner, base, n-1, term, term(n)))\n","after":"def accumulate(combiner, base, n, term, k =1):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner( accumulate(combiner, base, n-1, term), term(n))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0), Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0), Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0), Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0))))))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0), 2), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner( accumulate(combiner, base, n-1, term, term(n)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner( accumulate(combiner, base, n-1, term, term(n)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner( accumulate(combiner, base, n-1, term, term(n)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner( accumulate(combiner, base, n-1, term, term(n)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return combiner( accumulate(combiner, base, n-1, term, term(n)))","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":329,"diff":"\r\nInputObject                                                          SideIndicator\r\n-----------                                                          -------------\r\n    if n == 1:                                                       =>           \r\n        return combiner(base, term(n))                               =>           \r\n    elif n == 0:                                                     =>           \r\n        return base                                                  =>           \r\n        return combiner(term(n), accumulate(combiner,base,n-1,term)) =>           \r\n    def helper(x):                                                   =>           \r\n        return compose1(f,f)                                         =>           \r\n    return helper(x)                                                 =>           \r\n    else:                                                            =>           \r\n    if n == 0:                                                       <=           \r\n        return term(base)                                            <=           \r\n    return combiner(term(n), accumulate(combiner,base,n-1,term))     <=           \r\n                                                                     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return term(base)\n    return combiner(term(n), accumulate(combiner,base,n-1,term))\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(base, term(n))\n    elif n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner,base,n-1,term))\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)))))))))))))), Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), 0))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))), InOrderSort(ast)))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":331,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    total, k = base, 1 =>           \r\n    total, k = 0, base <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = 0, base\n    while k <= n:\n        total, k = combiner(total,term(k)), k + 1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(total,term(k)), k + 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     26","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":458,"diff":"\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n    final = base                                    =>           \r\n    x = 1                                           =>           \r\n    while x <= n:                                   =>           \r\n        final = combiner(term(x), final)            =>           \r\n    # total, k = base, 1                            <=           \r\n    # while k <=n:                                  <=           \r\n    #     total, k = combiner(term(k),total), k + 1 <=           \r\n    # return total                                  <=           \r\n    # total = 1                                     <=           \r\n    # k = base                                      <=           \r\n    # while k <=n:                                  <=           \r\n    #     total = combiner(term(k),total)           <=           \r\n    #     k = k + 1                                 <=           \r\n    # return total                                  <=           \r\n    final = 1                                       <=           \r\n    x = base                                        <=           \r\n    while x <=n:                                    <=           \r\n        final = combiner(term(x),final)             <=           \r\n                                                    <=           \r\n                                                    <=           \r\n                                                    <=           \r\n                                                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # total, k = base, 1\n    # while k <=n:\n    #     total, k = combiner(term(k),total), k + 1\n    # return total    \n\n    # total = 1\n    # k = base\n    # while k <=n:\n    #     total = combiner(term(k),total) \n    #     k = k + 1\n    # return total\n\n\n\n    final = 1\n    x = base\n    while x <=n:\n        final = combiner(term(x),final)\n        x = x + 1\n    return final\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    final = base\n    x = 1\n    while x <= n:\n        final = combiner(term(x), final)\n        x = x + 1\n    return final\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":605,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    prev_term = base            =>           \r\n    for x in range (1, n+1):    =>           \r\n    prev_term = 0               <=           \r\n    for x in range (base, n+1): <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    prev_term = 0\n    for x in range (base, n+1):\n        current_term = term(x)\n        prev_term = combiner(current_term, prev_term)\n\n    return prev_term\n        \n \n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    prev_term = base\n    for x in range (1, n+1):\n        current_term = term(x)\n        prev_term = combiner(current_term, prev_term)\n\n    return prev_term\n        \n \n    \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     26","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":333,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while x < n:  =>           \r\n    while x <= n: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = 0\n    Total = base\n    while x <= n:\n        Total = combiner(Total, term(x))\n        x += 1\n    return Total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = 0\n    Total = base\n    while x < n:\n        x += 1\n        Total = combiner(Total, term(x))\n    return Total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-x), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":334,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n        if n == 0:      =>           \r\n            return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def accumulate_helper(combiner, i, n_result):\n        if i == n:\n            return combiner(n_result, term(i))\n        else:\n            return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))\n    return accumulate_helper(combiner, 1, base)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def accumulate_helper(combiner, i, n_result):\n        if n == 0:\n            return base\n        if i == n:\n            return combiner(n_result, term(i))\n        else:\n            return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))\n    return accumulate_helper(combiner, 1, base)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 0), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate_helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper","    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper","    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper","    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper","    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper","    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate_helper","    return accumulate_helper(combiner, i + 1, combiner(n_result, term(i)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate_helper","    if i == n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":338,"diff":"\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n    return combiner(base, accumulate(combiner, term(n), n-1, term))    =>           \r\n                                                                       =>           \r\n    '''if n==0:                                                        <=           \r\n    return combiner(base, accumulate(combiner, term(n), n-1, term))''' <=           \r\n        return base                                                    <=           \r\n    total, next_term = base, 1                                         <=           \r\n    while n>0:                                                         <=           \r\n        total = total + term(next_term)                                <=           \r\n        next_term +=1                                                  <=           \r\n        n-=1                                                           <=           \r\n    return total                                                       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    '''if n==0:\n        return base\n    elif n==1:\n        return combiner(base, term(1))\n \n    return combiner(base, accumulate(combiner, term(n), n-1, term))'''\n\n    if n==0:\n        return base\n    total, next_term = base, 1\n    while n>0:\n        total = total + term(next_term)\n        next_term +=1\n        n-=1\n    return total \n    \n    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n==0:\n        return base\n    elif n==1:\n        return combiner(base, term(1))\n \n    return combiner(base, accumulate(combiner, term(n), n-1, term))\n\n    \n    \n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1))))), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ReferenceNode(node, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0), SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))))))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-GreaterThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base)))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)))), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0), 2), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AugmentedAssignStatementNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term)))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast)))))))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","16","","# Error: expected","#     72","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":339,"diff":"\r\nInputObject                                                                                 SideIndicator\r\n-----------                                                                                 -------------\r\n        return base                                                                         =>           \r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))                         =>           \r\n    def cmb(x, y):                                                                          =>           \r\n        if pred(y):                                                                         =>           \r\n            return combiner(x,y)                                                            =>           \r\n        else:                                                                               =>           \r\n            return x                                                                        =>           \r\n    return accumulate(cmb, base, n, term)                                                   =>           \r\n                                                                                            =>           \r\n        return term(n)                                                                      <=           \r\n    return base + combiner(term(n), accumulate(combiner, 0, n-1, term))                     <=           \r\n    return accumulate(lambda x,y: combiner(x,y) if pred(y) == True else x, base, n, term)   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return term(n)\n    return base + combiner(term(n), accumulate(combiner, 0, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","0","","# Error: expected","#     11","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":341,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    return helper(1, base)       =>           \r\n    return helper(1, term(base)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i, total):\n        if i > n:\n            return total\n        else:\n            total = combiner(total, term(i))\n            return helper(i + 1, total)\n    return helper(1, term(base))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i, total):\n        if i > n:\n            return total\n        else:\n            total = combiner(total, term(i))\n            return helper(i + 1, total)\n    return helper(1, base)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ArgNode\"))))), 0), 2), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","135","","# Error: expected","#     25","# but got","#     135","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":496,"diff":"\r\nInputObject                                                           SideIndicator\r\n-----------                                                           -------------\r\n    return combiner(term(n),accumulate(combiner,base,n-1,term))       =>           \r\n    return combiner(term(n),term(accumulate(combiner,base,n-1,term))) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    if n == 1:\n    \treturn combiner(term(1),base)\n    return combiner(term(n),term(accumulate(combiner,base,n-1,term)))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    if n == 1:\n    \treturn combiner(term(1),base)\n    return combiner(term(n),accumulate(combiner,base,n-1,term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ArgNode\"))))), 0), 2), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","21913","","# Error: expected","#     25","# but got","#     21913","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":343,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n < 1:       =>           \r\n        return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-LessThan, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":345,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n    if n == 0:                                                          =>           \r\n        return combiner (accumulate(combiner, base, n-1, term),term(n)) =>           \r\n    if base < n:                                                        <=           \r\n        return term(base) + accumulate(combiner, base+1, n, term)       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if base < n:\n        return term(base) + accumulate(combiner, base+1, n, term)\n    else:\n        return base\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner (accumulate(combiner, base, n-1, term),term(n))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)))), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))))))))))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","11","","# Error: expected","#     26","# but got","#     11","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":347,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n <= 1:      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, (n - 1), term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, (n - 1), term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), 0), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"IfStatementNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Equals, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\"))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":476,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n == 0:      =>           \r\n        return base =>           \r\n    elif n == 1:    =>           \r\n    if n <= 1:      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <= 1:\n        return combiner(base, term(1))\n    return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(1))\n    return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), 0), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"IfStatementNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Equals, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\"))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":349,"diff":"\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)  =>           \r\n        return accumulate(combiner, combiner(base, term(n), n-1, term))  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n), n-1, term)) \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n-1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0))))))), 2), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), 3), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), 4), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return accumulate(combiner, combiner(base, term(n), n-1, term))","TypeError: op_add expected 2 arguments, got 4","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":350,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n    def helper(n, term):                                                  <=           \r\n        if n > 0:                                                         <=           \r\n            return combiner(n, helper(n - 1, term))                       <=           \r\n        return combiner(base, combiner(term(n), helper(n - 1, term)))     <=           \r\n                                                                          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(n, term):\n        if n > 0:\n            return combiner(n, helper(n - 1, term))\n\n    if n == 0:\n        return base\n    else:\n        return combiner(base, combiner(term(n), helper(n - 1, term)))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast)))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(base, combiner(term(n), helper(n - 1, term)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in helper","    return combiner(n, helper(n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in helper","    return combiner(n, helper(n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in helper","    return combiner(n, helper(n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in helper","    return combiner(n, helper(n - 1, term))","TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":351,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        base = combiner(term(n),base)       =>           \r\n        base = base + combiner(term(n),n-1) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        base = base + combiner(term(n),n-1)\n        return accumulate(combiner,base,n-1,term)","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        base = combiner(term(n),base)\n        return accumulate(combiner,base,n-1,term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":354,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        return acc_help(combiner, total, k, term, y) =>           \r\n        return acc_help(combiner, total, k, term)    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def acc_help(combiner, total, k, term, y):\n        if k > n:\n            return total\n        total = combiner(total, term(k))\n        k += y\n        return acc_help(combiner, total, k, term)\n    return acc_help(combiner, base, 1, term, 1)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def acc_help(combiner, total, k, term, y):\n        if k > n:\n            return total\n        total = combiner(total, term(k))\n        k += y\n        return acc_help(combiner, total, k, term, y)\n    return acc_help(combiner, base, 1, term, 1)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-y))), 5), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return acc_help(combiner, base, 1, term, 1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in acc_help","    return acc_help(combiner, total, k, term)","TypeError: acc_help() missing 1 required positional argument: 'y'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":359,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return base                                                 =>           \r\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return n                                                    <=           \r\n    return combiner(base, term(n-1))                                <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return n\n    return combiner(base, term(n-1))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), 0)))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast)))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","4","","# Error: expected","#     15","# but got","#     4","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":360,"diff":"\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n    if n == 0 :                                                        =>           \r\n        return base                                                    =>           \r\n    else:                                                              =>           \r\n        return combiner(term(n), accumulate(combiner,base, n-1, term)) =>           \r\n    number = 0                                                         <=           \r\n    while number < n:                                                  <=           \r\n        total = combiner(base, term(number))                           <=           \r\n        number + 1                                                     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    number = 0 \n    while number < n:\n        total = combiner(base, term(number)) \n        number + 1\n    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0 :\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner,base, n-1, term))\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)))))), 1), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), 3), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)))))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term)))))))))))))))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Target(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)))))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term)))))))))))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     15","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":363,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n        return combiner(term(n), accumulate(base, n - 1, term))           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(base, term(n))\n    elif n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(base, n - 1, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(base, term(n))\n    elif n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(base, n - 1, term))","TypeError: accumulate() missing 1 required positional argument: 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":533,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumulate(base, n-1, term))           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(base, n-1, term))\n   ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n   ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(base, n-1, term))","TypeError: accumulate() missing 1 required positional argument: 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":364,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n        total += term(i)                 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, i = base, 1\n    while i <= n:\n        total += term(i)\n        i += 1\n    return total","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, i = base, 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i))))))))))))))), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","16","","# Error: expected","#     72","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":424,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n                                         =>           \r\n        total += term(i)                 <=           \r\n                                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n < 1:\n    #     return base\n    # else:\n    #     return combiner(base, accumulate(combiner, term(n), n-1, term))\n\n    # if n < 1:\n    #     return combiner(base, term(n))\n    # else:\n    #     return accumulate(combiner, term(n), n-1, term)\n\n    i, total = 1, base\n    while i <= n:\n        total += term(i)\n        i += 1\n    return total\n    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # if n < 1:\n    #     return base\n    # else:\n    #     return combiner(base, accumulate(combiner, term(n), n-1, term))\n\n    # if n < 1:\n    #     return combiner(base, term(n))\n    # else:\n    #     return accumulate(combiner, term(n), n-1, term)\n\n    i, total = 1, base\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i))))))))))))))), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","16","","# Error: expected","#     72","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":365,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n ==0:                          =>           \r\n        return combiner(base, term(0)) =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n ==0:\n        return combiner(base, term(0))\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-0))))))))))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return combiner(combiner(term(n),term(n-1)),accumulate(combiner, base, n-2, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":367,"diff":"\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))  =>           \r\n        return combiner(accumulate(combiner, base, n-1, term) + term(n)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"def helper(a):\n        \n        if a == n:\n            return combiner(term(a), base)\n        else:\n            return combiner(term(a),  helper(a+1))\n    if n == 0:\n        return base\n    else:\n        return helper(1) \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term) + term(n))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"def helper(a):\n        \n        if a == n:\n            return combiner(term(a), base)\n        else:\n            return combiner(term(a),  helper(a+1))\n    if n == 0:\n        return base\n    else:\n        return helper(1) \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))), 2), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    return combiner(accumulate(combiner, base, n-1, term) + term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    return combiner(accumulate(combiner, base, n-1, term) + term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    return combiner(accumulate(combiner, base, n-1, term) + term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    return combiner(accumulate(combiner, base, n-1, term) + term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    return combiner(accumulate(combiner, base, n-1, term) + term(n))","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":368,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    i = 1                                   =>           \r\n    while i <= n:                           =>           \r\n        total = combiner(total, term(i))    =>           \r\n        i +=1                               =>           \r\n    return combiner(total, base)            =>           \r\n    while base <= n:                        <=           \r\n        total = combiner(total, term(base)) <=           \r\n        base +=1                            <=           \r\n    return total                            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    if combiner == add:\n        total = 0 \n    else:\n        total = 1\n    \n    while base <= n:\n        total = combiner(total, term(base))\n        base +=1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    if combiner == add:\n        total = 0 \n    else:\n        total = 1\n    \n    i = 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i +=1\n    return combiner(total, base)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     26","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":369,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n    if n == 0:                                                          =>           \r\n    return combiner(term(n), accumulate(combiner, base, n-1, term))     =>           \r\n                                                                        =>           \r\n                                                                        =>           \r\n    if term(n) == base:                                                 <=           \r\n    else:                                                               <=           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) <=           \r\n    \"*** YOUR CODE HERE ***\"                                            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if term(n) == base:\n    \treturn base\n    else:\n    \treturn combiner(term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n    \treturn base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ReferenceNode(node, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), 0))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), 0), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 67, in accumulate","    if term(n) == base:","RecursionError: maximum recursion depth exceeded","","# Error: expected","#     26","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":370,"diff":"\r\nInputObject                                                              SideIndicator\r\n-----------                                                              -------------\r\n    if n == 0:                                                           =>           \r\n        return base                                                      =>           \r\n        return combiner(term(n), accumulate(combiner,base, n-1,term))    =>           \r\n    return accumulate(add, 0, n, term)                                   =>           \r\n    if base == n:                                                        <=           \r\n        return term(base)                                                <=           \r\n        return combiner(term(base), accumulate(combiner,base+1, n,term)) <=           \r\n    return _______                                                       <=           \r\n    \"*** YOUR CODE HERE ***\"                                             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if base == n:\n        return term(base)\n    else: \n        return combiner(term(base), accumulate(combiner,base+1, n,term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n == 0:\n        return base\n    else: \n        return combiner(term(n), accumulate(combiner,base, n-1,term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast)))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner,base+1, n,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner,base+1, n,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner,base+1, n,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner,base+1, n,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner,base+1, n,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(base), accumulate(combiner,base+1, n,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    if base == n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     26","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":371,"diff":"\r\nInputObject                        SideIndicator\r\n-----------                        -------------\r\n    return partial_accum(1,base)   =>           \r\n    return partial_product(1,base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def partial_accum(k,accum):\n        if k==n+1:\n            return accum\n        else:\n            return partial_accum(k+1,combiner(accum,term(k)))\n    return partial_product(1,base)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def partial_accum(k,accum):\n        if k==n+1:\n            return accum\n        else:\n            return partial_accum(k+1,combiner(accum,term(k)))\n    return partial_accum(1,base)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-partial_accum)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 79, in accumulate","    return partial_product(1,base)","NameError: name 'partial_product' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":373,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(base, term(n-1))                                <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return identity(base)\n    else:\n        return combiner(base, term(n-1))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return identity(base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), 0)))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","4","","# Error: expected","#     15","# but got","#     4","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":374,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n    total=base                        =>           \r\n        total=combiner(term(n),total) =>           \r\n        total=combiner(term(n),base)  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while n>0:\n        total=combiner(term(n),base)\n        n-=1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=base\n    while n>0:\n        total=combiner(term(n),total)\n        n-=1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(NameExpressionNode-base)))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":375,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    a = 1                                =>           \r\n    total = base                         =>           \r\n    while a <= n:                        =>           \r\n        total = combiner(total, term(a)) =>           \r\n        a += 1                           =>           \r\n    return total                         =>           \r\n    def summation(term, n):              <=           \r\n        a, total = n, 0                  <=           \r\n        while a > 0:                     <=           \r\n            total += term(a)             <=           \r\n            a -= 1                       <=           \r\n        return total                     <=           \r\n    return combiner(base, term(n))       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def summation(term, n):\n        a, total = n, 0\n        while a > 0:\n            total += term(a)\n            a -= 1\n        return total\n    return combiner(base, term(n))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    a = 1\n    total = base\n    while a <= n:\n        total = combiner(total, term(a))\n        a += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-a), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-summation, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(LeafConstNode(NameExpressionNode-n))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-a))))))))))))))), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatementNode-Add, Children(ReferenceNode(node, Node(AugmentedAssignStatementNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Target(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(FunctionDefinitionNode-summation, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-summation, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-summation, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-summation, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-summation, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-summation, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-summation, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), InOrderSort(ast))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":376,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    while k<=n: =>           \r\n    while n<=k: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while n<=k:\n        total, k = combiner(total, term(k)), k+1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k<=n:\n        total, k = combiner(total, term(k)), k+1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":378,"diff":"\r\nInputObject                                                                            SideIndicator\r\n-----------                                                                            -------------\r\n    def accumulate_fuzzies(combiner, base, n, term):                                   =>           \r\n        if n == 0:                                                                     =>           \r\n            return combiner(term(n), accumulate_fuzzies(combiner, base, n-1, term))    =>           \r\n    return accumulate_fuzzies(combiner, base, n, term)                                 =>           \r\n    def accumulate_fuzzies(combiner, base, n, term, k):                                <=           \r\n        if k == n:                                                                     <=           \r\n            return combiner(term(k), accumulate_fuzzies(combiner, base, n, term, k+1)) <=           \r\n    return accumulate_fuzzies(combiner, base, n, term, n)                              <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulate_fuzzies(combiner, base, n, term, k):\n        if k == n:\n            return base\n        else:\n            return combiner(term(k), accumulate_fuzzies(combiner, base, n, term, k+1))\n    return accumulate_fuzzies(combiner, base, n, term, n)","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulate_fuzzies(combiner, base, n, term):\n        if n == 0:\n            return base\n        else:\n            return combiner(term(n), accumulate_fuzzies(combiner, base, n-1, term))\n    return accumulate_fuzzies(combiner, base, n, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(FunctionDefinitionNode-accumulate_fuzzies, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(Target(LeafWildcard(\"ParameterNode\")), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(FunctionDefinitionNode-accumulate_fuzzies, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":379,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n        accumulate(combiner, base, n-1, term)                           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(n), base)\n    else:\n        accumulate(combiner, base, n-1, term)","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(n), base)\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))))))))), 0), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":381,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n    total, k = base, 1                             =>           \r\n    while k <= n:                                  =>           \r\n        total, k = combiner(term(k), total), k + 1 =>           \r\n    return total                                   =>           \r\n    result, k = base, 1                            <=           \r\n    while k<=n:                                    <=           \r\n        k+=1                                       <=           \r\n        result = combiner(term(k), result)         <=           \r\n    return result                                  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result, k = base, 1\n    while k<=n:\n        k+=1\n        result = combiner(term(k), result)\n    return result\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(term(k), total), k + 1\n    return total\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(NameExpressionNode-k)))), SingleChild(ConstNode(TupleExpressionNode-False, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-k)))))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))))))), SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","20","","# Error: expected","#     15","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":382,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    total = base =>           \r\n    total = 1    <=           \r\n    base = 1     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 1\n    counter = 1\n    base = 1\n    while counter <= n:\n        total = combiner(term(counter), total)\n        counter += 1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1\n    while counter <= n:\n        total = combiner(term(counter), total)\n        counter += 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":384,"diff":"\r\nInputObject                                                                 SideIndicator\r\n-----------                                                                 -------------\r\n    i = 1                                                                   =>           \r\n    total = base                                                            =>           \r\n    while i <= n:                                                           =>           \r\n        total = combiner(total, term(i))                                    =>           \r\n        i += 1                                                              =>           \r\n    return total                                                            =>           \r\n    if n == 0:                                                              <=           \r\n        return base                                                         <=           \r\n    elif n == 1:                                                            <=           \r\n        return combiner(base, term(n))                                      <=           \r\n    else:                                                                   <=           \r\n        return combiner(term(1), accumulate(combiner, base, (n + 1), term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(1), accumulate(combiner, base, (n + 1), term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    total = base\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(NameExpressionNode-n))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(NameExpressionNode-n)))), SingleChild(ConstNode(SuiteStatementNode, Children(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)))), SingleChild(ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), 0), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), 0), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), 0), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))))))), InOrderSort(ast))))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(1), accumulate(combiner, base, (n + 1), term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(1), accumulate(combiner, base, (n + 1), term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(1), accumulate(combiner, base, (n + 1), term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(1), accumulate(combiner, base, (n + 1), term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(1), accumulate(combiner, base, (n + 1), term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(1), accumulate(combiner, base, (n + 1), term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    if n == 0:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":385,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n        if n == 0:       =>           \r\n            return total =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(k,total):\n        if n <= k:\n            return combiner(term(k),total)\n        else:\n            total = combiner(term(k),total)\n        return helper (k+1, total)\n    return helper(1,base)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(k,total):\n        if n == 0:\n            return total\n        if n <= k:\n            return combiner(term(k),total)\n        else:\n            total = combiner(term(k),total)\n        return helper (k+1, total)\n    return helper(1,base)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-total)))))))))), 0), Selected(\\x => Match(x, Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":386,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        total = base                         =>           \r\n            total = combiner(total, term(i)) =>           \r\n        return total                         =>           \r\n        total = term(0)                      <=           \r\n            total = combiner(term(i), total) <=           \r\n        return base + total                  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        i = 1\n        total = term(0)\n        while i <= n:\n            total = combiner(term(i), total)\n            i = i+1\n        return base + total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        i = 1\n        total = base\n        while i <= n:\n            total = combiner(total, term(i))\n            i = i+1\n        return total\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 1), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast)))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","2","","# Error: expected","#     72","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":387,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n    if n==0:                          =>           \r\n        return base                   =>           \r\n        ans=combiner(base,term(1))    =>           \r\n        i=2                           =>           \r\n        while i<=n:                   =>           \r\n            ans=combiner(ans,term(i)) =>           \r\n            i+=1                      =>           \r\n        return ans                    =>           \r\n    else:                             =>           \r\n    ans=combiner(base,term(1))        <=           \r\n    i=2                               <=           \r\n    while i<=n:                       <=           \r\n        ans=combiner(ans,term(i))     <=           \r\n        i+=1                          <=           \r\n    return ans                        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    ans=combiner(base,term(1))\n    i=2\n    while i<=n:\n        ans=combiner(ans,term(i))\n        i+=1\n    return ans","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        ans=combiner(base,term(1))\n        i=2\n        while i<=n:\n            ans=combiner(ans,term(i))\n            i+=1\n        return ans","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), SingleChild(ConstNode(SuiteStatementNode, Children(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), Children(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), Children(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":388,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), accumulate(combiner, base, n, term))   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(combiner, base, n, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 69, in accumulate","    if n < 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":585,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        return accumulate(combiner, base, n-1, term) =>           \r\n        return accumulate(combiner, base, n, term)   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else: \n        base = combiner(term(n),base)\n        return accumulate(combiner, base, n, term)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else: \n        base = combiner(term(n),base)\n        return accumulate(combiner, base, n-1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return accumulate(combiner, base, n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return accumulate(combiner, base, n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return accumulate(combiner, base, n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return accumulate(combiner, base, n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return accumulate(combiner, base, n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    return accumulate(combiner, base, n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    if n == 0:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":389,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n    elif n == 1:                                                          =>           \r\n        return combiner(base, term(1))                                    =>           \r\n        return (combiner(term(n), accumulate(combiner, base, n-1, term))) =>           \r\n    else:                                                                 =>           \r\n    else:                                                                 <=           \r\n        return accumulate(combiner(base, term(n + 1)), n, term) + base    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else: \n        return accumulate(combiner(base, term(n + 1)), n, term) + base\n    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(1))\n    else:\n        return (combiner(term(n), accumulate(combiner, base, n-1, term)))\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))))))))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(ParenthesisExpressionNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)))))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate), Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))))))))))), 2), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return accumulate(combiner(base, term(n + 1)), n, term) + base","TypeError: accumulate() missing 1 required positional argument: 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":390,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        a=combiner(a,term(i+1)) =>           \r\n        combiner(a,term(i+1))   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    a=base\n    for i in range(n):\n        combiner(a,term(i+1))\n        \"\"\"if combiner==add:\n            a+=term(i+1)\n        else:\n            a*=term(i+1)\"\"\"\n    return(a)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    a=base\n    for i in range(n):\n        a=combiner(a,term(i+1))\n        \"\"\"if combiner==add:\n            a+=term(i+1)\n        else:\n            a*=term(i+1)\"\"\"\n    return(a)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-a), SingleChild(ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":392,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), base)                                  =>           \r\n    elif n == 1:                                                        =>           \r\n        return combiner(term(n), base)                                  =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    else:                                                               =>           \r\n        return n                                                        <=           \r\n    return combiner((term(n-1)), term(n)) * n-1                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\"\"\n    if n == 0:\n        return n\n    return combiner((term(n-1)), term(n)) * n-1\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\"\"\n    if n == 0:\n        return combiner(term(n), base)\n    elif n == 1:\n        return combiner(term(n), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)))))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(ParenthesisExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ParenthesisExpressionNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)))))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))))))), Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0), Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast)))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","44","","# Error: expected","#     15","# but got","#     44","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":393,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n                                          =>           \r\n        total = combiner(total,term(x))   =>           \r\n                                          =>           \r\n        total = combiner((total,term(x))) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    x = 1\n    while x <= n:\n        total = combiner((total,term(x)))\n        x = x + 1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total = base\n    x = 1\n    while x <= n:\n        total = combiner(total,term(x))\n        x = x + 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 1), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    total = combiner((total,term(x)))","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":398,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    if n == 0:    =>           \r\n    if n == base: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == base:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(term(n), accumulate(combiner, base, n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if n == base:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     26","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":441,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    if base > 0: =>           \r\n    if base > n: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    k = 1\n    total = 0\n    if base > n:\n        total = base\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n        ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    k = 1\n    total = 0\n    if base > 0:\n        total = base\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n        ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":560,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    if n==0: return base    =>           \r\n    if n==base: return base <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==base: return base\n    else: return combiner(term(n),accumulate(combiner,base,n-1,term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0: return base\n    else: return combiner(term(n),accumulate(combiner,base,n-1,term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    else: return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    else: return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    else: return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    else: return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    else: return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    else: return combiner(term(n),accumulate(combiner,base,n-1,term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 67, in accumulate","    if n==base: return base","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     26","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":399,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    for i in range (1,n+1): =>           \r\n    while x != n:           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while x != n:\n        base = combiner(base, term(i))\n    return(base)\n        \n        \n        ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    for i in range (1,n+1):\n        base = combiner(base, term(i))\n    return(base)\n        \n        \n        ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-range), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(ForStatementNode, Children(LeafConstNode(NameExpressionNode-i), Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-range), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))), SingleChild(ReferenceNode(node, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), 0)))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(ParenthesisExpressionNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    while x != n:","NameError: name 'x' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":401,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n    if n > 1:                                                             =>           \r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n    if n > 2:                                                             <=           \r\n        return combiner(term(n), term(n - 1))                             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n > 2:\n        return combiner(term(n), term(n - 1))\n    else:\n        return combiner(term(n), base)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n > 1:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n    else:\n        return combiner(term(n), base)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","9","","# Error: expected","#     15","# but got","#     9","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":404,"diff":"\r\nInputObject                                                        SideIndicator\r\n-----------                                                        -------------\r\n            return combiner(term(k), helper_accumulate(k+1, term)) =>           \r\n            return combiner(term(k), helper_accumulate(k+1), term) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper_accumulate(k, term):\n        if k>n:\n            return base\n        else:\n            return combiner(term(k), helper_accumulate(k+1), term)\n    if n==0:\n        return base\n    else:\n        return helper_accumulate(1, term)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper_accumulate(k, term):\n        if k>n:\n            return base\n        else:\n            return combiner(term(k), helper_accumulate(k+1, term))\n    if n==0:\n        return base\n    else:\n        return helper_accumulate(1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in accumulate","    return helper_accumulate(1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in helper_accumulate","    return combiner(term(k), helper_accumulate(k+1), term)","TypeError: helper_accumulate() missing 1 required positional argument: 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":406,"diff":"\r\nInputObject                                                                     SideIndicator\r\n-----------                                                                     -------------\r\n    next_term= accumulate(combiner,term(n), n-1, term)                          =>           \r\n    return combiner(base, next_term)                                            =>           \r\n    if n<=0:                                                                    =>           \r\n    if n<1:                                                                     <=           \r\n    return combiner(base, combiner(term(n), accumulate(combiner,0, n-1, term))) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"def term2(combiner, n, term):\n        if combiner==add and n<=0:\n            return 0\n        elif combiner==mul and n<=0:\n            return 1\n        else:\n            return combiner(term(n), term2(combiner, n-1, term))\"\"\"\n\n    if n<1:\n        return base\n    return combiner(base, combiner(term(n), accumulate(combiner,0, n-1, term)))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"\"\"def term2(combiner, n, term):\n        if combiner==add and n<=0:\n            return 0\n        elif combiner==mul and n<=0:\n            return 1\n        else:\n            return combiner(term(n), term2(combiner, n-1, term))\"\"\"\n\n    if n<=0:\n        return base\n    next_term= accumulate(combiner,term(n), n-1, term)\n    return combiner(base, next_term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-accumulate)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0), 2), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), 3), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), 4), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-next_term), SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-next_term))))))))), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))))))))), InOrderSort(ast))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":411,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    if n == 0:                                                      =>           \r\n        return base                                                 =>           \r\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    total = 0                                                       <=           \r\n    while n>0:                                                      <=           \r\n        total = combiner(term(n), term(n-1))                        <=           \r\n        n-=1                                                        <=           \r\n    total = combiner(total, term(base))                             <=           \r\n    return total                                                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    while n>0:\n        total = combiner(term(n), term(n-1))\n        n-=1\n    total = combiner(total, term(base))\n    return total","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-GreaterThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 4), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), 0)))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":412,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        return combiner(term(n), helper(n-1, term))  =>           \r\n    return combiner(base,helper(n,term))             =>           \r\n        return combiner(n, helper(n-1,term))         <=           \r\n    return combiner(base,helper)                     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(n,term):\n        if n ==1:\n            return n\n        elif n ==0:\n            return 0\n        return combiner(n, helper(n-1,term))\n    return combiner(base,helper)","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(n,term):\n        if n ==1:\n            return n\n        elif n ==0:\n            return 0\n        return combiner(term(n), helper(n-1, term)) \n    return combiner(base,helper(n,term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    return combiner(base,helper)","TypeError: unsupported operand type(s) for +: 'int' and 'function'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":415,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n        i = 1  =>           \r\n        i += 1 =>           \r\n        i = 2  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0: \n        return base\n    else: \n        total = combiner(base, term(i))\n        i = 2\n        while i <= n:\n            total = combiner(total, term(i))\n            i += 1\n        return total \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0: \n        return base\n    else: \n        i = 1\n        total = combiner(base, term(i))\n        i += 1\n        while i <= n:\n            total = combiner(total, term(i))\n            i += 1\n        return total \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatementNode-Add, Children(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    total = combiner(base, term(i))","UnboundLocalError: local variable 'i' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":417,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n                k = k + 1 =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    k = 1\n    while k <= n:\n        if combiner == mul:\n            if total == 0:\n                total = total + combiner(1, term(k))\n                k = k + 1\n            else: \n                total = total * combiner(1, term(k))\n        else:\n            total = combiner(total, term(k))\n            k = k + 1\n    final_total = combiner(base, total)\n    return final_total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    k = 1\n    while k <= n:\n        if combiner == mul:\n            if total == 0:\n                total = total + combiner(1, term(k))\n                k = k + 1\n            else: \n                total = total * combiner(1, term(k))\n                k = k + 1\n        else:\n            total = combiner(total, term(k))\n            k = k + 1\n    final_total = combiner(base, total)\n    return final_total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-k), SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))), 1), Selected(\\x => Match(x, Skip(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"any\"))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     72","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":464,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n        k = k + 1 =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    total = base\n    while k <= n:\n        total = combiner(total, term(k))\n    return total \n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    total = base\n    while k <= n:\n        total = combiner(total, term(k))\n        k = k + 1\n    return total \n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-k), SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))), 1), Selected(\\x => Match(x, Skip(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"any\"))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     15","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":418,"diff":"\r\nInputObject                                                                       SideIndicator\r\n-----------                                                                       -------------\r\n    elif combiner== mul:                                                          =>           \r\n        return combiner(combiner(term(n),base),accumulate(combiner,0,(n-1),term)) =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    else:\n        return combiner(combiner(term(n),base),accumulate(combiner,1,(n-1),term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    elif combiner== mul:\n        return combiner(combiner(term(n),base),accumulate(combiner,1,(n-1),term))\n    else:\n        return combiner(combiner(term(n),base),accumulate(combiner,0,(n-1),term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-combiner), SingleChild(LeafConstNode(NameExpressionNode-mul)))), SingleChild(ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), 0)))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))))))))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-0))), Children(ConstNode(ArgNode, SingleChild(ConstNode(ParenthesisExpressionNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))))))))), 2), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","20","","# Error: expected","#     15","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":427,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    return Total  =>           \r\n    return Total  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    Total = base\n    counter = 1\n    while counter <= n:\n        counter += 1\n        Total = combiner(Total, term(counter))\n    return Total ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    Total = base\n    counter = 1\n    while counter <= n:\n        Total = combiner(Total, term(counter))\n        counter += 1\n    return Total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-counter), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","20","","# Error: expected","#     15","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":428,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    while i<=n:                   =>           \r\n    return start                  =>           \r\n    return accumulate(add, start) =>           \r\n    while i<n:                    <=           \r\n    return combiner               <=           \r\n    return _______                <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    start=base\n    i=1\n    while i<n:\n        start= combiner(start, term(i))\n        i +=1\n    return combiner\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    start=base\n    i=1\n    while i<=n:\n        start= combiner(start, term(i))\n        i +=1\n    return start\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-start)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","<built-in function add>","","# Error: expected","#     15","# but got","#     <built-in function add>","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":429,"diff":"\r\nInputObject                                                                                      SideIndicator\r\n-----------                                                                                      -------------\r\n            return combiner(term(x), awkward_accumulate(combiner, base, x+1, n, term))           =>           \r\n            return combiner(term(x), lambda x: awkward_accumulate(combiner, base, x+1, n, term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def awkward_accumulate(combiner, base, x, n, term):\n        if x>n:\n            return base\n        else:\n            return combiner(term(x), lambda x: awkward_accumulate(combiner, base, x+1, n, term))\n    #    if combiner==add:\n    #        return term(x) + awkward_accumulate(combiner, base, x+1, n, term)\n    #    else:\n    #        return term(x) * awkward_accumulate(combiner, base, x+1, n, term)\n    return awkward_accumulate(combiner, base, 1, n, term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def awkward_accumulate(combiner, base, x, n, term):\n        if x>n:\n            return base\n        else:\n            return combiner(term(x), awkward_accumulate(combiner, base, x+1, n, term))\n    #    if combiner==add:\n    #        return term(x) + awkward_accumulate(combiner, base, x+1, n, term)\n    #    else:\n    #        return term(x) * awkward_accumulate(combiner, base, x+1, n, term)\n    return awkward_accumulate(combiner, base, 1, n, term)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(LambdaExpressionNode, TChild(Node(FunctionDefinitionNode-<lambda$4922>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(ArgNode, TChild(Node(LambdaExpressionNode, TChild(Node(FunctionDefinitionNode-<lambda$4922>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(ArgNode, TChild(Node(LambdaExpressionNode, TChild(Node(FunctionDefinitionNode-<lambda$4922>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in accumulate","    return awkward_accumulate(combiner, base, 1, n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in awkward_accumulate","    return combiner(term(x), lambda x: awkward_accumulate(combiner, base, x+1, n, term))","TypeError: unsupported operand type(s) for +: 'int' and 'function'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":430,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    15                                 =>           \r\n    15_________                        <=           \r\n    elif n == 1:                       <=           \r\n        return combiner(base, term(n)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15_________ \n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0: \n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n      \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0: \n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n      \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    )), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     15_________","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":431,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n        while i < n+1: =>           \r\n        while i < n:   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        i = 1\n        accumulation = base\n        while i < n:\n            accumulation = combiner(accumulation, term(i))\n            i += 1\n        return accumulation      \n    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        i = 1\n        accumulation = base\n        while i < n+1:\n            accumulation = combiner(accumulation, term(i))\n            i += 1\n        return accumulation      \n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":538,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    while counter < n + 1: =>           \r\n    while counter < n:     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1\n\n    while counter < n:\n        total = combiner(total, term(counter))\n        counter += 1\n\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1\n\n    while counter < n + 1:\n        total = combiner(total, term(counter))\n        counter += 1\n\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":432,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        total = combiner(total,term(k))    =>           \r\n    return accumulate(mul, 1, n, term)     =>           \r\n                                           =>           \r\n        total = combiner(total,term)       <=           \r\n    return accumulate(product, 1, n, term) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k=1\n    total = base \n    while k<=n:\n        total = combiner(total,term)\n        k+=1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k=1\n    total = base \n    while k<=n:\n        total = combiner(total,term(k))\n        k+=1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-k)))))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    total = combiner(total,term)","TypeError: unsupported operand type(s) for +: 'int' and 'function'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":433,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    return total     =>           \r\n        return total <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # k is the next term in the sequence\n\n    total , k = base , 1\n    while k <= n:\n        total, k = combiner(total , term(k)), k + 1\n        return total\n        \n\n        \n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    # k is the next term in the sequence\n\n    total , k = base , 1\n    while k <= n:\n        total, k = combiner(total , term(k)), k + 1\n    return total\n        \n\n        \n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ReferenceNode(node, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), 0)))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":436,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n == 0:                         =>           \r\n        return base                    =>           \r\n    if n == 1:                         =>           \r\n    return accumulate(add, 0, n, term) =>           \r\n    return accumulate(mul, 0, n, term) =>           \r\n    if n <= 1:                         <=           \r\n    return _______                     <=           \r\n    return _______                     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    if n == 1:\n        return combiner(base, term(1))\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Equals, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":438,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n        while i >= 1: =>           \r\n        while i > 1:  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = n\n    total = base \n    if n == 0:\n        return base\n    else:\n        while i > 1:\n            total = combiner (total, term (i))\n            i -= 1\n        return total\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = n\n    total = base \n    if n == 0:\n        return base\n    else:\n        while i >= 1:\n            total = combiner (total, term (i))\n            i -= 1\n        return total\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","14","","# Error: expected","#     15","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":440,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    if combiner == mul:     =>           \r\n    while i <= n:           =>           \r\n    while i <= n:           <=           \r\n        if combiner == mul: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, i = 0, 1\n    while i <= n:\n        if combiner == mul:\n            total = 1\n        total = combiner(total, term(i))\n        i += 1\n    return combiner(total, base)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, i = 0, 1\n    if combiner == mul:\n            total = 1\n    while i <= n:    \n        total = combiner(total, term(i))\n        i += 1\n    return combiner(total, base)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(NameExpressionNode-n)))), SingleChild(ConstNode(SuiteStatementNode, Children(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0), SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0))))))), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","18","","# Error: expected","#     72","# but got","#     18","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":442,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n), combiner(n-1, term))                   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), combiner(n-1, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0))), 1), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    return combiner(term(n), combiner(n-1, term))","TypeError: unsupported operand type(s) for +: 'int' and 'function'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":444,"diff":"\r\nInputObject                                              SideIndicator\r\n-----------                                              -------------\r\n        return base                                      =>           \r\n        base = combiner(term(n), base)                   =>           \r\n        return accumulate(combiner, base, n-1, term)     =>           \r\n        return acc                                       <=           \r\n        next_acc = combiner(term(n), acc)                <=           \r\n        return accumulate(combiner, next_acc, n-1, term) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return acc\n    else:\n        next_acc = combiner(term(n), acc)\n        return accumulate(combiner, next_acc, n-1, term)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        base = combiner(term(n), base)\n        return accumulate(combiner, base, n-1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    next_acc = combiner(term(n), acc)","NameError: name 'acc' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":563,"diff":"\r\nInputObject                                           SideIndicator\r\n-----------                                           -------------\r\n        return base                                   =>           \r\n        base = combiner(term(n), base)                =>           \r\n        return accumulate(combiner, base, n-1, term)  =>           \r\n        return start                                  <=           \r\n        start = combiner(term(n), start)              <=           \r\n        return accumulate(combiner, start, n-1, term) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return start\n    else:\n        start = combiner(term(n), start)\n        return accumulate(combiner, start, n-1, term)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        base = combiner(term(n), base)\n        return accumulate(combiner, base, n-1, term)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    start = combiner(term(n), start)","UnboundLocalError: local variable 'start' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":445,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    q=term(1)               =>           \r\n    for i in range(2, n+1): =>           \r\n    q=0                     <=           \r\n    for i in range(1, n+1): <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if (n==0): return base\n    q=0\n    for i in range(1, n+1):\n    \tq=combiner(q, term(i))\n    return combiner(base, q)\n    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if (n==0): return base\n    q=term(1)\n    for i in range(2, n+1):\n    \tq=combiner(q, term(i))\n    return combiner(base, q)\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-2)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":446,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return combiner(term(n),accumulate(combiner,base,n-1,term)) =>           \r\n    else:                                                           =>           \r\n                                                                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <= 1:\n        return combiner(base,term(n))\n    \n        \n    \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <= 1:\n        return combiner(base,term(n))\n    else:\n        return combiner(term(n),accumulate(combiner,base,n-1,term))\n        \n    \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))))))))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":449,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n                                                                        =>           \r\n    if n ==0:                                                           =>           \r\n        return base                                                     =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    else:                                                               =>           \r\n    total=0                                                             <=           \r\n    base>=0                                                             <=           \r\n    k=n                                                                 <=           \r\n    combiner=(term(n)+term(n-1))                                        <=           \r\n    while k>=0:                                                         <=           \r\n        total+=accumulate (combiner, base, k, term)                     <=           \r\n        k-=1                                                            <=           \r\n    return total                                                        <=           \r\n    # if n ==0:                                                         <=           \r\n    #     return combiner(base, accumulate(combiner, base, n, term))    <=           \r\n    # else:                                                             <=           \r\n    #     return accumulate(combiner, base, n-1, term)                  <=           \r\n                                                                        <=           \r\n                                                                        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total=0 \n    base>=0\n    k=n\n    combiner=(term(n)+term(n-1))\n    while k>=0:\n        total+=accumulate (combiner, base, k, term)\n        k-=1\n    return total \n\n    # if n ==0:\n    #     return combiner(base, accumulate(combiner, base, n, term))\n    # else:\n    #     return accumulate(combiner, base, n-1, term)\n\n        \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n   \n    if n ==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n        \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)))), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(ParenthesisExpressionNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), 0), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term)))))))))))))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 85, in accumulate","    total+=accumulate (combiner, base, k, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 85, in accumulate","    total+=accumulate (combiner, base, k, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 85, in accumulate","    total+=accumulate (combiner, base, k, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 85, in accumulate","    total+=accumulate (combiner, base, k, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 85, in accumulate","    total+=accumulate (combiner, base, k, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 85, in accumulate","    total+=accumulate (combiner, base, k, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 81, in accumulate","    base>=0","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":450,"diff":"\r\nInputObject                                                            SideIndicator\r\n-----------                                                            -------------\r\n    if combiner == add:                                                =>           \r\n        final_number = 0                                               =>           \r\n    elif combiner == mul:                                              =>           \r\n        final_number = 1                                               =>           \r\n        final_number, k = combiner(final_number, term(k)), k - 1       =>           \r\n                                                                       =>           \r\n    final_number = 0                                                   <=           \r\n        final_number, k = combiner(term(final_number), term(k)), k - 1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = n\n    final_number = 0\n    while k > 0:\n        final_number, k = combiner(term(final_number), term(k)), k - 1\n    return combiner(base, final_number)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = n\n    if combiner == add:\n        final_number = 0\n    elif combiner == mul:\n        final_number = 1\n    while k > 0:\n        final_number, k = combiner(final_number, term(k)), k - 1\n    return combiner(base, final_number)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-combiner), SingleChild(LeafConstNode(NameExpressionNode-add)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)))))), SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-combiner), SingleChild(LeafConstNode(NameExpressionNode-mul)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-final_number), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), 1), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","7237","","# Error: expected","#     25","# but got","#     7237","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":451,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n        return combiner(base, term(n))\"\"\"          =>           \r\n    return combiner(base, accumulate_helper(1))    =>           \r\n        return combiner(base, term(n))             <=           \r\n    return combiner(base, accumulate_helper(1))\"\"\" <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return base\n    elif n>0:\n        return combiner(term(n), accumulate(n-1))\n    elif n==1:\n        return combiner(base, term(n))\n    \n    \n    \"\"\"if n==0:\n        return base\n    def accumulate_helper(i):\n        if i==n:\n            return term(i)\n        else:\n            return combiner(term(i), accumulate_helper(i+1))\n    return combiner(base, accumulate_helper(1))\"\"\"\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"if n==0:\n        return base\n    elif n>0:\n        return combiner(term(n), accumulate(n-1))\n    elif n==1:\n        return combiner(base, term(n))\"\"\"\n    \n    \n    if n==0:\n        return base\n    def accumulate_helper(i):\n        if i==n:\n            return term(i)\n        else:\n            return combiner(term(i), accumulate_helper(i+1))\n    return combiner(base, accumulate_helper(1))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ExpressionStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-if n==0:\n        return base\n    elif n>0:\n        return combiner(term(n), accumulate(n-1))\n    elif n==1:\n        return combiner(base, term(n))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ReferenceNode(node, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), 0))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-i), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i)))))))))))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-accumulate_helper)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-i), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(FunctionDefinitionNode-accumulate_helper, Children(LeafConstNode(ParameterNode-i), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-i), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i))))))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate_helper), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-i), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))))))))))))))))))))))))), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-accumulate_helper)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0), 5), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), TChild(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast)))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in accumulate","    return combiner(term(n), accumulate(n-1))","TypeError: accumulate() missing 3 required positional arguments: 'base', 'n', and 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":452,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    while x<= n: =>           \r\n    while i<= n: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\"\"\"\n  \n    result, x = base, 1\n    while i<= n:\n        result = combiner(term(x), result)\n        x += 1\n    return result\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\"\"\"\n  \n    result, x = base, 1\n    while x<= n:\n        result = combiner(term(x), result)\n        x += 1\n    return result\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-x)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    while i<= n:","NameError: name 'i' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":598,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n        x = combiner(x, term(i))    =>           \r\n        x = combiner(base, term(i)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    i = 1\n    while (i <= n):\n        x = combiner(base, term(i))\n        i += 1\n    return x","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = base\n    i = 1\n    while (i <= n):\n        x = combiner(x, term(i))\n        i += 1\n    return x","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-x)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":455,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n    if n == 0:                                                            =>           \r\n        return base                                                       =>           \r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) =>           \r\n    return accumulate(add, 0, n, term)                                    =>           \r\n    return accumulate(mul, 1, n, term)                                    =>           \r\n                                                                          =>           \r\n                                                                          =>           \r\n                                                                          =>           \r\n    if combiner == add:                                                   <=           \r\n        k = 1                                                             <=           \r\n        while k <= n:                                                     <=           \r\n            summation_using_accumulate                                    <=           \r\n            k += 1                                                        <=           \r\n        result1 = summation_using_accumulate                              <=           \r\n        return base + result1                                             <=           \r\n        k = 1                                                             <=           \r\n        while k <= n:                                                     <=           \r\n            product_using_accumulate                                      <=           \r\n            k += 1                                                        <=           \r\n        result2 = product_using_accumulate                                <=           \r\n        return base * result2                                             <=           \r\n    total += term(k)                                                      <=           \r\n    total, k = 1, 1                                                       <=           \r\n    def helper(n, term):                                                  <=           \r\n        while k <= n:                                                     <=           \r\n            total, k = total * term(k), k + 1                             <=           \r\n        return total                                                      <=           \r\n    return helper                                                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        k = 1\n        while k <= n:\n            summation_using_accumulate\n            k += 1\n        result1 = summation_using_accumulate\n        return base + result1\n\n    else:\n        k = 1\n        while k <= n:\n            product_using_accumulate\n            k += 1\n        result2 = product_using_accumulate\n        return base * result2\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))))))), 0), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 82, in accumulate","    return base + result1","TypeError: unsupported operand type(s) for +: 'int' and 'function'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":456,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        result, i = combiner(term(i), result), i + 1 =>           \r\n        total, i = combiner(term(i), result), i + 1  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result, i = base, 1\n    while i<= n:\n        total, i = combiner(term(i), result), i + 1\n    return result\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result, i = base, 1\n    while i<= n:\n        result, i = combiner(term(i), result), i + 1\n    return result\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-result)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":457,"diff":"\r\nInputObject                                                                                                                               SideIndic\r\n                                                                                                                                          ator     \r\n-----------                                                                                                                               ---------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))                                                                   =>       \r\n    accumulate(lambda x, y: combiner (x,y) if pred(x) and pred(y) else combiner(x, accumulate(combiner, base, n-1, term)), base, n, term) =>       \r\n                                                                                                                                          =>       \r\n    k, result = 1, base                                                                                                                   <=       \r\n    while (k <= n):                                                                                                                       <=       \r\n        result = combiner(result, term(k))                                                                                                <=       \r\n        k = next(k)                                                                                                                       <=       \r\n    return result                                                                                                                         <=       \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\"\"\"                                                                <=       \r\n    accumulate(lambda x, y: combiner (x,y) if pred(x) and pred(y) else base, base, n, term)                                               <=       \r\n    \"\"\"                                                                                                                                   <=       \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k, result = 1, base\n    while (k <= n):\n        result = combiner(result, term(k))\n        k = next(k)\n    return result\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\"\"\"","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    if n==0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0))))), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"ConstantExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))))), Selected(\\x => Match(x, Node(ParenthesisExpressionNode, TChild(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-accumulate)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1))))), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0), 2), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0), 3), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), 4), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term)))))))))))))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast)))))))))))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    k = next(k)","TypeError: 'int' object is not an iterator","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":459,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n    result = combiner(base, term(n))                 =>           \r\n    while n>1:                                       =>           \r\n        result, n = combiner(result, term(n-1)), n-1 =>           \r\n    k=0                                              <=           \r\n    result = combiner(base, term(k))                 <=           \r\n    while k<n:                                       <=           \r\n        result, k = combiner(result, term(k+1)), k+1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k=0\n    result = combiner(base, term(k))\n    while k<n:\n        result, k = combiner(result, term(k+1)), k+1\n    return result\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result = combiner(base, term(n))\n    while n>1:\n        result, n = combiner(result, term(n-1)), n-1\n    return result\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThan, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":462,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        if n == 0:         =>           \r\n            return term(0) =>           \r\n        elif x == 1:       =>           \r\n                           =>           \r\n    if n == 0:             <=           \r\n        return term(0)     <=           \r\n        if x == 1:         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return term(0)\n    def helper(x, term):\n        if x == 1:\n            return term(1)\n        else:\n            return combiner(term(x), helper(x-1, term))\n    return combiner(base, helper(n, term))\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    def helper(x, term):\n        if n == 0:\n            return term(0)\n        elif x == 1:\n            return term(1)\n        else:\n            return combiner(term(x), helper(x-1, term))\n    return combiner(base, helper(n, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(FunctionDefinitionNode-helper, Children(LeafConstNode(ParameterNode-x), Children(LeafConstNode(ParameterNode-term), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(IfStatementNode, Children(ReferenceNode(node, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), 0), Children(ReferenceNode(node, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), 0), SingleChild(ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), 0))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Target(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","0","","# Error: expected","#     11","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":463,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n        start += 1 =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    start = 1\n    total = base\n    while start <= n:\n        total = combiner(term(start), total)\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    start = 1\n    total = base\n    while start <= n:\n        total = combiner(term(start), total)\n        start += 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-start), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     15","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":465,"diff":"\r\nInputObject                                                                         SideIndicator\r\n-----------                                                                         -------------\r\n    if n == 0:                                                                      =>           \r\n        return base                                                                 =>           \r\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))           =>           \r\n    return accumulate(lambda x, y: combiner(x, y) if pred(x) else y, base, n, term) =>           \r\n    k = 0                                                                           <=           \r\n    if k == n:                                                                      <=           \r\n        return term(n)                                                              <=           \r\n        return combiner(base, accumulate(combiner, base, k+1, term))                <=           \r\n    return accumulate(lambda x, y: combiner(x, y) if pred(y) else x, base, n, term) <=           \r\n                                                                                    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 0\n    if k == n:\n        return term(n)\n    else:\n        return combiner(base, accumulate(combiner, base, k+1, term)) \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast)))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    return combiner(base, accumulate(combiner, base, k+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    return combiner(base, accumulate(combiner, base, k+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    return combiner(base, accumulate(combiner, base, k+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    return combiner(base, accumulate(combiner, base, k+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    return combiner(base, accumulate(combiner, base, k+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 86, in accumulate","    return combiner(base, accumulate(combiner, base, k+1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in accumulate","    if k == n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":466,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n    if n == 0:                                =>           \r\n        return base                           =>           \r\n        total = 1                             =>           \r\n        for i in range(2, n+1):               =>           \r\n            total = combiner(total, term(i))  =>           \r\n        return combiner(base, total)          =>           \r\n    else:                                     =>           \r\n    total = 1                                 <=           \r\n    for i in range(2, n+1):                   <=           \r\n        total = combiner(total, term(i))      <=           \r\n    return combiner(base, total)              <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 1\n    for i in range(2, n+1):\n        total = combiner(total, term(i)) \n    return combiner(base, total)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        total = 1\n        for i in range(2, n+1):\n            total = combiner(total, term(i)) \n        return combiner(base, total)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), SingleChild(ConstNode(SuiteStatementNode, Children(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0), Children(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0), SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":469,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n    if n > 0:                                                           =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    if n > 1:                                                           <=           \r\n        return combiner(term(n), accumulate(base, n-1, term(n)))        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n > 1:\n        return combiner(term(n), accumulate(base, n-1, term(n)))\n    else:\n        return base\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n > 0:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n    else:\n        return base\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(term(n), accumulate(base, n-1, term(n)))","TypeError: accumulate() missing 1 required positional argument: 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":470,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(term(n),accumulate(combiner, base, n-1, term))    =>           \r\n        return combiner(term(n)) + accumulate(combiner, base, n-1, term)  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n)) + accumulate(combiner, base, n-1, term) \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return combiner(term(n),accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0), Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 78, in accumulate","    return combiner(term(n)) + accumulate(combiner, base, n-1, term)","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":471,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    for i in range(n):                 =>           \r\n        acc = combiner(acc, term(i+1)) =>           \r\n    for i in range(n+1):               <=           \r\n        acc = combiner(acc, term(i))   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    acc = base \n    for i in range(n+1):\n        acc = combiner(acc, term(i))\n    return acc\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    acc = base \n    for i in range(n):\n        acc = combiner(acc, term(i+1))\n    return acc\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":478,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        if (n == 1) | (n == 0) : =>           \r\n        if n == 1:               <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    #combiner(base, term(n))\n    def helper_function(combiner, n, term):\n        if n == 1:\n            return term(n)\n        else:\n            return combiner(term(n), helper_function(combiner, n - 1, term))\n    return combiner(base, helper_function(combiner, n, term))  \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    #combiner(base, term(n))\n    def helper_function(combiner, n, term):\n        if (n == 1) | (n == 0) :\n            return term(n)\n        else:\n            return combiner(term(n), helper_function(combiner, n - 1, term))\n    return combiner(base, helper_function(combiner, n, term))  \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-BitwiseOr, Children(ConstNode(ParenthesisExpressionNode, SingleChild(ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0))), SingleChild(ConstNode(ParenthesisExpressionNode, SingleChild(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0))))))))), 0), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function","    return combiner(term(n), helper_function(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function","    return combiner(term(n), helper_function(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function","    return combiner(term(n), helper_function(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function","    return combiner(term(n), helper_function(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function","    return combiner(term(n), helper_function(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 83, in helper_function","    return combiner(term(n), helper_function(combiner, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 80, in helper_function","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":479,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    if n == 0:                                                      =>           \r\n        return base                                                 =>           \r\n        return combiner(accumulate(combiner,base,n-1,term),term(n)) =>           \r\n    else:                                                           =>           \r\n    return base + term(combiner(n))                                 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    return base + term(combiner(n))\n\n    \n    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner(accumulate(combiner,base,n-1,term),term(n))\n\n    \n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-combiner), 0), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0))))))))))), 1), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0)))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0))))))))))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))))))))))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast)))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    return base + term(combiner(n))","TypeError: op_add expected 2 arguments, got 1","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":483,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n        total=combiner(term(n),base)               =>           \r\n        return accumulate(combiner,total,n-1,term) =>           \r\n        return accumulate(combiner,base,n-1,term)  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base \n    else:\n        return accumulate(combiner,base,n-1,term)","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base \n    else:\n        total=combiner(term(n),base)\n        return accumulate(combiner,total,n-1,term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 0), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":485,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        x = combiner(x, term(i))             =>           \r\n        total = total * combiner(x, term(i)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 0\n    x = base\n    while i < n:\n        i = i + 1\n        total = total * combiner(x, term(i))\n    return x","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 0\n    x = base\n    while i < n:\n        i = i + 1\n        x = combiner(x, term(i))\n    return x","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-x)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    total = total * combiner(x, term(i))","UnboundLocalError: local variable 'total' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":487,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        if combiner==add: =>           \r\n        if combiner==mul: =>           \r\n        if add:           <=           \r\n        if mul:           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    sum = base\n    for x in range (1,n+1):\n        if term==square:\n            x=x**2\n        if term==triple:\n            x=x**3\n        if add:\n            sum+=x\n        if mul:\n            sum*=x\n    return sum\n    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    sum = base\n    for x in range (1,n+1):\n        if term==square:\n            x=x**2\n        if term==triple:\n            x=x**3\n        if combiner==add:\n            sum+=x\n        if combiner==mul:\n            sum*=x\n    return sum\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-combiner), SingleChild(ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)))), 0), Selected(\\x => Match(x, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-combiner), SingleChild(ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)))), 0), Selected(\\x => Match(x, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","645","","# Error: expected","#     15","# but got","#     645","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":489,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(base, accumulate(combiner, term(n), n-1, term)) =>           \r\n    if n == 1:                                                          <=           \r\n        return term(n)                                                  <=           \r\n        return combiner(base, accumulate(combiner, n, n-1, term))       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # totalAccumulate = 1\n    # p = 1\n    # while n >= p:\n    #     totalAccumulate = combiner(totalAccumulate, term(p))\n    #     p = p + 1\n    # return combiner(totalAccumulate, base)\n\n    # if n == 0:\n    #     return combiner(totalAccumulate, base)\n    # totalAccumulate = combiner(totalAccumulate, term(n))\n    # accumulate(combiner, base, n-1, term(n))\n\n    if n == 0:\n        return base\n    if n == 1:\n        return term(n)\n    else:\n        return combiner(base, accumulate(combiner, n, n-1, term))\n\n    # while n >= 1:\n    #     totalAccumulate = combiner(base, term(n))\n    #     n = n - 1 \n    # return totalAccumulate\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # totalAccumulate = 1\n    # p = 1\n    # while n >= p:\n    #     totalAccumulate = combiner(totalAccumulate, term(p))\n    #     p = p + 1\n    # return combiner(totalAccumulate, base)\n\n    # if n == 0:\n    #     return combiner(totalAccumulate, base)\n    # totalAccumulate = combiner(totalAccumulate, term(n))\n    # accumulate(combiner, base, n-1, term(n))\n\n    if n == 0:\n        return base\n    else:\n        return combiner(base, accumulate(combiner, term(n), n-1, term))\n\n    # while n >= 1:\n    #     totalAccumulate = combiner(base, term(n))\n    #     n = n - 1 \n    # return totalAccumulate\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)))))), 2), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast)))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","13","","# Error: expected","#     15","# but got","#     13","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":491,"diff":"\r\nInputObject                                             SideIndicator\r\n-----------                                             -------------\r\n    k=1                                                 =>           \r\n    while k<=n:                                         =>           \r\n        result,k=combiner(result,term(k)), k+1          =>           \r\n    while base<=n:                                      <=           \r\n        result,base=combiner(result,term(base)), base+1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result=base\n    while base<=n:\n        result,base=combiner(result,term(base)), base+1\n    return result\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    result=base\n    k=1\n    while k<=n:\n        result,k=combiner(result,term(k)), k+1\n    return result\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","11","","# Error: expected","#     26","# but got","#     11","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":492,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    while n > 0:      =>           \r\n        n-=1          =>           \r\n    while count <= n: <=           \r\n        count += 1    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    start = base\n    count = 1\n    while count <= n:\n        start = combiner(start, term(n))\n        count += 1\n    return start\n\n    \"\"\"\n    if combiner == mul:\n        return (base * product(n,term))\n    else:\n        summation = base\n        while n > 0:\n            summation += term(n)\n            n -= 1\n        return summation\n    \"\"\"","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    start = base\n    count = 1\n    while n > 0:\n        start = combiner(start, term(n))\n        n-=1\n    return start\n\n    \"\"\"\n    if combiner == mul:\n        return (base * product(n,term))\n    else:\n        summation = base\n        while n > 0:\n            summation += term(n)\n            n -= 1\n        return summation\n    \"\"\"","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThan, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatementNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(ReferenceNode(node, Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":493,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        if n == 1:         =>           \r\n            return term(1) =>           \r\n            return 0       =>           \r\n            return term(0) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulated_terms(n):\n        if n == 0:\n            return term(0)\n        return combiner(term(n), accumulated_terms(n-1))\n\n    return combiner(base, accumulated_terms(n))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def accumulated_terms(n):\n        if n == 1:\n            return term(1)\n        if n == 0:\n            return 0\n        return combiner(term(n), accumulated_terms(n-1))\n\n    return combiner(base, accumulated_terms(n))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-0)))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulated_terms, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":494,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    k = 1         =>           \r\n    while k <= n: =>           \r\n    k = 0         <=           \r\n    while k < n:  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 0\n    while k < n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k = 1\n    while k <= n:\n        total = combiner(total, term(k))\n        k += 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":549,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    i = 1         =>           \r\n    while i <= n: =>           \r\n    i = 0         <=           \r\n    while i < n:  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 0\n    while i < n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    i = 1\n    while i <= n:\n        total = combiner(total, term(i))\n        i += 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":498,"diff":"\r\nInputObject                                                                     SideIndicator\r\n-----------                                                                     -------------\r\n    return accumulate(combiner, base, n, term if pred(base) else lambda x:0)    =>           \r\n        return 0                                                                <=           \r\n        return combiner(base, term (n)) + accumulate(combiner, base, n-1, term) <=           \r\n    return accumulate(combiner, base, n, term if pred(base) else lambda x :0)   <=           \r\n    if n == 0:                                                                  <=           \r\n    else:                                                                       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return combiner(base, term (n)) + accumulate(combiner, base, n-1, term)\n    index, total = 1, base\n    while index <= n:\n        total = combiner(total, term(index))\n        index += 1\n    return total","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    index, total = 1, base\n    while index <= n:\n        total = combiner(total, term(index))\n        index += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","70","","# Error: expected","#     26","# but got","#     70","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":502,"diff":"\r\nInputObject                                                                             SideIndicator\r\n-----------                                                                             -------------\r\n    if n < 1:                                                                           =>           \r\n        return base                                                                     =>           \r\n        return combiner(accumulate(combiner, base, n-1, term), term(n))                 =>           \r\n    if n == 1:                                                                          <=           \r\n        return term(n)                                                                  <=           \r\n        return combiner(combiner(accumulate(combiner, base, n-1, term), term(n)), base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return combiner(combiner(accumulate(combiner, base, n-1, term), term(n)), base)\n\ndef add_things(x, y):\n    def actualadding(x, y):\n        return x + y\n    return actualadding(x, y)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n < 1:\n        return base\n    else:\n        return combiner(accumulate(combiner, base, n-1, term), term(n))\n\ndef add_things(x, y):\n    def actualadding(x, y):\n        return x + y\n    return actualadding(x, y)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","59","","# Error: expected","#     26","# but got","#     59","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":503,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n        return combiner(term(n-1), base)                                <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(1), base) \n    else:\n        return combiner(term(n-1), base)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(term(1), base) \n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))), 2), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","4","","# Error: expected","#     15","# but got","#     4","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":504,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    if n == 1:                <=           \r\n        return term(1) + base <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    if n == 1:\n        return term(1) + base\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1, term)) \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","108","","# Error: expected","#     72","# but got","#     108","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":505,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(total, term(i)) =>           \r\n    return combiner(total, term(n))      =>           \r\n        total = combiner(total, i)       <=           \r\n    return combiner(total, n)            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    total = base\n    for i in range(1, n):\n        total = combiner(total, i)\n    return combiner(total, n)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    total = base\n    for i in range(1, n):\n        total = combiner(total, term(i))\n    return combiner(total, term(n))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)))))), 2), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)))))), 2), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","17","","# Error: expected","#     25","# but got","#     17","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":509,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n    if n == 0:                                                          =>           \r\n        return base                                                     =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term)) =>           \r\n    else:                                                               =>           \r\n                                                                        =>           \r\n                                                                        =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term)))))))))))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":511,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    while counter <= n: =>           \r\n    while counter < n:  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    total = base\n    while counter < n:\n        total = combiner(total, term(counter))\n        counter += 1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    counter = 1\n    while counter <= n:\n        total = combiner(total, term(counter))\n        counter += 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-counter)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","10","","# Error: expected","#     15","# but got","#     10","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":513,"diff":"\r\nInputObject                                                        SideIndicator\r\n-----------                                                        -------------\r\n    if n == 0:                                                     =>           \r\n        return base                                                =>           \r\n    return combiner(term(n), accumulate(combiner, base, n-1,term)) =>           \r\n    def summation(n,term):                                         <=           \r\n        total, k = 0,1                                             <=           \r\n        while k<=n:                                                <=           \r\n            total,k = total + term(k), k+1                         <=           \r\n            return total                                           <=           \r\n    if combiner == add:                                            <=           \r\n        return base + summation(n,term)                            <=           \r\n        return base + product (n,term)                             <=           \r\n    else:                                                          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def summation(n,term):\n        total, k = 0,1\n        while k<=n:\n            total,k = total + term(k), k+1\n            return total\n    if combiner == add:\n        return base + summation(n,term)\n    else:\n        return base + product (n,term)\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    return combiner(term(n), accumulate(combiner, base, n-1,term))\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(FunctionDefinitionNode-summation, TChildren(Target(LeafWildcard(\"ParameterNode\")), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(FunctionDefinitionNode-summation, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(FunctionDefinitionNode-summation, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(Target(LeafWildcard(\"ParameterNode\")), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(FunctionDefinitionNode-summation, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"ConstantExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"ConstantExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-summation, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-summation, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"ConstantExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)))), SingleChild(ReferenceNode(node, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))))), Selected(\\x => Match(x, Node(FunctionDefinitionNode-summation, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"ConstantExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)))), SingleChild(ReferenceNode(node, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(FunctionDefinitionNode-summation, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-summation, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-summation, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-summation, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-accumulate), 0), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), 1), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), 2), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term)))))))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-summation, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0), 2), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-summation, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-summation, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-summation, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-summation, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))), InOrderSort(ast)))))))))))))))))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":514,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n            sum3 = sum3 * term(p) =>           \r\n            sum3 = sum3 * term(k) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 0\n    p = 1\n    sum2 = 0\n    sum3 = 1\n\n    if combiner == add :\n        while k <= n :\n            sum2 = sum2 + term(k)\n            k += 1\n\n        return base + sum2\n    \n    if combiner == mul :\n        while p <= n :\n            sum3 = sum3 * term(k)\n            p += 1\n\n        return base * sum3\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 0\n    p = 1\n    sum2 = 0\n    sum3 = 1\n\n    if combiner == add :\n        while k <= n :\n            sum2 = sum2 + term(k)\n            k += 1\n\n        return base + sum2\n    \n    if combiner == mul :\n        while p <= n :\n            sum3 = sum3 * term(p)\n            p += 1\n\n        return base * sum3\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-p)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":516,"diff":"\r\nInputObject                                                                         SideIndicator\r\n-----------                                                                         -------------\r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))             =>           \r\n    return accumulate(add, 1, n, identity)                                          =>           \r\n        return combiner(term(n), term(n-1)) + accumulate(combiner, base, n-2, term) <=           \r\n    return _______                                                                  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n<=0:\n        return base\n    else:\n        return combiner(term(n), term(n-1)) + accumulate(combiner, base, n-2, term)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n<=0:\n        return base\n    else:\n        return combiner(term(n), accumulate(combiner, base, n-1, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), 0), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), 0), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), 0), Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), 0), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast)))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","38","","# Error: expected","#     72","# but got","#     38","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":518,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n    total=base     =>           \r\n    k=1            =>           \r\n    while k<=n:    =>           \r\n        k+=1       =>           \r\n    total=1        <=           \r\n    while base<=n: <=           \r\n        base+=1    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total=1\n    while base<=n:\n        total= combiner(total,term(k))\n        base+=1\n    return total    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    total=base\n    k=1\n    while k<=n:\n        total= combiner(total,term(k))\n        k+=1\n    return total    \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(NameExpressionNode-base)))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 75, in accumulate","    total= combiner(total,term(k))","NameError: name 'k' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":523,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        if combiner == add:     =>           \r\n        elif combiner == mul:   =>           \r\n        if combiner == add():   <=           \r\n        elif combiner == mul(): <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        k = combiner(base, term(n))\n        if combiner == add():\n            return combiner(accumulate(combiner, 0, n-1, term), k)\n        elif combiner == mul():\n            return combiner(accumulate(combiner, 1, n-1, term), k)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        k = combiner(base, term(n))\n        if combiner == add:\n            return combiner(accumulate(combiner, 0, n-1, term), k)\n        elif combiner == mul:\n            return combiner(accumulate(combiner, 1, n-1, term), k)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    if combiner == add():","TypeError: op_add expected 2 arguments, got 0","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":525,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    i = 2   =>           \r\n    i = 1   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 0:\n        return base\n    i = 1\n    final = combiner(base, term(1))\n    while i <= n:\n        final = combiner(final, term(i))\n        i += 1\n    return final\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n <= 0:\n        return base\n    final = combiner(base, term(1))\n    i = 2\n    while i <= n:\n        final = combiner(final, term(i))\n        i += 1\n    return final\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-2)))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":526,"diff":"\r\nInputObject                                               SideIndicator\r\n-----------                                               -------------\r\n    total, k = base, 1                                    =>           \r\n        total, k = combiner(term(k), total), increment(k) =>           \r\n    total = 1                                             <=           \r\n    k = 1                                                 <=           \r\n        total = combiner(term(k), total)                  <=           \r\n        k = k + 1                                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 1\n    k = 1\n    while k <= n:\n        total = combiner(term(k), total)\n        k = k + 1\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n        total, k = combiner(term(k), total), increment(k)\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(NameExpressionNode-k)))), SingleChild(ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-base), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-increment)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)))), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(ConstNode(TupleExpressionNode-False, Children(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), SingleChild(LeafConstNode(NameExpressionNode-k)))), SingleChild(ConstNode(TupleExpressionNode-False, Children(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-increment), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)))))))))))), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast)))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":529,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    while a <= n:                          =>           \r\n        result = combiner(term(a), result) =>           \r\n    while(a <= n):                         <=           \r\n        result = combiner(base, term(a))   <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = base\n    a = 1\n    while(a <= n):\n        result = combiner(base, term(a))\n        a += 1\n        # result += 1\n        # a += 1\n    return result\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = base\n    a = 1\n    while a <= n:\n        result = combiner(term(a), result)\n        a += 1\n        # result += 1\n        # a += 1\n    return result\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(WhileStatementNode, TChildren(Target(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ParenthesisExpressionNode, TChild(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-result))), 2), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":530,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return combiner(x, base) // term(n+1) =>           \r\n        return combiner(x, base) / term(n+1)  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    num = 1\n    x = term(1)\n    while num <= n:\n        x = combiner(x, term(num+1))\n        num += 1\n    if combiner == mul:\n        return combiner(x, base) / term(n+1)\n    else:\n        return combiner(x, base) - term(n+1)\n    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    num = 1\n    x = term(1)\n    while num <= n:\n        x = combiner(x, term(num+1))\n        num += 1\n    if combiner == mul:\n        return combiner(x, base) // term(n+1)\n    else:\n        return combiner(x, base) - term(n+1)\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-FloorDivide, Children(ReferenceNode(node, Node(BinaryExpressionNode-Divide, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Divide, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Divide, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","72.0","","# Error: expected","#     72","# but got","#     72.0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":532,"diff":"\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n        base = combiner(base, term(term_iteration)) =>           \r\n    return base                                     =>           \r\n        t = combiner(t, term(term_iteration))       <=           \r\n    return t                                        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    term_iteration = 1\n    while term_iteration < n + 1:\n        t = combiner(t, term(term_iteration))\n        term_iteration += 1\n    return t","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n\n    term_iteration = 1\n    while term_iteration < n + 1:\n        base = combiner(base, term(term_iteration))\n        term_iteration += 1\n    return base","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    t = combiner(t, term(term_iteration))","UnboundLocalError: local variable 't' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":534,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n        return base =>           \r\n        return      <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return \n    else:\n        new_base = combiner(base,term(n))\n        return accumulate(combiner, new_base, (n-1), term)\n    ","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        new_base = combiner(base,term(n))\n        return accumulate(combiner, new_base, (n-1), term)\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-base), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(LeafWildcard(\"ReturnStatementNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","","# Error: expected","#     15","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":535,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n <= 1:                         =>           \r\n        return term(n)                 =>           \r\n    if n <= 1:                         =>           \r\n        return combiner(term(n), base) =>           \r\n    if n == 1:                         <=           \r\n        return term(1)                 <=           \r\n    if n == 1:                         <=           \r\n        return combiner(term(1), base) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <= 1:\n        return combiner(term(n), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    return combiner(term(n), accumulate(combiner, base, n - 1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 70, in accumulate","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":536,"diff":"\r\nInputObject                                                               SideIndicator\r\n-----------                                                               -------------\r\n        return combiner(base, term(n))                                    =>           \r\n        return accumulate(combiner, combiner(base, term(n)), n - 1, term) =>           \r\n        return combiner(total, base)                                      <=           \r\n        total = total + combiner(total, term(n))                          <=           \r\n        return accumulate(combiner, base, n - 1, term, 0)                 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(total, base)\n    else:\n        total = total + combiner(total, term(n))\n        return accumulate(combiner, base, n - 1, term, 0)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    elif n == 1:\n        return combiner(base, term(n))\n    else:\n        return accumulate(combiner, combiner(base, term(n)), n - 1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)))))), 2), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))))))))), Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0))))))))), 0), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))), InOrderSort(ast)))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 76, in accumulate","    total = total + combiner(total, term(n))","UnboundLocalError: local variable 'total' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":537,"diff":"","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total,x = BASE, 1\n    while x<=n:\n        total = COMBINER(term(x), total)\n        x = x+1\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total,x = base, 1\n    while x<=n:\n        total = combiner(term(x), total)\n        x = x+1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    total,x = BASE, 1","NameError: name 'BASE' is not defined","","# Error: expected","#     15","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":542,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n        if i>n: =>           \r\n        if i<n: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i=1\n    def counter(i):\n        if i<n:\n            return 0\n        elif i==n:\n            return term(n)\n        else:\n            return combiner(term(i),counter(i+1))\n    return combiner(base,counter(i))\n\n\n\n\n\n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i=1\n    def counter(i):\n        if i>n:\n            return 0\n        elif i==n:\n            return term(n)\n        else:\n            return combiner(term(i),counter(i+1))\n    return combiner(base,counter(i))\n\n\n\n\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":551,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    if combiner == mul:           =>           \r\n        v = 1                     =>           \r\n    return accumulate(n, term(x)) =>           \r\n    return _______                <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = 1\n    v = 0\n    while n > 0:\n        v = combiner(v, term(x))\n        x = x + 1\n        n = n - 1\n    return combiner(v, base)","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    x = 1\n    v = 0\n    if combiner == mul:\n        v = 1\n    while n > 0:\n        v = combiner(v, term(x))\n        x = x + 1\n        n = n - 1\n    return combiner(v, base)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-combiner), SingleChild(LeafConstNode(NameExpressionNode-mul)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-v), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":556,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n    total, k = base, 1                               =>           \r\n    while k <= n:                                    =>           \r\n        total, k = combiner(total,term(k)), k+1      =>           \r\n    return total                                     =>           \r\n    k = 1                                            <=           \r\n    while k <= n+1:                                  <=           \r\n        total, k = combiner(term(k), term(k+1)), k+2 <=           \r\n    return combiner(total, base)                     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    while k <= n+1:\n    \ttotal, k = combiner(term(k), term(k+1)), k+2\n    return combiner(total, base)\n   \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k <= n:\n    \ttotal, k = combiner(total,term(k)), k+1\n    return total\n   \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-base), SingleChild(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), 1), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","11","","# Error: expected","#     15","# but got","#     11","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":557,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    while n >= 1:                        =>           \r\n        base = combiner(base, term(n))   =>           \r\n                                         =>           \r\n    total = 0                            <=           \r\n        total = combiner(total, term(n)) <=           \r\n    return total                         <=           \r\n        base = combiner(base, term(i))   <=           \r\n        i += 1                           <=           \r\n    while base <= n:                     <=           \r\n    i = 1                                <=           \r\n    while i <= n:                        <=           \r\n    \"\"\"                                  <=           \r\n    \"\"\"                                  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = 0\n    while base <= n:\n        total = combiner(total, term(n))\n        n -= 1\n    return total\n    \"\"\"\n    i = 1\n    while i <= n:\n        base = combiner(base, term(i))\n        i += 1\n    return base\n    \"\"\"\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while n >= 1:\n        base = combiner(base, term(n))\n        n -= 1\n    return base\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     26","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":558,"diff":"\r\nInputObject                                                                  SideIndicator\r\n-----------                                                                  -------------\r\n        return combiner( term(n), accumulate(combiner,base , n - 1 , term) ) =>           \r\n        return combiner( base, accumulate(combiner, 0, n, term) )            <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner( base, accumulate(combiner, 0, n, term) )\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return base\n    else:\n        return combiner( term(n), accumulate(combiner,base , n - 1 , term) )\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner( base, accumulate(combiner, 0, n, term) )","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner( base, accumulate(combiner, 0, n, term) )","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner( base, accumulate(combiner, 0, n, term) )","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner( base, accumulate(combiner, 0, n, term) )","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner( base, accumulate(combiner, 0, n, term) )","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    return combiner( base, accumulate(combiner, 0, n, term) )","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 68, in accumulate","    if n == 0:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     15","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":559,"diff":"\r\nInputObject                                                    SideIndicator\r\n-----------                                                    -------------\r\n    i = 1                                                      =>           \r\n    while i <= n:                                              =>           \r\n        base = combiner(base, term(i))                         =>           \r\n        i= i + 1                                               =>           \r\n    return base                                                =>           \r\n    if combiner == add:                                        <=           \r\n        if n == 0:                                             <=           \r\n            return base                                        <=           \r\n        if n>0:                                                <=           \r\n            return accumulate(combiner, base, term(n-1), term) <=           \r\n    if combiner == mul:                                        <=           \r\n        return base + factorial(n)                             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if combiner == add:\n        if n == 0:\n            return base\n        if n>0:\n            return accumulate(combiner, base, term(n-1), term)\n    if combiner == mul:\n        return base + factorial(n)\n\n\n    \"*** YOUR CODE HERE ***\"","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    i = 1\n    while i <= n:\n        base = combiner(base, term(i))\n        i= i + 1\n    return base\n\n\n    \"*** YOUR CODE HERE ***\"","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0), 1), Selected(\\x => Match(x, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), 0), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(NameExpressionNode-n)))), SingleChild(ConstNode(SuiteStatementNode, Children(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-base), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i))))))))))))))), SingleChild(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-i), SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))))))))))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":569,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n    total = base                                   =>           \r\n        total = combiner(term(k), total)           =>           \r\n    return accumulate(add, 0, n, term)             =>           \r\n    total = 0                                      <=           \r\n        if k == 1:                                 <=           \r\n            total = combiner(base, term(k+1))      <=           \r\n        else:                                      <=           \r\n            total = combiner(term(k+1), term(k+2)) <=           \r\n    return _______                                 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    total = 0\n    while k <= n:\n        if k == 1:\n            total = combiner(base, term(k+1))\n        else:\n            total = combiner(term(k+1), term(k+2))\n        k = k + 1\n\n    return total\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    total = base\n    while k <= n:\n        total = combiner(term(k), total)\n        k = k + 1\n\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0), 2), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))), 0), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","13","","# Error: expected","#     15","# but got","#     13","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":570,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n        if combiner == add: =>           \r\n            result = 0      =>           \r\n        if combiner == mul: =>           \r\n            result = 1      =>           \r\n        result = 0          <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    def helper(i):\n    \tresult = 0\n    \t\n    \tif i <= n:\n    \t\tresult = combiner(result, term(i))\n    \t\treturn combiner(result, helper(i + 1))\n    \telse:\n    \t\treturn result\n    \n    return combiner(base, helper(1))\n    \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \n    def helper(i):\n    \tif combiner == add:\n    \t\tresult = 0\n    \tif combiner == mul:\n    \t\tresult = 1\n    \t\n    \tif i <= n:\n    \t\tresult = combiner(result, term(i))\n    \t\treturn combiner(result, helper(i + 1))\n    \telse:\n    \t\treturn result\n    \n    return combiner(base, helper(1))\n    \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-combiner), SingleChild(LeafConstNode(NameExpressionNode-add)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)))))))), 0), Selected(\\x => Match(x, Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-combiner), SingleChild(LeafConstNode(NameExpressionNode-mul)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-result), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":571,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        accumulation=combiner(base,term(0))   =>           \r\n        accumulutation=combiner(base,term(0)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        accumulutation=combiner(base,term(0))\n    else:\n        accumulation=combiner(base,term(1))\n    for i in range(2,n+1):\n        accumulation=combiner(accumulation, term(i))\n    return accumulation\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        accumulation=combiner(base,term(0))\n    else:\n        accumulation=combiner(base,term(1))\n    for i in range(2,n+1):\n        accumulation=combiner(accumulation, term(i))\n    return accumulation\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-accumulation)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 77, in accumulate","    return accumulation","UnboundLocalError: local variable 'accumulation' referenced before assignment","","# Error: expected","#     11","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":572,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        if n == 0:   =>           \r\n        elif n <= 1: =>           \r\n        if n <= 1:   <=           \r\n        elif n == 0: <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i, total, combiner, base, n, term): \n        if n <= 1:\n            return combiner(total, term(i))\n        elif n == 0:\n            return total \n        else:\n            total = combiner(total, term(i)) \n            return helper(i+1, total, combiner, base, n-1, term)\n\n    return helper(1, base, combiner, base, n, term)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(i, total, combiner, base, n, term): \n        if n == 0:\n            return total \n        elif n <= 1:\n            return combiner(total, term(i))\n        else:\n            total = combiner(total, term(i)) \n            return helper(i+1, total, combiner, base, n-1, term)\n\n    return helper(1, base, combiner, base, n, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-total)))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","12","","# Error: expected","#     11","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":575,"diff":"\r\nInputObject                                                 SideIndicator\r\n-----------                                                 -------------\r\n        return accumulate(combiner, total, n, term)         =>           \r\n        return accumulate(combiner, total, n-1, term)       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"    \n    total = combiner(base, term(n))\n    n = n - 1\n    if n < 1:\n        return total\n    else: \n        return accumulate(combiner, total, n-1, term)      \n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"    \n    total = combiner(base, term(n))\n    n = n - 1\n    if n < 1:\n        return total\n    else: \n        return accumulate(combiner, total, n, term)      \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","9","","# Error: expected","#     15","# but got","#     9","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":576,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        total = combiner(term(i), total) =>           \r\n        total = combiner(term, total)    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k= n+1\n    for i in range(1, k):\n        total = combiner(term, total)\n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    k= n+1\n    for i in range(1, k):\n        total = combiner(term(i), total)\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i)))))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 73, in accumulate","    total = combiner(term, total)","TypeError: unsupported operand type(s) for +: 'function' and 'int'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":577,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    counter = 1 =>           \r\n                =>           \r\n    counter = 0 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 0\n    ans = base\n    while (counter <= n):\n        counter += 1\n        ans = combiner(ans, term(counter))\n    return ans\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    counter = 1\n    ans = base\n    while (counter <= n):\n\n        ans = combiner(ans, term(counter))\n        counter += 1\n    return ans\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-counter), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","21","","# Error: expected","#     15","# but got","#     21","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":578,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        sum, i = combiner(term(i), sum), i+1 =>           \r\n        sum, k = combiner(term(k), sum), i+1 <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    sum, i = base, 1\n    while i<=n:\n        sum, k = combiner(term(k), sum), i+1\n    return sum\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    sum, i = base, 1\n    while i<=n:\n        sum, i = combiner(term(i), sum), i+1\n    return sum\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in accumulate","    sum, k = combiner(term(k), sum), i+1","UnboundLocalError: local variable 'k' referenced before assignment","","# Error: expected","#     15","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":579,"diff":"\r\nInputObject                                      SideIndicator\r\n-----------                                      -------------\r\n        acc_sum = combiner(acc_sum, term(index)) =>           \r\n        acc_sum = combiner(acc_sum, term(n))     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #if n == 0:\n    #    return base\n    #return combiner(term(n), accumulate(combiner,base,n-1, term))\n\n    acc_sum = base \n    index = 1 \n    while index <= n:\n        acc_sum = combiner(acc_sum, term(n))\n        index += 1 \n    return acc_sum \n\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    #if n == 0:\n    #    return base\n    #return combiner(term(n), accumulate(combiner,base,n-1, term))\n\n    acc_sum = base \n    index = 1 \n    while index <= n:\n        acc_sum = combiner(acc_sum, term(index))\n        index += 1 \n    return acc_sum \n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-index)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","25","","# Error: expected","#     15","# but got","#     25","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":580,"diff":"\r\nInputObject                                       SideIndicator\r\n-----------                                       -------------\r\n    total, k = base, 1                            =>           \r\n        total, k = combiner(total, term (k)), k+1 =>           \r\n    total, k = 0, 1                               <=           \r\n        total, k = combiner(term(k), total), k+1  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = 0, 1\n    while k<= n:\n        total, k = combiner(term(k), total), k+1\n    return total","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base, 1\n    while k<= n:\n        total, k = combiner(total, term (k)), k+1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"ConstantExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 1), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":582,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    if n == 1:             =>           \r\n        return term(1)     =>           \r\n        if n == 1:         =>           \r\n            return term(1) =>           \r\n    if n == 0:             <=           \r\n        return 1           <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def sequence(combiner, n, term):\n        if n == 0:\n            return 0\n        return combiner(term(n), sequence(combiner, n - 1, term))\n    return combiner(base, sequence(combiner, n, term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def sequence(combiner, n, term):\n        if n == 0:\n            return 0\n        if n == 1:\n            return term(1)\n        return combiner(term(n), sequence(combiner, n - 1, term))\n    return combiner(base, sequence(combiner, n, term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-sequence, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":584,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n            if combiner(term(a),b)==0: =>           \r\n                b=combiner(term(a),1)  =>           \r\n                b=combiner(term(a),b)  =>           \r\n                return value(a+1,b)    =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    def value (a,b=0):\n        if a<=n:\n            b=combiner(term(a),b)\n            return value(a+1,b)\n        return combiner(b,base)\n    return value(1)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    def value (a,b=0):\n        if a<=n:\n            if combiner(term(a),b)==0:\n                b=combiner(term(a),1)\n                b=combiner(term(a),b)\n                return value(a+1,b)\n            b=combiner(term(a),b)\n            return value(a+1,b)\n        return combiner(b,base)\n    return value(1)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-b), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-a)))))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))), 0), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(SuiteStatementNode, Children(ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-a)))))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-b))))))), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ReferenceNode(node, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)))))), Children(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-b), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-a)))))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-b)))))))))), SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-value), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-a), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-b))))))))))))), 1), Selected(\\x => Match(x, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":586,"diff":"\r\nInputObject                                                  SideIndicator\r\n-----------                                                  -------------\r\n            if n == 1:                                       =>           \r\n                return term(1)                               =>           \r\n            else:                                            =>           \r\n                return combiner(term(n), rec_n((n-1), term)) =>           \r\n            return combiner(term(n), rec_n((n-1), term))     <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def rec_n(n, term):\n        if n == 0:\n            return term(0)\n        else:\n            return combiner(term(n), rec_n((n-1), term))\n    return combiner((base), rec_n(n, term))\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def rec_n(n, term):\n        if n == 0:\n            return term(0)\n        else:\n            if n == 1:\n                return term(1)\n            else:\n                return combiner(term(n), rec_n((n-1), term))\n    return combiner((base), rec_n(n, term))\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(SuiteStatementNode, SingleChild(ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))), SingleChild(ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), 0)))))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","0","","# Error: expected","#     72","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":588,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    k = 1                               =>           \r\n        base = combiner(base, term(k))  =>           \r\n    return base                         =>           \r\n    total, k = base , 1                 <=           \r\n        total = combiner(base, term(k)) <=           \r\n    return combiner( base, total)       <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total, k = base , 1\n    while k <= n:\n        total = combiner(base, term(k))\n        k = k + 1\n    return combiner( base, total)","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    k = 1\n    while k <= n:\n        base = combiner(base, term(k))\n        k = k + 1\n    return base","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast)))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","5","","# Error: expected","#     15","# but got","#     5","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":589,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        base = combiner(base, term(n))     =>           \r\n        base = combiner(base, (n ** term)) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while(n > 0):\n        base = combiner(base, (n ** term))\n        n -= 1\n    return base\n    \"\"\"\n    if combiner is add:\n        for i in range(0, n + 1):\n            base += term(i)\n        return base\n    else: #if combiner is mul\n        for i in range(1, n + 1):\n            base = base * term(i)\n        return base\n    \"\"\"\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    while(n > 0):\n        base = combiner(base, term(n))\n        n -= 1\n    return base\n    \"\"\"\n    if combiner is add:\n        for i in range(0, n + 1):\n            base += term(i)\n        return base\n    else: #if combiner is mul\n        for i in range(1, n + 1):\n            base = base * term(i)\n        return base\n    \"\"\"\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(ParenthesisExpressionNode, TChild(Target(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Power, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0)))), Selected(\\x => Match(x, Node(ParenthesisExpressionNode, TChild(Target(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Power, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0))))))), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in accumulate","    base = combiner(base, (n ** term))","TypeError: unsupported operand type(s) for ** or pow(): 'int' and 'function'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":592,"diff":"\r\nInputObject                                              SideIndicator\r\n-----------                                              -------------\r\n        total_choice = 0                                 =>           \r\n        total_choice = 1                                 =>           \r\n    return  counter(combiner,base,n,term,total_choice,1) =>           \r\n        count_choice = 0                                 <=           \r\n        count_choice = 1                                 <=           \r\n    return  counter(combiner,base,n,term,1,count_choice) <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if combiner(0,7) != 0:\n        count_choice = 0\n    else:\n        count_choice = 1\n    def counter(combiner,base,n,term,total,count):\n        if count <= n:\n            placeholder = int(term(count))\n            total = combiner(total,placeholder)\n            return counter(combiner,base,n,term,total,count+1)\n        else:\n            return combiner(base,total)\n\n    return  counter(combiner,base,n,term,1,count_choice)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if combiner(0,7) != 0:\n        total_choice = 0\n    else:\n        total_choice = 1\n    def counter(combiner,base,n,term,total,count):\n        if count <= n:\n            placeholder = int(term(count))\n            total = combiner(total,placeholder)\n            return counter(combiner,base,n,term,total,count+1)\n        else:\n            return combiner(base,total)\n\n    return  counter(combiner,base,n,term,total_choice,1)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total_choice)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total_choice)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total_choice)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":593,"diff":"\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n        base= combiner(term(n),base) =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        return accumulate(combiner,base,n-1,term)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return base\n    else:\n        base= combiner(term(n),base)\n        return accumulate(combiner,base,n-1,term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-base), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 0), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","0","","# Error: expected","#     15","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":594,"diff":"\r\nInputObject                                                  SideIndicator\r\n-----------                                                  -------------\r\n    def function(operation, n, term, total, i=1):            =>           \r\n        return function(operation, n, term, total, i+1)      =>           \r\n    if combiner == mul:                                      =>           \r\n        total = 1                                            =>           \r\n        total = 0                                            =>           \r\n    return combiner(base, function(combiner, n,term, total)) =>           \r\n    else:                                                    =>           \r\n                                                             =>           \r\n    def function(operation, n, term, i=1, total=0):          <=           \r\n        if operation == mul:                                 <=           \r\n            total=1                                          <=           \r\n        return function(operation, n, term, i+1, total)      <=           \r\n                                                             <=           \r\n    return combiner(base, function(combiner, n,term))        <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def function(operation, n, term, i=1, total=0):\n        if operation == mul:\n            total=1\n        if i > n:\n            return total\n        total = operation(total, term(i))\n        return function(operation, n, term, i+1, total)\n    \n    return combiner(base, function(combiner, n,term))\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def function(operation, n, term, total, i=1):\n        if i > n:\n            return total\n        total = operation(total, term(i))\n        return function(operation, n, term, total, i+1)\n\n    if combiner == mul:\n        total = 1\n    else:\n        total = 0\n    return combiner(base, function(combiner, n,term, total))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(ParameterNode-total), 3), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(FunctionDefinitionNode-function, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(Node(ParameterNode-i, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ParameterNode-total, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(FunctionDefinitionNode-function, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(Node(ParameterNode-i, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(ParameterNode-total, TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(FunctionDefinitionNode-function, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(Node(ParameterNode-i, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ParameterNode-total, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-function, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(Node(ParameterNode-i, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ParameterNode-total, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 4), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-combiner), SingleChild(LeafConstNode(NameExpressionNode-mul)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(ConstantExpressionNode-0))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-function, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(Node(ParameterNode-i, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ParameterNode-total, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 4), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast)))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","11",">>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2","25",">>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2","2","","# Error: expected","#     72","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":595,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n <= 0:      =>           \r\n        return base =>           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def terms(func, m): # This function uses combiner to mesh the terms together\n        if m == n:\n            return func(m)\n        else:\n            return combiner(func(m), terms(func, m + 1))\n    return combiner(base, terms(term, 1)) # This function ties the base to the series formed by terms(term, n)\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def terms(func, m): # This function uses combiner to mesh the terms together\n        if m == n:\n            return func(m)\n        else:\n            return combiner(func(m), terms(func, m + 1))\n    if n <= 0:\n        return base\n    return combiner(base, terms(term, 1)) # This function ties the base to the series formed by terms(term, n)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-terms, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","26",">>> accumulate(add, 11, 0, identity) # 11","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms","    return combiner(func(m), terms(func, m + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms","    return combiner(func(m), terms(func, m + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms","    return combiner(func(m), terms(func, m + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms","    return combiner(func(m), terms(func, m + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms","    return combiner(func(m), terms(func, m + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 74, in terms","    return combiner(func(m), terms(func, m + 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 71, in terms","    if m == n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     11","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":600,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    if n == 1:                         =>           \r\n    elif n ==0:                        =>           \r\n        return combiner(term(0), base) =>           \r\n    if n == 0:                         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 0:\n        return combiner(term(1), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n == 1:\n        return combiner(term(1), base)\n    elif n ==0:\n        return combiner(term(0), base)\n    else:\n        return combiner(term(n), accumulate(combiner, base, n - 1, term)) \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-base)))))))))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","16","","# Error: expected","#     15","# but got","#     16","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":601,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    t, i = base, 1                       =>           \r\n        t = combiner(t, term(i))         =>           \r\n    return t                             =>           \r\n    return accumulate(combiner(n, term)) =>           \r\n    t, i = 1, 1                          <=           \r\n        t = term(i)                      <=           \r\n    return t * 3                         <=           \r\n    return _______                       <=           \r\n    \"*** YOUR CODE HERE ***\"             <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    t, i = 1, 1\n    while i <= n:\n        t = term(i)\n        i += 1\n    return t * 3\n    \n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    t, i = base, 1\n    while i <= n:\n        t = combiner(t, term(i))\n        i += 1\n    return t\n    \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"ConstantExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-t))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))))))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","15",">>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5","15","","# Error: expected","#     26","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":602,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        total = combiner(total, term(i))      =>           \r\n        total = combiner(term(i-1), term(i))  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        total = combiner(term(i-1), term(i)) \n    return total\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    total = base\n    for i in range(1, n+1):\n        total = combiner(total, term(i)) \n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0), 1), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","9","","# Error: expected","#     15","# but got","#     9","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":603,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    if n >= 1:      =>           \r\n        return base =>           \r\n    if n >= 2:      <=           \r\n        return 1    <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n >= 2:\n        return accumulate(combiner, combiner(base, term(n)), n - 1, term)\n    else:\n        return 1","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n >= 1:\n        return accumulate(combiner, combiner(base, term(n)), n - 1, term)\n    else:\n        return base","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-base)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","1","","# Error: expected","#     15","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":604,"diff":"\r\nInputObject                                                                       SideIndicator\r\n-----------                                                                       -------------\r\n    return accumulate(add, 0, n, term)                                            =>           \r\n    return accumulate(mul, 1, n, term)                                            =>           \r\n    return accumulate(lambda a,x: combiner(a,x) if pred(x) else a, base, n, term) =>           \r\n    term_number = 0                                                               <=           \r\n    result = base                                                                 <=           \r\n    if combiner == add:                                                           <=           \r\n        while term_number < n:                                                    <=           \r\n            result += term(term_number)                                           <=           \r\n        return result                                                             <=           \r\n    elif combiner == mul:                                                         <=           \r\n        while term_number < n:                                                    <=           \r\n            result *= term(term_number)                                           <=           \r\n        return result                                                             <=           \r\n    return accumulate(add, lambda base: base , n, term  )                         <=           \r\n    return _______                                                                <=           \r\n    return _______                                                                <=           \r\n                                                                                  <=           \r\n                                                                                  <=           \r\n    \"*** YOUR CODE HERE ***\"                                                      <=           \r\n                                                                                  <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    term_number = 0\n    result = base\n    if combiner == add:\n        while term_number < n:\n            result += term(term_number)\n        return result\n    elif combiner == mul:\n        while term_number < n:\n            result *= term(term_number)\n        return result\n\n\n    def helper(a,n):\n        if n == 0:\n            return a\n        else:\n            a = combiner(a, term(n))\n        return helper(a, n-1)\n    return helper(base, n)\n\n","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    def helper(a,n):\n        if n == 0:\n            return a\n        else:\n            a = combiner(a, term(n))\n        return helper(a, n-1)\n    return helper(base, n)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     15","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":608,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n        return accumulate(combiner,combiner(base,term(n)),n-1,term) =>           \r\n    if n==1:                                                        <=           \r\n        return combiner(base,term(n))                               <=           \r\n        return combiner(base,accumulate(combiner,n-1,term))         <=           \r\n\r\n\r\n","before":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    if n==1:\n        return combiner(base,term(n))\n    else:\n        return combiner(base,accumulate(combiner,n-1,term))","after":"def accumulate(combiner, base, n, term):\n    \"\"\"Return the result of combining the first N terms in a sequence.  The\n    terms to be combined are TERM(1), TERM(2), ..., TERM(N).  COMBINER is a\n    two-argument function.  Treating COMBINER as if it were a binary operator,\n    the return value is\n        BASE COMBINER TERM(1) COMBINER TERM(2) ... COMBINER TERM(N)\n\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\n    15\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\n    26\n    >>> accumulate(add, 11, 0, identity) # 11\n    11\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\n    25\n    >>> accumulate(mul, 2, 3, square)   # 2 * 1^2 * 2^2 * 3^2\n    72\n    \"\"\"\n    if n==0:\n        return base\n    else:\n        return accumulate(combiner,combiner(base,term(n)),n-1,term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner)))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0), 2), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0), 3), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), 4), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ReferenceNode(node, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-accumulate), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-combiner))), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0))), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term)))))))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-accumulate, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))))), InOrderSort(ast)))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for accumulate","",">>> from hw02 import *",">>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 72, in accumulate","    return combiner(base,accumulate(combiner,n-1,term))","TypeError: accumulate() missing 1 required positional argument: 'term'","","# Error: expected","#     15","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}]]