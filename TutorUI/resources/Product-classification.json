[[{"Id":1,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while k <= n: =>           \r\n    if k <= n:    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 1\n    a = 1\n    if k <= n:\n    \ta = a * term(k)\n    \tk += 1\n    return a ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 1\n    a = 1\n    while k <= n:\n    \ta = a * term(k)\n    \tk += 1\n    return a ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(WhileStatementNode, Children(ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0), SingleChild(ReferenceNode(node, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), 0))))), Selected(\\x => Match(x, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), 0), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":2,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n            y *= term(x) =>           \r\n            y * term(x)  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(x, y):\n    \tif x == n:\n    \t\treturn y * term(n)\n    \telse:\n    \t\ty * term(x)\n    \t\treturn helper(x + 1, y)\n    return helper(1, 1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(x, y):\n    \tif x == n:\n    \t\treturn y * term(n)\n    \telse:\n    \t\ty *= term(x)\n    \t\treturn helper(x + 1, y)\n    return helper(1, 1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatementNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))))), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0), 0), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","3","","# Error: expected","#     6","# but got","#     3","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":3,"diff":"\r\nInputObject                        SideIndicator\r\n-----------                        -------------\r\n        product= product*term(num) =>           \r\n        num+=1                     =>           \r\n        product= product*term(n)   <=           \r\n        n+=1                       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    num=2\n    product= term(1)\n    while num<=n:\n        product= product*term(n)\n        n+=1\n    return product","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    num=2\n    product= term(1)\n    while num<=n:\n        product= product*term(num)\n        num+=1\n    return product","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-num)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-num)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":4,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        total=total*term(k)      =>           \r\n        total=total*term_of_n(k) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    total, k=1,1\n    while k<=n:\n        total=total*term_of_n(k)\n        k+=1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    total, k=1,1\n    while k<=n:\n        total=total*term(k)\n        k+=1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    total=total*term_of_n(k)","NameError: name 'term_of_n' is not defined","","# Error: expected","#     6","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":36,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    return term(n)*product(n-1,term)     =>           \r\n    return turm(n)*product(n-1,term)     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if (n==1):\n    \treturn term(n)\n    return turm(n)*product(n-1,term)    ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if (n==1):\n    \treturn term(n)\n    return term(n)*product(n-1,term)    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return turm(n)*product(n-1,term)","NameError: name 'turm' is not defined","","# Error: expected","#     6","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":151,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return tern(n) * product(n-1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return tern(n) * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return tern(n) * product(n-1, term)","NameError: name 'tern' is not defined","","# Error: expected","#     6","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":383,"diff":"\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n        total_product = term(i) * total_product     =>           \r\n        total_product = identity(i) * total_product <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total_product = 1\n    while i <= n:\n        total_product = identity(i) * total_product\n        i += 1\n\n    return total_product","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total_product = 1\n    while i <= n:\n        total_product = term(i) * total_product\n        i += 1\n\n    return total_product","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":5,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n        return 1                        =>           \r\n    return term(n) * product(n-1, term) =>           \r\n        return 0                        <=           \r\n    return term * product(n-1, term)    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 0\n    return term * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    return term * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    return term * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    return term * product(n-1, term)","TypeError: unsupported operand type(s) for *: 'function' and 'int'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":7,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    result = term(1)              =>           \r\n    for i in range (1, n+1):      =>           \r\n        result = term(i) * result =>           \r\n    return result                 =>           \r\n    \"*** YOUR CODE HERE ***\"      <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    result = term(1)\n    for i in range (1, n+1):\n        result = term(i) * result\n    return result ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-result), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ForStatementNode, Children(LeafConstNode(NameExpressionNode-i), Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-range), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-result), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i)))))), SingleChild(LeafConstNode(NameExpressionNode-result))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-result)), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-result)))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":8,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return term(n) * term(n-1)          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * term(n-1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":79,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n)*product(n - 1, term) =>           \r\n        return term(n)*term(n-1)            <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return 1\n    else:\n        return term(n)*term(n-1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return 1\n    else:\n        return term(n)*product(n - 1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":84,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return term(n) * product(n - 1, term) =>           \r\n        return term(n) * term(n - 1)          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * term(n - 1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n - 1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":99,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        return term(n)*product(n-1, term) =>           \r\n    if n == 1:                            =>           \r\n        return 1                          =>           \r\n        return n*factorial(n-1)           =>           \r\n    else:                                 =>           \r\n        return term(n)*term(n-1)          <=           \r\n    return _______                        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n)*term(n-1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n)*product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":158,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return term(n) * term(n-1)          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n <= 1:\n        return 1\n    else:\n        return term(n) * term(n-1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n <= 1:\n        return 1\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":182,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return term(n) * term(n-1)          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if not n:\n        return term(1)\n    else:\n        return term(n) * term(n-1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if not n:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":277,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    return term(n) * product(n - 1, term) =>           \r\n    return term(n) * term(n - 1)          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    return term(n) * term(n - 1)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    return term(n) * product(n - 1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":304,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return term(n) * term(n-1)          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * term(n-1)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":360,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return product(n - 1, term) * term(n) =>           \r\n        return term(n - 1) * term(n)          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n - 1) * term(n)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return product(n - 1, term) * term(n)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":427,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        return term(n)*product(n-1, term) =>           \r\n        return term(n)*term(n-1)          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return 1\n    else:\n        return term(n)*term(n-1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return 1\n    else:\n        return term(n)*product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":9,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n    \"\"\"while n > 0:\n        term(n) * product(term(n-1), term)\"\"\"\n\n    \"*** YOUR CODE HERE ***\"","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n    \"\"\"while n > 0:\n        term(n) * product(term(n-1), term)\"\"\"\n\n    \"*** YOUR CODE HERE ***\"","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":17,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    while n > 1:\n        total *= term(n)\n        n -= 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while n > 1:\n        total *= term(n)\n        n -= 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":25,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, x = 1, 1 =>           \r\n    total, x = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, x = 0, 1\n    while x <= n:\n        total, x = total * term(x), x +1\n    return total ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, x = 1, 1\n    while x <= n:\n        total, x = total * term(x), x +1\n    return total ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":30,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    count = 1\n    while count <= n:\n        total = total*term(count)\n        count = count + 1\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    count = 1\n    while count <= n:\n        total = total*term(count)\n        count = count + 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":32,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":34,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = 0, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":43,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n    total, counter = 1, 1 =>           \r\n    total, counter = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, counter = 0, 1\n    while counter <= n:\n        total, counter =  total * term(counter), counter + 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, counter = 1, 1\n    while counter <= n:\n        total, counter =  total * term(counter), counter + 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":48,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    k = 1\n    while k <= n:\n        total = total * term(k)\n        k = k + 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    k = 1\n    while k <= n:\n        total = total * term(k)\n        k = k + 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":50,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total = total * term(k)\n        k += 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total = total * term(k)\n        k += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":61,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 0\n    while n > 0:\n        total = total * term (n)\n        n -= 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    while n > 0:\n        total = total * term (n)\n        n -= 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":68,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":75,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    sum=1   =>           \r\n    sum=0   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    sum=0\n    for i in range(1,n+1):\n        sum=sum*term(i) \n    return sum","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    sum=1\n    for i in range(1,n+1):\n        sum=sum*term(i) \n    return sum","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":78,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    total, k = 1, 1  =>           \r\n    total, k = 1, 0  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 0 \n    while k <= n: \n        total, k = total * term(k), k + 1\n    return total ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1 \n    while k <= n: \n        total, k = total * term(k), k + 1\n    return total ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":80,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        total = total * term(i)\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    for i in range(1, n + 1):\n        total = total * term(i)\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":86,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    total=1 =>           \r\n    total=0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i=0\n    total=0\n    while i<n:\n        i+=1\n        total=total*term(i)\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i=0\n    total=1\n    while i<n:\n        i+=1\n        total=total*term(i)\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":89,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    return prod(1,1)  =>           \r\n                      =>           \r\n    return prod(12,1) <=           \r\n                      <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def prod(k,ans):\n        if k ==n+1:\n            return ans\n        else:\n            ans*=term(k)\n            return prod(k+1,ans)\n    return prod(12,1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def prod(k,ans):\n        if k ==n+1:\n            return ans\n        else:\n            ans*=term(k)\n            return prod(k+1,ans)\n    return prod(1,1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in prod","    return prod(k+1,ans)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in prod","    return prod(k+1,ans)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in prod","    return prod(k+1,ans)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in prod","    return prod(k+1,ans)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in prod","    return prod(k+1,ans)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in prod","    return prod(k+1,ans)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in prod","    if k ==n+1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":91,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n        return 1 =>           \r\n        return 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if (n == 0):\n        return 0\n    else:\n        return term(n) * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if (n == 0):\n        return 1\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":95,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 0\n    while i <= n:\n        total *= term(i)\n        i+=1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i <= n:\n        total *= term(i)\n        i+=1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":98,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 1: =>           \r\n    if n == 0: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":104,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n        return 1 =>           \r\n        return 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if (n==0):\n        return 0\n    else:\n        return term(n) * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if (n==0):\n        return 1\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":110,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n        return 1 =>           \r\n        return 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return term(n) * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":112,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    total, k = 1, 1                        =>           \r\n                                           =>           \r\n    return product(n, lambda x: square(x)) =>           \r\n    total, k = 0, 1                        <=           \r\n    if n ==0:                              <=           \r\n        return 0                           <=           \r\n        return n * factorial(n-1)          <=           \r\n    return product (n, lambda x: x)        <=           \r\n    else:                                  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = 0, 1\n    while k <= n:\n        total = term (k) * total\n        k += 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = 1, 1\n    while k <= n:\n        total = term (k) * total\n        k += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":117,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, i = 1, 1 =>           \r\n    total, i = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, i = 0, 1\n    while i <= n:\n        total = total * term(i)\n        i += 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, i = 1, 1\n    while i <= n:\n        total = total * term(i)\n        i += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":127,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = 0, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total \n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":128,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 0\n    for i in range(0, n):\n        total *= term(i + 1)\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    for i in range(0, n):\n        total *= term(i + 1)\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":130,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    x = 1   =>           \r\n    x = 0   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    count = 1\n    x = 0\n    while count <= n:\n        x = x * term(count)\n        count += 1\n    return x\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    count = 1\n    x = 1\n    while count <= n:\n        x = x * term(count)\n        count += 1\n    return x\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":154,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    if n == 1: =>           \r\n    if n == 0: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # result = 1\n    # count = 1\n    # while count <= n:\n    #     result *= term(count)\n    #     count += 1\n    # return result\n    if n == 0:\n        return n\n    else:\n        return term(n) * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # result = 1\n    # count = 1\n    # while count <= n:\n    #     result *= term(count)\n    #     count += 1\n    # return result\n    if n == 1:\n        return n\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":161,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n        return 1 =>           \r\n        return 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return 0\n    else:\n        return term(n) * product(n - 1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return 1\n    else:\n        return term(n) * product(n - 1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":162,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    k = 1\n    while k <= n:\n        total = total * term(k)\n        k += 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    k = 1\n    while k <= n:\n        total = total * term(k)\n        k += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":166,"diff":"\r\nInputObject                                            SideIndicator\r\n-----------                                            -------------\r\n    total, x = 1, 1                                    =>           \r\n    total, x = base, 1                                 =>           \r\n    while x <= n:                                      =>           \r\n        total, x = combiner(base, product(n,term)),x+1 =>           \r\n    return total                                       =>           \r\n    total, x = 0, 1                                    <=           \r\n    \"*** YOUR CODE HERE ***\"                           <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, x = 0, 1\n    while x <= n:\n        total, x = total * term(x), x + 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, x = 1, 1\n    while x <= n:\n        total, x = total * term(x), x + 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":171,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total *= term(k)\n        k += 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total *= term(k)\n        k += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":173,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    k, sum = 1, 1 =>           \r\n    k, sum = 1, 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, sum = 1, 0\n    while k <= n:\n        sum, k = sum*term(k), k+1\n    return sum\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, sum = 1, 1\n    while k <= n:\n        sum, k = sum*term(k), k+1\n    return sum\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":174,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n    i,total = 0, 1 =>           \r\n    i,total = 0, 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    #create a list that has all the values until n (including n)\n    max_count = list (range(1,n+1))\n    #using that list\n    i,total = 0, 0\n\n    while i < n:\n      total *= term(max_count[i])\n      i += 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    #create a list that has all the values until n (including n)\n    max_count = list (range(1,n+1))\n    #using that list\n    i,total = 0, 1\n\n    while i < n:\n      total *= term(max_count[i])\n      i += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":175,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n              =>           \r\n    total = 0 <=           \r\n              <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    i, k = 1, 1\n    total = 0\n\n    while i <= n:\n        total *= term(k)\n        i += 1\n        k += 1\n    \n    return total\n    \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    i, k = 1, 1\n    total = 1\n\n    while i <= n:\n        total *= term(k)\n        i += 1\n        k += 1\n    \n    return total\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":177,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    while(n > 0):\n        total *= term(n)\n        n -= 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while(n > 0):\n        total *= term(n)\n        n -= 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":180,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    k, product = 1, 1 =>           \r\n    k, product = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k, product = 0, 1\n    while k<=n:\n\n        product, k = product*term(k), k +1\n\n    return product\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k, product = 1, 1\n    while k<=n:\n\n        product, k = product*term(k), k +1\n\n    return product\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":190,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":205,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    x, result = 1, 1 =>           \r\n    x, result = 1, 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x, result = 1, 0\n    while x <= n:\n        result = result * term(x)\n        x += 1\n    return result\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x, result = 1, 1\n    while x <= n:\n        result = result * term(x)\n        x += 1\n    return result\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":221,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    k = 1   =>           \r\n    k = 0   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    k = 0\n    while k <= n:\n        total= total * term(k)\n        k += 1\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    k = 1\n    while k <= n:\n        total= total * term(k)\n        k += 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":222,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    k, result = 1, 1 =>           \r\n    k, result = 1, 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k, result = 1, 0\n    while k <= n:\n        k, result = k + 1, result * term(k)\n    return result","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k, result = 1, 1\n    while k <= n:\n        k, result = k + 1, result * term(k)\n    return result","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":224,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n            return 1 =>           \r\n            return 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def product_helper(num):\n        if num > n:\n            return 0\n        else:\n            return term(num) * product_helper(num+1)\n    return product_helper(1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def product_helper(num):\n        if num > n:\n            return 1\n        else:\n            return term(num) * product_helper(num+1)\n    return product_helper(1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":244,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    return multiplier(1, 1) =>           \r\n    return multiplier(1, 0) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def multiplier(x, total):\n        if x > n:\n            return total\n        else:\n            return multiplier(x + 1, total * term(x))\n    return multiplier(1, 0)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def multiplier(x, total):\n        if x > n:\n            return total\n        else:\n            return multiplier(x + 1, total * term(x))\n    return multiplier(1, 1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":252,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    i, total = 1, 1 =>           \r\n    i, total = 1, 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, total = 1, 0\n    while i <= n:\n       total *= term(i)\n       i += 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, total = 1, 1\n    while i <= n:\n       total *= term(i)\n       i += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":255,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n: \n        total, k = total * term(k), k + 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n: \n        total, k = total * term(k), k + 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":268,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    while n >= 1:\n        total *= term(n)\n        n -= 1\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while n >= 1:\n        total *= term(n)\n        n -= 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":291,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    return prod_help(1, 1) =>           \r\n    return prod_help(1, 0) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def prod_help(x, total):\n        total = total * term(x)\n        x += 1\n        if x > n:\n            return total\n        else:\n            return prod_help(x, total)\n    return prod_help(1, 0)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def prod_help(x, total):\n        total = total * term(x)\n        x += 1\n        if x > n:\n            return total\n        else:\n            return prod_help(x, total)\n    return prod_help(1, 1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":298,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    sum =1  =>           \r\n    sum =0  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i=1\n    sum =0\n    while i<=n:\n        sum *= term(i)\n        i+=1\n    return sum","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i=1\n    sum =1\n    while i<=n:\n        sum *= term(i)\n        i+=1\n    return sum","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":300,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    k = 1   =>           \r\n    k = 0   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 0\n    prod = 1\n    while k <= n:\n       prod *= term(k)\n       k += 1\n    return prod","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 1\n    prod = 1\n    while k <= n:\n       prod *= term(k)\n       k += 1\n    return prod","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":302,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    sum = 1 =>           \r\n    sum = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    sum = 0\n    i = 1\n\n    while i <= n:\n        sum = sum * term(i)\n        i += 1\n    return sum\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    sum = 1\n    i = 1\n\n    while i <= n:\n        sum = sum * term(i)\n        i += 1\n    return sum\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":307,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k<=n:\n        total, k = total*term(k), k+1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k<=n:\n        total, k = total*term(k), k+1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":317,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    return counter(1, 1) =>           \r\n    return counter(1, 0) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def counter(i, total):\n        if i > n:\n            return total \n        else:\n            total = total * term(i)\n            return counter(i+1, total)\n    return counter(1, 0)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def counter(i, total):\n        if i > n:\n            return total \n        else:\n            total = total * term(i)\n            return counter(i+1, total)\n    return counter(1, 1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":319,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 1\n    total = 0\n    while k <= n:\n        total = total * term(k)\n        k = k + 1\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 1\n    total = 1\n    while k <= n:\n        total = total * term(k)\n        k = k + 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":322,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":327,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 0\n    while i <= n:\n        total *= term(i)\n        i += 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i <= n:\n        total *= term(i)\n        i += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":328,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    x = 1   =>           \r\n    x = 0   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = 0\n    for i in range(1,n+1):\n        x *= term(i)\n    return (x)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = 1\n    for i in range(1,n+1):\n        x *= term(i)\n    return (x)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":337,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    while n>1: =>           \r\n    while n>0: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    while n>0:\n        return term(n)*product(n-1, term)\n    return term(n)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    while n>1:\n        return term(n)*product(n-1, term)\n    return term(n)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":350,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    k = 1\n    while k <= n:\n        total = total * term(k)\n        k = k + 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    k = 1\n    while k <= n:\n        total = total * term(k)\n        k = k + 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":354,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 0\n    while i <= n:\n        total *= term(i)\n        i += 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i <= n:\n        total *= term(i)\n        i += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":363,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1 ,1 =>           \r\n    total, k = 0,1  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0,1\n    while k <= n:\n        total, k = total * term(k) , k + 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1 ,1\n    while k <= n:\n        total, k = total * term(k) , k + 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":364,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n    i, prod = 1, 1 =>           \r\n    i, prod = 1, 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, prod = 1, 0\n    while i <= n:\n        prod = prod * term(i)\n        i += 1\n    return prod","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, prod = 1, 1\n    while i <= n:\n        prod = prod * term(i)\n        i += 1\n    return prod","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":365,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n    prod, incr_val = 1, 1 =>           \r\n    prod, incr_val = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    prod, incr_val = 0, 1\n    while incr_val <= n:\n        prod, incr_val = prod * term(incr_val), incr_val+1\n    return prod ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    prod, incr_val = 1, 1\n    while incr_val <= n:\n        prod, incr_val = prod * term(incr_val), incr_val+1\n    return prod ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":367,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    for i in range(1, n+1): =>           \r\n    for i in range(0, n+1): <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    for i in range(0, n+1):\n        total = total * term(i)\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    for i in range(1, n+1):\n        total = total * term(i)\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":370,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    sumofproducts = 1 =>           \r\n    sumofproducts = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    sumofproducts = 0\n    i = 1\n    while i <= n:\n        sumofproducts *= term(i)\n        i += 1\n    return sumofproducts","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    sumofproducts = 1\n    i = 1\n    while i <= n:\n        sumofproducts *= term(i)\n        i += 1\n    return sumofproducts","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":372,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    k = 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    k = 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":381,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    total, k=1,1 =>           \r\n    total, k=0,1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\"\"\"\n    total, k=0,1\n    while k<=n:\n        total,k=total*term(k),k+1\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\"\"\"\n    total, k=1,1\n    while k<=n:\n        total,k=total*term(k),k+1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":392,"diff":"\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n    if n==1: =>           \r\n    if n==0: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==0:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":415,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    totalProduct = 1 =>           \r\n    totalProduct = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    totalProduct = 0\n    while count <= n:\n        totalProduct *= term(count)\n        count += 1\n    return totalProduct","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    totalProduct = 1\n    while count <= n:\n        totalProduct *= term(count)\n        count += 1\n    return totalProduct","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":424,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    y = 1   =>           \r\n    y = 0   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = 1\n    y = 0\n    while x <= n:\n        y *= term(x)\n        x += 1\n    return y","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = 1\n    y = 1\n    while x <= n:\n        y *= term(x)\n        x += 1\n    return y","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":436,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":451,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    k, total = 1, 1 =>           \r\n    k, total = 1, 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, total = 1, 0\n    while k <= n:\n        total, k = total * term(k), k+1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, total = 1, 1\n    while k <= n:\n        total, k = total * term(k), k+1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":461,"diff":"\r\nInputObject                    SideIndicator\r\n-----------                    -------------\r\n    def counter(i, total = 1): =>           \r\n    def counter(i, total = 0): <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def counter(i, total = 0):\n        if i == n:\n            return total * term(i)\n        else:\n            return counter(i + 1, total * term(i))\n    return counter(1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def counter(i, total = 1):\n        if i == n:\n            return total * term(i)\n        else:\n            return counter(i + 1, total * term(i))\n    return counter(1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":464,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    k, pro = 1, 1 =>           \r\n    k, pro = 1, 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, pro = 1, 0\n    while k <= n:\n        pro, k = pro*term(k), k + 1\n    return pro","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, pro = 1, 1\n    while k <= n:\n        pro, k = pro*term(k), k + 1\n    return pro","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":473,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n    \ttotal, k = total * term(k), k+1\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n    \ttotal, k = total * term(k), k+1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":480,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    r = 1\n    total = 0\n    while r <= n:\n        total *= term(r)\n        r += 1\n    return total ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    r = 1\n    total = 1\n    while r <= n:\n        total *= term(r)\n        r += 1\n    return total ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":484,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n        return 1 =>           \r\n        return 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 0\n    return term(n) * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":490,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    sum, i = 1, 1 =>           \r\n    sum, i = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    sum, i = 0, 1\n    while i<=n:\n        sum*=term(i)\n        i+=1\n    return sum","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    sum, i = 1, 1\n    while i<=n:\n        sum*=term(i)\n        i+=1\n    return sum","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":491,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = 0, 1\n    while k <= n:\n        total, k =  total * term (k), k + 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, k = 1, 1\n    while k <= n:\n        total, k =  total * term (k), k + 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":492,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n        return 1 =>           \r\n        return 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 0\n    return term(n) * product(n - 1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    return term(n) * product(n - 1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":493,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    i,total = 1,1 =>           \r\n    i,total = 1,0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i,total = 1,0\n    while i <= n:\n    \ttotal = total * term(i)\n    \ti += 1\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i,total = 1,1\n    while i <= n:\n    \ttotal = total * term(i)\n    \ti += 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":512,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    i = 1   =>           \r\n    i = 0   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    product = 1\n    i = 0\n    while (i <= n):\n        product *= term(i)\n        i += 1\n    return product","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    product = 1\n    i = 1\n    while (i <= n):\n        product *= term(i)\n        i += 1\n    return product","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":513,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    total = 1 =>           \r\n    total = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    total = 0\n    while count <= n:\n        total *= term(count)\n        count += 1\n\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    total = 1\n    while count <= n:\n        total *= term(count)\n        count += 1\n\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":517,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n        return 1 =>           \r\n        return 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return term(n) * product(n-1,term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return term(n) * product(n-1,term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":519,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    result = 1 =>           \r\n    result = 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = 0\n    for x in range (1, n+1):\n        result *= term(x)\n    return result\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = 1\n    for x in range (1, n+1):\n        result *= term(x)\n    return result\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":10,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n        return 1 =>           \r\n        return   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return \n    else:\n        return term(n) * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, LeafConstNode(ConstantExpressionNode-1), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(LeafWildcard(\"ReturnStatementNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n) * product(n-1, term)","TypeError: unsupported operand type(s) for *: 'int' and 'NoneType'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":64,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n        return 1 =>           \r\n        return   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    if (n==0):\n        return\n    else:\n        return term(n)* product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    if (n==0):\n        return 1\n    else:\n        return term(n)* product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, LeafConstNode(ConstantExpressionNode-1), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(LeafWildcard(\"ReturnStatementNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in product","    return term(n)* product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in product","    return term(n)* product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in product","    return term(n)* product(n-1, term)","TypeError: unsupported operand type(s) for *: 'int' and 'NoneType'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":11,"diff":"\r\nInputObject                                     SideIndicator\r\n-----------                                     -------------\r\n                                                =>           \r\n    if n == 1:                                  =>           \r\n        return term(n)                          =>           \r\n    else:                                       =>           \r\n        return term(n) * product(n-1, term)     =>           \r\n    def inner_product(n):                       <=           \r\n        if n == 1:                              <=           \r\n            return term(n)                      <=           \r\n        else:                                   <=           \r\n            return term(n) * product(n-1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def inner_product(n):\n        if n == 1:\n            return term(n)\n        else:\n            return term(n) * product(n-1, term)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(FunctionDefinitionNode-inner_product, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(FunctionDefinitionNode-inner_product, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), 0), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(FunctionDefinitionNode-inner_product, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":12,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    if n == 0:   =>           \r\n        return 1 =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    return term(n) * product(n - 1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return 1\n    return term(n) * product(n - 1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    return term(n) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    return term(n) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    return term(n) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    return term(n) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    return term(n) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    return term(n) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    return term(n) * product(n - 1, term)","RecursionError: maximum recursion depth exceeded","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":13,"diff":"\r\nInputObject                    SideIndicator\r\n-----------                    -------------\r\n                               =>           \r\n    if n == 0:                 <=           \r\n        return 1               <=           \r\n                               <=           \r\n        result = n * term(n-1) <=           \r\n    result = 1                 <=           \r\n    return result              <=           \r\n    else:                      <=           \r\n                               <=           \r\n                               <=           \r\n                               <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    result = 1\n    if n == 0:\n        return 1\n    else:\n        \n        result = n * term(n-1)\n\n\n    return result\n\n\n    result = 1\n    \n    number = 1    \n    while n > 0:\n            result = result * term(number)\n            number = number + 1\n            n = n - 1\n\n    return result","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n\n    result = 1\n    \n    number = 1    \n    while n > 0:\n            result = result * term(number)\n            number = number + 1\n            n = n - 1\n\n    return result","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), TChildren(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":14,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n            return helper(i+1, k) =>           \r\n            return helper(i, k)   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper(i,k):\n        if i > n:\n            return k\n        else:\n            k = k * term(i)\n            return helper(i, k)\n    return helper(1,1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper(i,k):\n        if i > n:\n            return k\n        else:\n            k = k * term(i)\n            return helper(i+1, k)\n    return helper(1,1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Skip(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in helper","    return helper(i, k)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in helper","    return helper(i, k)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in helper","    return helper(i, k)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in helper","    return helper(i, k)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in helper","    return helper(i, k)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in helper","    return helper(i, k)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in helper","    if i > n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":176,"diff":"\r\nInputObject                  SideIndicator\r\n-----------                  -------------\r\n        product *= term(i+1) =>           \r\n        product *= term(i)   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i=0\n    product=1\n    while i<n:\n        product *= term(i)\n        i += 1\n    return product","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i=0\n    product=1\n    while i<n:\n        product *= term(i+1)\n        i += 1\n    return product","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Skip(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":215,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n        sum = sum * term(k+1) =>           \r\n        sum = sum * term(k)   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 0\n    sum = 1\n    while k < n:\n        sum = sum * term(k)\n        k += 1\n    return sum\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 0\n    sum = 1\n    while k < n:\n        sum = sum * term(k+1)\n        k += 1\n    return sum\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Skip(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":235,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    for i in range(1, n+1): =>           \r\n    for i in range(1, n):   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    for i in range(1, n):\n        if term == identity:\n            total *= i\n        elif term == square:\n            total *= square(i)\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    for i in range(1, n+1):\n        if term == identity:\n            total *= i\n        elif term == square:\n            total *= square(i)\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Skip(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":245,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n        product = product * term(i + 1) =>           \r\n        product = product * term(i)     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    product = term(1)\n    for i in range(1, n):\n\t    product = product * term(i)\n    return product","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    product = term(1)\n    for i in range(1, n):\n\t    product = product * term(i + 1)\n    return product","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Skip(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":299,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    for i in range(1,n+1): =>           \r\n    for i in range(1,n):   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    product=1\n    for i in range(1,n):\n        number=term(i)\n        product=product*number\n    return product","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    product=1\n    for i in range(1,n+1):\n        number=term(i)\n        product=product*number\n    return product","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Skip(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":377,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    for i in range(1, n+1): =>           \r\n    for i in range(1, n):   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    j = 1\n    for i in range(1, n):\n    \tj*=term(i)\n    return j","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    j = 1\n    for i in range(1, n+1):\n    \tj*=term(i)\n    return j","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Skip(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":15,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n)                      =>           \r\n        return term(n) * product(n-1, term) =>           \r\n    prod = iterm                            =>           \r\n    if n == 1:                              =>           \r\n    else:                                   =>           \r\n                                            =>           \r\n    prod = iterm*prod                       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    iterm = term(n)\n    prod = iterm*prod\n    if n == 1:\n        return prod\n    else:\n        return product(n-1, term)\n    '''def counter(n):\n        if n == 1:\n            return prod\n        else:\n            n -= 1\n            prod = prod * term(n)\n            return counter(n)\n    return counter(n)\n'''","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)\n\n    iterm = term(n)\n    prod = iterm\n    if n == 1:\n        return prod\n    else:\n        return product(n-1, term)\n    '''def counter(n):\n        if n == 1:\n            return prod\n        else:\n            n -= 1\n            prod = prod * term(n)\n            return counter(n)\n    return counter(n)\n'''","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))))))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    prod = iterm*prod","UnboundLocalError: local variable 'prod' referenced before assignment","","# Error: expected","#     6","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":16,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        return term(n)*product(n-1,term) =>           \r\n        return (n)*product(n-1,term)     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n   \n    if n==1:\n        return 1\n    else:\n        return (n)*product(n-1,term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n   \n    if n==1:\n        return 1\n    else:\n        return term(n)*product(n-1,term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(ParenthesisExpressionNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(ParenthesisExpressionNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(ParenthesisExpressionNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":18,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return term(n) * product(n - 1, term) =>           \r\n        return term(n) + product(n - 1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) + product(n - 1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n - 1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":114,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n        return term(i) * mult_up(i+1) =>           \r\n        return term(i) + mult_up(i+1) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def mult_up(i):\n        if(i==n):\n            return term(n)\n        return term(i) + mult_up(i+1)\n\n    return mult_up(1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def mult_up(i):\n        if(i==n):\n            return term(n)\n        return term(i) * mult_up(i+1)\n\n    return mult_up(1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(LeafWildcard(\"CallExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":167,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n            return term(i)* counter(i+1) =>           \r\n            return term(i)+ counter(i+1) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def counter(i):\n        \n        if i == n:\n            return term(i)\n        else:\n            return term(i)+ counter(i+1)\n    return counter(1)        \n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def counter(i):\n        \n        if i == n:\n            return term(i)\n        else:\n            return term(i)* counter(i+1)\n    return counter(1)        \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(LeafWildcard(\"CallExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":194,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return term(n) * product(n - 1, term) =>           \r\n    return product(n, identity)               =>           \r\n        return term(n) + product(n - 1, term) <=           \r\n    return _______                            <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) + product(n - 1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n - 1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(LeafWildcard(\"CallExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":232,"diff":"\r\nInputObject                                    SideIndicator\r\n-----------                                    -------------\r\n        return product(n-1,term) * term(n)     =>           \r\n        return product(n-1,term) + term(n)     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return product(n-1,term) + term(n)    ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return product(n-1,term) * term(n)    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":274,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n            return term(R) * helper(R+1) =>           \r\n            return term(R) + helper(R+1) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper (R) :\n        if R == n :\n            return term(n)\n        else :\n            return term(R) + helper(R+1)\n    return helper(1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper (R) :\n        if R == n :\n            return term(n)\n        else :\n            return term(R) * helper(R+1)\n    return helper(1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":276,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return term(n) + product(n-1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==0:\n        return 0\n    elif n==1:\n        return term(1)\n    else:\n        return term(n) + product(n-1, term)\n\n    ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==0:\n        return 0\n    elif n==1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)\n\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":290,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return term(n) + product(n-1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) + product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":313,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return term(n) + product(n-1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return term(n) + product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","7","","# Error: expected","#     6","# but got","#     7","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":326,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return term(n) * product(n - 1, term) =>           \r\n                                              =>           \r\n        return term(n) + product(n - 1, term) <=           \r\n                                              <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) + product(n - 1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n - 1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":346,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    return term(n)* product(n-1, term) =>           \r\n    return term(n)+ product(n-1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n ==1:\n        return n\n    return term(n)+ product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n ==1:\n        return n\n    return term(n)* product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":351,"diff":"\r\nInputObject                                    SideIndicator\r\n-----------                                    -------------\r\n        return square(n) * product((n-1),term) =>           \r\n        return square(n)+ product((n-1),term)  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n== 1:\n        return n\n    elif term == square:\n        return square(n)+ product((n-1),term)\n    else:\n        return n* product((n-1),term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n== 1:\n        return n\n    elif term == square:\n        return square(n) * product((n-1),term)\n    else:\n        return n* product((n-1),term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","14","","# Error: expected","#     36","# but got","#     14","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":398,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n            return term(i) * terminater(i+1) =>           \r\n            return term(i) + terminater(i+1) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def terminater(i):\n        if i == n:\n            return term(i) \n        else:\n            return term(i) + terminater(i+1)\n\n    return terminater(1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def terminater(i):\n        if i == n:\n            return term(i) \n        else:\n            return term(i) * terminater(i+1)\n\n    return terminater(1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":425,"diff":"\r\nInputObject                                     SideIndicator\r\n-----------                                     -------------\r\n        return term(n) * product(n-1, term)     =>           \r\n        return term(n) + product(n-1, term)     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) + product(n-1, term)    ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":440,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    return term(n) * product(n-1,term) =>           \r\n    return term(n) + product(n-1,term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    return term(n) + product(n-1,term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    return term(n) * product(n-1,term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":448,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return term(n) * product(n-1, term) =>           \r\n    return term(n) + product(n-1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return 1\n    return term(n) + product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return 1\n    return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","7","","# Error: expected","#     6","# but got","#     7","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":450,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n            return term_a(x) * helper_a(x+1, term) =>           \r\n            return term_a(x) + helper_a(x+1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    y = 1\n    def helper_a(x, term_a):\n        if x == n:\n            return term_a(x)\n        else:\n            return term_a(x) + helper_a(x+1, term)\n    return helper_a(y, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    y = 1\n    def helper_a(x, term_a):\n        if x == n:\n            return term_a(x)\n        else:\n            return term_a(x) * helper_a(x+1, term)\n    return helper_a(y, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":505,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return term(n) * product(n - 1, term) =>           \r\n    return product(n, identity)               =>           \r\n        return term(n) + product(n - 1, term) <=           \r\n    return _______                            <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) + product(n - 1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n - 1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":516,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return term(n) + product(n-1, term) <=           \r\n                                            <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) + product(n-1, term)\n\n\n\n\"\"\"\n    def sum_product(n):\n        total = 0\n        k = 1\n        while k < n:\n            total = total + term(k)\n            sum_product(n-1)\n    return sum_product(n)\"\"\"","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)\n\n\n\"\"\"\n    def sum_product(n):\n        total = 0\n        k = 1\n        while k < n:\n            total = total + term(k)\n            sum_product(n-1)\n    return sum_product(n)\"\"\"","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"CallExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(Target(LeafWildcard(\"CallExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":19,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    if term == identity:    =>           \r\n    if term == identity(n): <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if term == identity(n):\n        total, k = 1, 1\n        while k <= n:\n            total, k = total * k, k + 1\n        return total\n    else:\n        total, k = 1, 1\n        while k <= n:\n            total, k = total * (k*k), k + 1\n        return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if term == identity:\n        total, k = 1, 1\n        while k <= n:\n            total, k = total * k, k + 1\n        return total\n    else:\n        total, k = 1, 1\n        while k <= n:\n            total, k = total * (k*k), k + 1\n        return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), 0), 1), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","36","","# Error: expected","#     6","# but got","#     36","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":20,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    if n == 0:                              =>           \r\n        return 0                            =>           \r\n    elif n == 1:                            =>           \r\n        return n                            =>           \r\n    else:                                   =>           \r\n        return term(n) * product(n-1, term) =>           \r\n    # if n == 0:                            <=           \r\n    #     return 0                          <=           \r\n    # elif n == 1:                          <=           \r\n    #     return n                          <=           \r\n    # else:                                 <=           \r\n    return term(n) * product(n-1, term)     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # if n == 0:\n    #     return 0\n    # elif n == 1:\n    #     return n\n    # else:\n    return term(n) * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return n\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-0)))))))), Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 36, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 36, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 36, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 36, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 36, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 36, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 36, in product","    return term(n) * product(n-1, term)","RecursionError: maximum recursion depth exceeded","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":21,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    return total     =>           \r\n        return total <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    total = 1\n    while i <= n:\n        total, i = total * term(i), i + 1\n        return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    total = 1\n    while i <= n:\n        total, i = total * term(i), i + 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ReferenceNode(node, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), 0)))))), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), 5), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":22,"diff":"\r\nInputObject                  SideIndicator\r\n-----------                  -------------\r\n    total = 1                =>           \r\n        total *= term(i)     =>           \r\n    total = 0                <=           \r\n        total *= i * term(i) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    i = 1\n    while i <= n:\n        total *= i * term(i)\n        i += 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    i = 1\n    while i <= n:\n        total *= term(i)\n        i += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":23,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        k, total = k + 1, total * term(k)   =>           \r\n        k, total = k + 1, total * term(k,1) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, total = 1, 1\n    while k <=n:\n        k, total = k + 1, total * term(k,1)\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, total = 1, 1\n    while k <=n:\n        k, total = k + 1, total * term(k)\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(LeafWildcard(\"ArgNode\")))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    k, total = k + 1, total * term(k,1)","TypeError: identity() takes 1 positional argument but 2 were given","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":142,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n    return product_counter(1)       =>           \r\n    return product_counter(1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def product_counter(i):\n    \tif i == n:\n    \t\treturn term(i)\n    \telse:\n    \t\treturn term(i) * product_counter(i + 1)\n    return product_counter(1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def product_counter(i):\n    \tif i == n:\n    \t\treturn term(i)\n    \telse:\n    \t\treturn term(i) * product_counter(i + 1)\n    return product_counter(1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(LeafWildcard(\"ArgNode\")))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in product","    return product_counter(1, term)","TypeError: product_counter() takes 1 positional argument but 2 were given","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":229,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n        prod, k = prod * term(k), k+1   =>           \r\n        prod, k = prod * term(k,1), k+1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, prod = 1,1\n    while k <= n:\n        prod, k = prod * term(k,1), k+1\n    return prod","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, prod = 1,1\n    while k <= n:\n        prod, k = prod * term(k), k+1\n    return prod","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(LeafWildcard(\"ArgNode\")))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    prod, k = prod * term(k,1), k+1","TypeError: identity() takes 1 positional argument but 2 were given","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":396,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n            return term(num) * times (num+1)       =>           \r\n            return term(num) * times (num+1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def times(num):\n        if num < n:\n            return term(num) * times (num+1, term)\n        else: \n            return term(n)\n    return times(1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def times(num):\n        if num < n:\n            return term(num) * times (num+1)\n        else: \n            return term(n)\n    return times(1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(LeafWildcard(\"ArgNode\")))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in product","    return times(1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in times","    return term(num) * times (num+1, term)","TypeError: times() takes 1 positional argument but 2 were given","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":499,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n        k, total = k+1, total*term(k)   =>           \r\n    return product(n+1,mul)             =>           \r\n        k, total = k+1, total*term(k,1) <=           \r\n    return product(n,mul)               <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k, total = 1,1\n    while k <= n:\n        k, total = k+1, total*term(k,1)\n    return total ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k, total = 1,1\n    while k <= n:\n        k, total = k+1, total*term(k)\n    return total ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(Target(LeafWildcard(\"ArgNode\")))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"ArgNode\"), TChild(LeafWildcard(\"ArgNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    k, total = k+1, total*term(k,1)","TypeError: identity() takes 1 positional argument but 2 were given","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":24,"diff":"\r\nInputObject                                           SideIndicator\r\n-----------                                           -------------\r\n            return total                              =>           \r\n        else:                                         =>           \r\n            return total_prod(x+1, total * term(x+1)) =>           \r\n    return product(n, identity)                       =>           \r\n            return total * term(x)                    <=           \r\n        #else:                                        <=           \r\n            #return product(x+1, total * term(x+1))   <=           \r\n    product()                                         <=           \r\n    return _______                                    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def total_prod(x, total):\n        if x == n:\n            return total * term(x)\n        #else:\n            #return product(x+1, total * term(x+1))\n    return total_prod(1, 1)\n\n# term becomes 1 instead of staying as square\n    # n goes down 1 every time you go through the code until it reaches 1, where\n    # you just return the total\n    # everytime you go through the loop, multiply the term applied to n by\n    # the term applied to (n-1) since you decrease 1 each time until you reach 1.\n    # but every time you go through the loop, you need to multiply your previous\n    # term(n) you got to total\n    #base case--> start from n and go down to 1\n    # if n is 1, return 1 * total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def total_prod(x, total):\n        if x == n:\n            return total\n        else:\n            return total_prod(x+1, total * term(x+1))\n    return total_prod(1, 1)\n\n# term becomes 1 instead of staying as square\n    # n goes down 1 every time you go through the code until it reaches 1, where\n    # you just return the total\n    # everytime you go through the loop, multiply the term applied to n by\n    # the term applied to (n-1) since you decrease 1 each time until you reach 1.\n    # but every time you go through the loop, you need to multiply your previous\n    # term(n) you got to total\n    #base case--> start from n and go down to 1\n    # if n is 1, return 1 * total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-total)))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-total_prod), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-x), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))))))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast)))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":27,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    if n == 0:                          =>           \r\n    if n == 1:                          =>           \r\n    return term(n)*product(n-1,term)    =>           \r\n    \"\"\"if term(n) == 0:                 <=           \r\n    if term(n) == 1:                    <=           \r\n    return n*product(term(n-1),term)\"\"\" <=           \r\n    return 1                            <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"if term(n) == 0:\n    \treturn term(0)\n    if term(n) == 1:\n    \treturn term(1)\n    return n*product(term(n-1),term)\"\"\"\n    return 1","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n    \treturn term(0)\n    if n == 1:\n    \treturn term(1)\n    return term(n)*product(n-1,term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-0))))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term)))))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":29,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n    while count < n:                =>           \r\n        value = value * term(count) =>           \r\n    return value * term(n)          =>           \r\n    while count != n:               <=           \r\n        value *= term(count)        <=           \r\n    return value                    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    value = 1\n    while count != n:\n        value *= term(count)\n        count += 1\n    return value\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    value = 1\n    while count < n:\n        value = value * term(count)\n        count += 1\n    return value * term(n)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-NotEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-value), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-value), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-count)))))))))))), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":31,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    if n <= 0:                              =>           \r\n        return 1                            =>           \r\n        return term(n) * product(n-1, term) =>           \r\n    if n <= 0:                              =>           \r\n        return 1                            =>           \r\n    else:                                   =>           \r\n        return n * factorial(n-1)           =>           \r\n    else:                                   =>           \r\n    return term(n) + product(n-1,term)      <=           \r\n    return _______                          <=           \r\n    \"*** YOUR CODE HERE ***\"                <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    return term(n) + product(n-1,term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n <= 0:\n        return 1\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) + product(n-1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) + product(n-1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) + product(n-1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) + product(n-1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) + product(n-1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) + product(n-1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) + product(n-1,term)","RecursionError: maximum recursion depth exceeded","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":33,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    return partial_product(n, term, 1) =>           \r\n    return partial_product(n, term, n) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def partial_product(n, term, k):\n        if n==1:\n            return k\n        else:\n            k*=term(n)\n            return partial_product(n-1, term, k)\n    return partial_product(n, term, n)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def partial_product(n, term, k):\n        if n==1:\n            return k\n        else:\n            k*=term(n)\n            return partial_product(n-1, term, k)\n    return partial_product(n, term, 1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","18","","# Error: expected","#     6","# but got","#     18","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":148,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n        return 1 =>           \r\n        return n <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def products(i):\n        if i <= n:\n            return term(i) * products(i+1)\n        return n\n    return products(1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def products(i):\n        if i <= n:\n            return term(i) * products(i+1)\n        return 1\n    return products(1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","18","","# Error: expected","#     6","# but got","#     18","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":345,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n        i += 1 =>           \r\n        i += i <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    a = 1\n    i = 1\n    while i < n:\n        a = a*term(i)\n        i += i\n    return a*term(n)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    a = 1\n    i = 1\n    while i < n:\n        a = a*term(i)\n        i += 1\n    return a*term(n)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","40","","# Error: expected","#     120","# but got","#     40","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":510,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    return prod(1, term) =>           \r\n    return prod(n, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def prod(m, func):\n        if m == n:\n            return func(m)\n        else:\n            return func(m) * prod(m + 1, func)\n    return prod(n, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def prod(m, func):\n        if m == n:\n            return func(m)\n        else:\n            return func(m) * prod(m + 1, func)\n    return prod(1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","3","","# Error: expected","#     6","# but got","#     3","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":35,"diff":"\r\nInputObject                                                 SideIndicator\r\n-----------                                                 -------------\r\n    total = 1                                               =>           \r\n        total, counter = total * term(counter), counter + 1 =>           \r\n    total = 0                                               <=           \r\n        total, counter = total + term(counter), counter + 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    counter = 1\n    total = 0\n    while counter <= n:\n        total, counter = total + term(counter), counter + 1\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    counter = 1\n    total = 1\n    while counter <= n:\n        total, counter = total * term(counter), counter + 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))))), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":51,"diff":"\r\nInputObject                                           SideIndicator\r\n-----------                                           -------------\r\n    value=1                                           =>           \r\n            return find_value(value*term(n),n-1,term) =>           \r\n    value=0                                           <=           \r\n            return find_value(value+term(n),n-1,term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    value=0\n    def find_value(value, n, term):\n        if n<=0:\n            return value\n        else:\n            return find_value(value+term(n),n-1,term)\n    return find_value(value, n, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    value=1\n    def find_value(value, n, term):\n        if n<=0:\n            return value\n        else:\n            return find_value(value*term(n),n-1,term)\n    return find_value(value, n, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))))), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":92,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    total = 1                             =>           \r\n        total, n = total * term(n), n - 1 =>           \r\n    total = 0                             <=           \r\n        total, n = total + term(n), n - 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    while n > 0:\n        total, n = total + term(n), n - 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while n > 0:\n        total, n = total * term(n), n - 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))))), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":140,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    k, total = 1, 1             =>           \r\n        total = total * term(k) =>           \r\n    k, total = 1, 0             <=           \r\n        total = total + term(k) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, total = 1, 0\n    while k <= n:\n        total = total + term(k)\n        k += 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, total = 1, 1\n    while k <= n:\n        total = total * term(k)\n        k += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))))), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":227,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    total = 1                   =>           \r\n        total = total * term(k) =>           \r\n    total = 0                   <=           \r\n        total = total + term(k) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    for k in range(1, n+1):\n        total = total + term(k)\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    for k in range(1, n+1):\n        total = total * term(k)\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))))), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":472,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    total, k = 1, 1                       =>           \r\n        total, k = total * term(k), k + 1 =>           \r\n    total, k = 0, 1                       <=           \r\n        total, k = total + term(k), k + 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total, k = total + term(k), k + 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))))), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":481,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    k, prod = 1, 1                      =>           \r\n        k, prod = k + 1, prod * term(k) =>           \r\n    k, prod = 1, 0                      <=           \r\n        k, prod = k + 1, prod + term(k) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, prod = 1, 0\n    while k <= n:\n        k, prod = k + 1, prod + term(k)\n    return prod\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, prod = 1, 1\n    while k <= n:\n        k, prod = k + 1, prod * term(k)\n    return prod\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))))), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":501,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    total, k = 1, 1             =>           \r\n        total = total * term(k) =>           \r\n    total, k = 0, 1             <=           \r\n        total = total + term(k) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total = total + term(k)\n        k = k + 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total = total * term(k)\n        k = k + 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))))), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":37,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    prod = 1                  =>           \r\n        prod = prod * term(i) =>           \r\n    prod = 0                  <=           \r\n        prod += term(i)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    prod = 0\n    while i < n + 1:\n        prod += term(i)\n        i += 1\n    return prod","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    prod = 1\n    while i < n + 1:\n        prod = prod * term(i)\n        i += 1\n    return prod","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-prod), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-prod), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i)))))))))))), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":38,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return term(n) * product(n-1, term) =>           \r\n    return n*product(n-1, term)         <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return term(n)\n    return n*product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return term(n)\n    return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":52,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        return term(n)*product(n-1,term) =>           \r\n        return n*product(n-1,term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==1:\n        return term(1)\n    else:\n        return n*product(n-1,term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==1:\n        return term(1)\n    else:\n        return term(n)*product(n-1,term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":73,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return term*product(n-1, term)      <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return term*product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term*product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term*product(n-1, term)","TypeError: unsupported operand type(s) for *: 'function' and 'int'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":77,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":103,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        return term(n) * product(n-1,term) =>           \r\n        return n * product(n-1,term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n > 1:\n        return n * product(n-1,term)\n    else:\n        return 1","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n > 1:\n        return term(n) * product(n-1,term)\n    else:\n        return 1","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":109,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0 or n ==1:\n        return 1\n    else:\n        return n * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0 or n ==1:\n        return 1\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":141,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        return term(n) * product( n-1, term) =>           \r\n        return n * product( n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==1:\n        return 1\n    else:\n        return n * product( n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==1:\n        return 1\n    else:\n        return term(n) * product( n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":157,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return n\n    else:\n        return n * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return n\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":206,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return term(n) * product(n - 1, term) =>           \r\n        return n * product(n - 1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    if n == 1:\n        return 1\n    else:\n        return n * product(n - 1, term)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    if n == 1:\n        return 1\n    else:\n        return term(n) * product(n - 1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":216,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        return term(n)*product(n-1, term) =>           \r\n        return n*product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return 1\n    if n > 1:\n        return n*product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return 1\n    if n > 1:\n        return term(n)*product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":225,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        return term(n)* product(n-1, term) =>           \r\n        return n* product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return n* product(n-1, term)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return term(n)* product(n-1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":237,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return term(n) * product(n - 1, term) =>           \r\n        return n * product(n - 1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return n * product(n - 1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return term(n) * product(n - 1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":240,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return term(n) * product(n-1, term) =>           \r\n    return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    return n * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":266,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return term(n) * product(n - 1, term) =>           \r\n        return n * product(n - 1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return n * product(n - 1, term)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return term(n) * product(n - 1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":278,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return term(n) * product(n-1, term) =>           \r\n    return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return 1\n    return n * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return 1\n    return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":281,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return term(n) * product(n-1, term) =>           \r\n    return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    return n * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":325,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n    \treturn 1\n\n    else:\n    \treturn n * product(n-1, term)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n    \treturn 1\n\n    else:\n    \treturn term(n) * product(n-1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":342,"diff":"\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n    return term(n)*product(n-1,term) =>           \r\n    return n*product(n-1,term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n<=0:\n        return 1\n    return n*product(n-1,term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n<=0:\n        return 1\n    return term(n)*product(n-1,term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":343,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        return term(n) * product(n-1,term) =>           \r\n        return n * product(n-1,term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n <1:\n        return 1\n    else:\n        return n * product(n-1,term)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n <1:\n        return 1\n    else:\n        return term(n) * product(n-1,term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":344,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return term(n) * product(n-1, term) =>           \r\n    return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    return n * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":378,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        return term(n)*product(n-1,term) =>           \r\n        return term*product(n-1,term)    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return n\n    else:\n        return term*product(n-1,term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return n\n    else:\n        return term(n)*product(n-1,term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product","    return term*product(n-1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product","    return term*product(n-1,term)","TypeError: unsupported operand type(s) for *: 'function' and 'int'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":401,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    return term(n) * product((n-1), term) =>           \r\n    return product(n, identity)           =>           \r\n    return n * product((n-1), term)       <=           \r\n    return _______                        <=           \r\n    \"*** YOUR CODE HERE ***\"              <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    return n * product((n-1), term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    return term(n) * product((n-1), term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":431,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n ==1:\n        return n\n    else:\n        return n * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n ==1:\n        return n\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":437,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return n * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":441,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return term(n) * product(n - 1, term) =>           \r\n        return n * product(n - 1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return 1\n    else:\n        return n * product(n - 1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return 1\n    else:\n        return term(n) * product(n - 1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":476,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n < 2:\n        return 1\n    else:\n        return n * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n < 2:\n        return 1\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":497,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <= 0: \n        return 1\n    else:\n        return n * product(n-1, term)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <= 0: \n        return 1\n    else:\n        return term(n) * product(n-1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":523,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return n * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return n * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":39,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    while index <= n:             =>           \r\n        sum1 = sum1 * term(index) =>           \r\n        index += 1                =>           \r\n    return product (n, identity)  =>           \r\n    while i <= n:                 <=           \r\n        sum1 = sum1 * term(i)     <=           \r\n        i += 1                    <=           \r\n    return _______                <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    index, sum1 =  1, 1\n    while i <= n:\n        sum1 = sum1 * term(i)\n        i += 1\n    return sum1","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    index, sum1 =  1, 1\n    while index <= n:\n        sum1 = sum1 * term(index)\n        index += 1\n    return sum1","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-index)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-index)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-index)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    while i <= n:","UnboundLocalError: local variable 'i' referenced before assignment","","# Error: expected","#     6","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":40,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    i = 1                                 =>           \r\n    def helper(n,i,term):                 =>           \r\n        if i == n:                        =>           \r\n        return term(i)*helper(n,i+1,term) =>           \r\n    return helper(n,i,term)               =>           \r\n    i, product = 1, 0                     <=           \r\n    def helper(n,i,term, product):        <=           \r\n        if n == i:                        <=           \r\n        product += term(i)                <=           \r\n        i += 1                            <=           \r\n    return helper(n,i,term,product)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, product = 1, 0\n    def helper(n,i,term, product):\n        if n == i:\n            return term(i)\n        product += term(i)\n        i += 1\n    return helper(n,i,term,product)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    def helper(n,i,term):\n        if i == n:\n            return term(i)\n        return term(i)*helper(n,i+1,term)\n    return helper(n,i,term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"ConstantExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(Target(LeafWildcard(\"ParameterNode\")), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Target(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-helper), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast)))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":41,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        return product(n-1, term)*term(n) =>           \r\n        return product(n-1, term)         <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n<=1:\n        return term(n)\n    else:\n        return product(n-1, term)\n  ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n<=1:\n        return term(n)\n    else:\n        return product(n-1, term)*term(n)\n  ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":42,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n    while identity <= n:            =>           \r\n    return total                    =>           \r\n                                    =>           \r\n    while identity < n:             <=           \r\n    return product(total, identity) <=           \r\n                                    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, identity = 1, 1\n    while identity < n:\n        total, identity = total * term(identity), identity + 1\n    return product(total, identity)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, identity = 1, 1\n    while identity <= n:\n        total, identity = total * term(identity), identity + 1\n    return total\n   ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(total, identity)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    total, identity = total * term(identity), identity + 1","TypeError: 'int' object is not callable","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":44,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return term(n) * product(n-1, term) =>           \r\n    return term(n) * product(n-1)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    return term(n) * product(n-1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    return term(n) * product(n-1)","TypeError: product() missing 1 required positional argument: 'term'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":121,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    return term(n) * product(n - 1, term) =>           \r\n    return term(n) * product(n - 1)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    return term(n) * product(n - 1)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    return term(n) * product(n - 1, term)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    return term(n) * product(n - 1)","TypeError: product() missing 1 required positional argument: 'term'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":143,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        return product(n-1,term)*term(n) =>           \r\n        return product(n-1)*term(n)      <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return term(n)\n    else:\n        return product(n-1)*term(n)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return term(n)\n    else:\n        return product(n-1,term)*term(n)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n-1)*term(n)","TypeError: product() missing 1 required positional argument: 'term'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":169,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n    if n == 1:                              =>           \r\n        return 1                            =>           \r\n        return n * factorial(n-1)           =>           \r\n    else:                                   =>           \r\n        return term(n) * product(n-1)       <=           \r\n    return _______                          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n-1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n) * product(n-1)","TypeError: product() missing 1 required positional argument: 'term'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":211,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return term(n) * product(n-1)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n) * product(n-1)","TypeError: product() missing 1 required positional argument: 'term'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":236,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return term(n) * product(n-1)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n) * product(n-1)","TypeError: product() missing 1 required positional argument: 'term'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":242,"diff":"\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n    return product(n-1,term)*term(n) =>           \r\n    return product(n-1)*term(n)      <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    return product(n-1)*term(n)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    return product(n-1,term)*term(n)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    return product(n-1)*term(n)","TypeError: product() missing 1 required positional argument: 'term'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":250,"diff":"\r\nInputObject                                                        SideIndicator\r\n-----------                                                        -------------\r\n            return term(n)*product_partial(n-1,term)               =>           \r\n    return product(n,identity)                                     =>           \r\n    def accumulate_partial (n,term):                               =>           \r\n        if n==2:                                                   =>           \r\n            return combiner(term(1), term(2))                      =>           \r\n        else:                                                      =>           \r\n            return combiner(term(n), accumulate_partial(n-1,term)) =>           \r\n    return combiner(base,accumulate_partial(n,term))               =>           \r\n            return term(n)*product_partial(n-1)                    <=           \r\n    return _______                                                 <=           \r\n    \"*** YOUR CODE HERE ***\"                                       <=           \r\n    \"*** YOUR CODE HERE ***\"                                       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def product_partial(n,term):\n        if n==2:\n            return term(1)*term(2)\n        else:\n            return term(n)*product_partial(n-1)\n    return product_partial(n,term)\n  ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def product_partial(n,term):\n        if n==2:\n            return term(1)*term(2)\n        else:\n            return term(n)*product_partial(n-1,term)\n    return product_partial(n,term)\n  ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in product","    return product_partial(n,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product_partial","    return term(n)*product_partial(n-1)","TypeError: product_partial() missing 1 required positional argument: 'term'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":263,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return term(n) * product(n-1, term) =>           \r\n    return term(n) * product(n-1)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    return term(n) * product(n-1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    return term(n) * product(n-1)","TypeError: product() missing 1 required positional argument: 'term'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":264,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return term(n) * product(n-1)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product","    return term(n) * product(n-1)","TypeError: product() missing 1 required positional argument: 'term'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":272,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return product(n - 1, term) * term(n) =>           \r\n        return product(n - 1) * term(n)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n    \treturn term(n)\n    else:\n    \treturn product(n - 1) * term(n)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n    \treturn term(n)\n    else:\n    \treturn product(n - 1, term) * term(n)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product","    return product(n - 1) * term(n)","TypeError: product() missing 1 required positional argument: 'term'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":297,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return term(n) * product(n - 1, term) =>           \r\n        return term(n) * product(n - 1)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n - 1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n - 1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n) * product(n - 1)","TypeError: product() missing 1 required positional argument: 'term'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":511,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return product(n - 1, term) * term(n) =>           \r\n        return product(n - 1) * term(n)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    else:\n        return product(n - 1) * term(n)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    else:\n        return product(n - 1, term) * term(n)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product","    return product(n - 1) * term(n)","TypeError: product() missing 1 required positional argument: 'term'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":521,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return term(n) * product(n-1)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return n\n    else:\n        return term(n) * product(n-1)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return n\n    else:\n        return term(n) * product(n-1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Skip(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n) * product(n-1)","TypeError: product() missing 1 required positional argument: 'term'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":45,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n            total = total * term(x)     =>           \r\n            total = total * term(x - 1) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    def helper(x, total):\n        if x == 1:\n            return total\n        else:\n            total = total * term(x - 1)\n            return helper(x - 1, total)\n    return helper(n, total)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    def helper(x, total):\n        if x == 1:\n            return total\n        else:\n            total = total * term(x)\n            return helper(x - 1, total)\n    return helper(n, total)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":90,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n        total = total * term(n)   =>           \r\n        total = total * term(n-1) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while n > 0:\n        total = total * term(n-1)\n        n -= 1\n    return total \n       ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while n > 0:\n        total = total * term(n)\n        n -= 1\n    return total \n       ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":454,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n            total = total * term(n)     =>           \r\n            total = total * term(n - 1) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def functions(n, term, total):\n        if n == 1:\n            return total\n        else:\n            total = total * term(n - 1)\n            return functions(n - 1, term, total)\n    return functions(n, term, 1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def functions(n, term, total):\n        if n == 1:\n            return total\n        else:\n            total = total * term(n)\n            return functions(n - 1, term, total)\n    return functions(n, term, 1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":46,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    if n==1:           =>           \r\n        return term(1) =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    return product(n-1,term)*term(n)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return term(1)\n    return product(n-1,term)*term(n)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\"))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return product(n-1,term)*term(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return product(n-1,term)*term(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return product(n-1,term)*term(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return product(n-1,term)*term(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return product(n-1,term)*term(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return product(n-1,term)*term(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return product(n-1,term)*term(n)","RecursionError: maximum recursion depth exceeded","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":189,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    if n == 1:         =>           \r\n        return term(1) =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    return term(n) * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"CallExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\"))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n-1, term)","RecursionError: maximum recursion depth exceeded","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":47,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n            return term(n) =>           \r\n            return n       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def times(x):\n        if x==n:\n            return n\n        else:\n            return term(x)*times(increment(x))\n    return times(1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def times(x):\n        if x==n:\n            return term(n)\n        else:\n            return term(x)*times(increment(x))\n    return times(1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)))))), 0), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","12","","# Error: expected","#     36","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":207,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n            return term(i) =>           \r\n            return i       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def product_of_sequence(i):\n        if i==n: \n            return i\n        else:\n            return term(i) * product_of_sequence(i+1)\n    return product_of_sequence(1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def product_of_sequence(i):\n        if i==n: \n            return term(i)\n        else:\n            return term(i) * product_of_sequence(i+1)\n    return product_of_sequence(1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","12","","# Error: expected","#     36","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":435,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    return term(total) =>           \r\n    return total       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x=0\n    total = 1\n    while x < n:\n        x= increment(x)\n        total = x * total\n    return total\n\n    \n\n\n    ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x=0\n    total = 1\n    while x < n:\n        x= increment(x)\n        total = x * total\n    return term(total)\n\n    \n\n\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)))))), 0), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Skip(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":49,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return term(n) * product(n-1, term) =>           \r\n    return term(n) * product(term(n-1)) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    return term(n) * product(term(n-1))","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0), 1), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    return term(n) * product(term(n-1))","TypeError: product() missing 1 required positional argument: 'term'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":53,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n        return term(n) * product(n-1, term)        =>           \r\n        return term(1)                             =>           \r\n        return product(identity(n), identity(n-1)) <=           \r\n        return 1                                   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n > 0:\n        return product(identity(n), identity(n-1))\n    else:\n        return 1","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n > 0:\n        return term(n) * product(n-1, term)\n    else:\n        return term(1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0)))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast)))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    return product(identity(n), identity(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    return product(identity(n), identity(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    return product(identity(n), identity(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    return product(identity(n), identity(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    return product(identity(n), identity(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    return product(identity(n), identity(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    if n > 0:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":54,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    if n==1:                =>           \r\n        return int(term(n)) =>           \r\n                            =>           \r\n    if n==0:                <=           \r\n        return              <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==0:\n        return\n    else:\n        return int(term(n))*product(n-1,term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    if n==1:\n        return int(term(n))\n    else:\n        return int(term(n))*product(n-1,term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-int), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))))))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(LeafWildcard(\"ReturnStatementNode\"))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return int(term(n))*product(n-1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return int(term(n))*product(n-1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return int(term(n))*product(n-1,term)","TypeError: unsupported operand type(s) for *: 'int' and 'NoneType'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":55,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    return term(n) *product((n-1), term)    =>           \r\n    return term(n) *product((n-1), term(x)) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    if n == 0:\n        return 0\n    if n == 1:\n        return term(1)\n    return term(n) *product((n-1), term(x))\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    if n == 0:\n        return 0\n    if n == 1:\n        return term(1)\n    return term(n) *product((n-1), term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ArgNode\")))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in product","    return term(n) *product((n-1), term(x))","NameError: name 'x' is not defined","","# Error: expected","#     6","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":170,"diff":"\r\nInputObject                                    SideIndicator\r\n-----------                                    -------------\r\n        return term(n)*product(n-1, term)      =>           \r\n                                               =>           \r\n        return term(n)*product(n-1, term(n-1)) <=           \r\n                                               <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n)*product(n-1, term(n-1))\n       ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n)*product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ArgNode\")))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n)*product(n-1, term(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n)*product(n-1, term(n-1))","TypeError: 'int' object is not callable","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":230,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        return term(n) * product(n - 1, term)        =>           \r\n        return term(n) * product(n - 1, term(n - 1)) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n - 1, term(n - 1))","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n - 1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ArgNode\")))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"any\"))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ArgNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product","    return term(n) * product(n - 1, term(n - 1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product","    return term(n) * product(n - 1, term(n - 1))","TypeError: 'int' object is not callable","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":56,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    while a < n:                           =>           \r\n    return product(n, identity)            =>           \r\n    a = 1                                  =>           \r\n    Total = term(a)                        =>           \r\n    while a < n:                           =>           \r\n        Total = combiner(Total, term(a+1)) =>           \r\n        a += 1                             =>           \r\n    return combiner(base, Total)           =>           \r\n                                           =>           \r\n    while a <= n:                          <=           \r\n    if n == 0:                             <=           \r\n        return 1                           <=           \r\n        return product(n, identity)        <=           \r\n    else:                                  <=           \r\n    \"*** YOUR CODE HERE ***\"               <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    a = 1\n    Product = term(a)\n    while a <= n:\n        Product = Product * term(a+1)\n        a += 1\n    return Product","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    a = 1\n    Product = term(a)\n    while a < n:\n        Product = Product * term(a+1)\n        a += 1\n    return Product","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(LeafWildcard(\"any\"), TChild(LeafWildcard(\"any\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","24","","# Error: expected","#     6","# but got","#     24","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":185,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while i < n:  =>           \r\n    while i <= n: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    product = term(i)\n    while i <= n:\n        i += 1\n        product = product * term(i)\n    return product","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    product = term(i)\n    while i < n:\n        i += 1\n        product = product * term(i)\n    return product","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(LeafWildcard(\"any\"), TChild(LeafWildcard(\"any\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","24","","# Error: expected","#     6","# but got","#     24","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":212,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while k < n:  =>           \r\n    while k <= n: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 1\n    total = 1\n    while k <= n:\n        k = k + 1\n        total = total * term(k)\n    return tota","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 1\n    total = 1\n    while k < n:\n        k = k + 1\n        total = total * term(k)\n    return tota","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(LeafWildcard(\"any\"), TChild(LeafWildcard(\"any\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","24","","# Error: expected","#     6","# but got","#     24","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":214,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while x < n:  =>           \r\n    while x <= n: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, x = 1 , 1\n    while x <= n:\n        total = total*term(x+1)\n        x += 1\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, x = 1 , 1\n    while x < n:\n        total = total*term(x+1)\n        x += 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(LeafWildcard(\"any\"), TChild(LeafWildcard(\"any\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","24","","# Error: expected","#     6","# but got","#     24","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":409,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while i < n:  =>           \r\n    while i <= n: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 0\n    total = 1\n    while i <= n:\n        i = i + 1\n        total = total * term(i)\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 0\n    total = 1\n    while i < n:\n        i = i + 1\n        total = total * term(i)\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(LeafWildcard(\"any\"), TChild(LeafWildcard(\"any\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","24","","# Error: expected","#     6","# but got","#     24","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":498,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while x < n:  =>           \r\n    while x <= n: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n\n\n    \"\"\"\n    x = 1\n    total = 1\n    while x <= n:\n        x = x + 1\n        total = total*term(x)\n    return total\n\n    \"\"\"def identity()\n \n        return identity\"\"\"","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n\n\n    \"\"\"\n    x = 1\n    total = 1\n    while x < n:\n        x = x + 1\n        total = total*term(x)\n    return total\n\n    \"\"\"def identity()\n \n        return identity\"\"\"","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(LeafWildcard(\"any\"), TChild(LeafWildcard(\"any\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","24","","# Error: expected","#     6","# but got","#     24","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":57,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        num = term(counter)                  =>           \r\n        mul = mul * num                      =>           \r\n        num, mul = term(counter), mul * num  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    counter = 1\n    mul = 1\n    while counter <= n:\n        num, mul = term(counter), mul * num \n        counter = counter + 1\n    return mul","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    counter = 1\n    mul = 1\n    while counter <= n:\n        num = term(counter)\n        mul = mul * num \n        counter = counter + 1\n    return mul","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)))), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-mul), SingleChild(ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    num, mul = term(counter), mul * num","UnboundLocalError: local variable 'num' referenced before assignment","","# Error: expected","#     6","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":58,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while k <= n: =>           \r\n    return total  =>           \r\n                  =>           \r\n    if k <= n:    <=           \r\n                  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    k = 1\n    if k <= n:\n        total = total * term(k)\n        k += 1","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    k = 1\n    while k <= n:\n        total = total * term(k)\n        k += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(WhileStatementNode, Children(ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0), SingleChild(ReferenceNode(node, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), 0))))), Selected(\\x => Match(x, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 5), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), 0), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":59,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    final = 1                              =>           \r\n        final = final * result             =>           \r\n        counter += 1                       =>           \r\n        if n == 0:                         <=           \r\n            return 0                       <=           \r\n        if n == 1:                         <=           \r\n            return 1                       <=           \r\n        final = result * term(counter + 1) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    counter = 1\n    while counter != n + 1:\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        result = term(counter)\n        final = result * term(counter + 1)\n    return final \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    counter = 1\n    final = 1\n    while counter != n + 1:\n        result = term(counter)\n        final = final * result\n        counter += 1\n    return final \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-final), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), 0), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-final), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0))))))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatementNode-Add, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0), 2), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast)))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":60,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    def multi(x,func):                     =>           \r\n            return func(n)                 =>           \r\n            return multi(x+1,func)*func(x) =>           \r\n    return multi(1,term)                   =>           \r\n    def multi(x):                          <=           \r\n            return term(n)                 <=           \r\n            return term(x+1)*x             <=           \r\n    return multi(1)                        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def multi(x):\n        if x==n:\n            return term(n)\n        else:\n            return term(x+1)*x\n    return multi(1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def multi(x,func):\n        if x==n:\n            return func(n)\n        else:\n            return multi(x+1,func)*func(x)\n    return multi(1,term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(ParameterNode-func), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(FunctionDefinitionNode-multi, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-func)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-multi)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-func))), 2), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-func), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast)))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":62,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        term(n) * product(n-1, term)        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        term(n) * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"any\")))), 0)))), Selected(\\x => Match(x, Skip(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    term(n) * product(n-1, term)","TypeError: unsupported operand type(s) for *: 'int' and 'NoneType'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":94,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    return f(n) =>           \r\n    f(n)        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def f(n):\n        if n==1:\n            return 1\n        else:\n            return term(n)*g(n-1)\n    def g(n):\n        if n==1:\n            return 1\n        else:\n            return term(n)*f(n-1)\n    f(n)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def f(n):\n        if n==1:\n            return 1\n        else:\n            return term(n)*g(n-1)\n    def g(n):\n        if n==1:\n            return 1\n        else:\n            return term(n)*f(n-1)\n    return f(n)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"any\")))), 0)))), Selected(\\x => Match(x, Skip(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":138,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    return helper(n) =>           \r\n    helper(n)        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper(i):\n        if i==0:\n            return 1\n        else:\n            return term(i) * product(i-1, term)\n    helper(n)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper(i):\n        if i==0:\n            return 1\n        else:\n            return term(i) * product(i-1, term)\n    return helper(n)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"any\")))), 0)))), Selected(\\x => Match(x, Skip(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in product","    helper(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in helper","    return term(i) * product(i-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in product","    helper(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in helper","    return term(i) * product(i-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in product","    helper(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in helper","    return term(i) * product(i-1, term)","TypeError: unsupported operand type(s) for *: 'int' and 'NoneType'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":273,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        return term(n)*product(n-1,term) =>           \r\n        term(n)*product(n-1,term)        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n < 1:\n        return 1\n    else:\n        term(n)*product(n-1,term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n < 1:\n        return 1\n    else:\n        return term(n)*product(n-1,term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"any\")))), 0)))), Selected(\\x => Match(x, Skip(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    term(n)*product(n-1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    term(n)*product(n-1,term)","TypeError: unsupported operand type(s) for *: 'int' and 'NoneType'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":357,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        term(n) * product(n-1, term)        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        term(n) * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"any\")))), 0)))), Selected(\\x => Match(x, Skip(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    term(n) * product(n-1, term)","TypeError: unsupported operand type(s) for *: 'int' and 'NoneType'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":503,"diff":"\r\nInputObject                    SideIndicator\r\n-----------                    -------------\r\n    return counter(n, term, 1) =>           \r\n    counter(n, term, 1)        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"if(n == 1):\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)\"\"\"\n\n    def counter(n, term, i):\n        if(i == n):\n            return term(n)\n        else:\n            return term(i) * counter(n, term, i+1)\n\n    counter(n, term, 1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \"\"\"if(n == 1):\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)\"\"\"\n\n    def counter(n, term, i):\n        if(i == n):\n            return term(n)\n        else:\n            return term(i) * counter(n, term, i+1)\n\n    return counter(n, term, 1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"any\")))), 0)))), Selected(\\x => Match(x, Skip(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"any\")))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":63,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    x, y = n, 1                   =>           \r\n    while x >= 1:                 =>           \r\n        x, y = x - 1, y * term(x) =>           \r\n    return y                      =>           \r\n    while x >= 1:                 =>           \r\n        temp = x                  =>           \r\n        y = y * term(temp)        =>           \r\n                                  =>           \r\n    while x > 1:                  <=           \r\n        y = y * term(x)           <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    x = n\n    y = 1\n    while x > 1: \n        x -= 1\n        y = y * term(x)\n    return y \n\n   ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    x, y = n, 1\n    while x >= 1:\n        x, y = x - 1, y * term(x)\n    return y\n\n    x = n\n    y = 1\n    while x >= 1: \n        temp = x \n        x -= 1\n        y = y * term(temp)\n    return y \n\n   ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-x), SingleChild(LeafConstNode(NameExpressionNode-y)))), SingleChild(ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(LeafConstNode(NameExpressionNode-x), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-x), SingleChild(LeafConstNode(NameExpressionNode-y)))), SingleChild(ConstNode(TupleExpressionNode-False, Children(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-x), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-y), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-x)))))))))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-y))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-temp), SingleChild(LeafConstNode(NameExpressionNode-x)))), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-temp)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":65,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    total=1                     =>           \r\n        total = term(i) * total =>           \r\n    total=0                     <=           \r\n        total = total * term(i) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i=1\n    total=0\n    while i<=n:\n        total = total * term(i)\n        i+=1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i=1\n    total=1\n    while i<=n:\n        total = term(i) * total\n        i+=1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-total), 1), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":66,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n    if n == 1:                                =>           \r\n        return term(1)                        =>           \r\n        return term(n) * product(n - 1, term) =>           \r\n    if n == 0:                                <=           \r\n        return 0                              <=           \r\n        return term(n) + product(n - 1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return term(n) + product(n - 1, term)\n   ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n - 1, term)\n   ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":67,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        product, k = product*(term(k)), k+1   =>           \r\n        product, k = product*(term-f(k)), k+1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k, product = 1, 1\n    while k <= n:\n        product, k = product*(term-f(k)), k+1\n    return product","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k, product = 1, 1\n    while k <= n:\n        product, k = product*(term(k)), k+1\n    return product","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ParenthesisExpressionNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), 0), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    product, k = product*(term-f(k)), k+1","NameError: name 'f' is not defined","","# Error: expected","#     6","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":69,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return 1                            =>           \r\n        return term(n) * product(n-1, term) =>           \r\n        return                              <=           \r\n        return term * product(n-1, term)    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n ==0:\n        return\n    else:\n        return term * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n ==0:\n        return 1\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(ConstantExpressionNode-1), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(LeafWildcard(\"ReturnStatementNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term * product(n-1, term)","TypeError: unsupported operand type(s) for *: 'function' and 'NoneType'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":70,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    for num in range(1, n+1): =>           \r\n    for num in range(n+1):    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    for num in range(n+1):\n        total = total * term(num)\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    for num in range(1, n+1):\n        total = total * term(num)\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))), 1), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":71,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n        p*=term(_) =>           \r\n        p*=_       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    p=1\n    for _ in range(1,n+1):\n        p*=_\n    return p\n        ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    p=1\n    for _ in range(1,n+1):\n        p*=term(_)\n    return p\n        ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Skip(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":131,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        product *= term(i) =>           \r\n        product *= i       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    product = 1\n    while i <= n:\n        product *= i\n        i += 1\n    return product","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    product = 1\n    while i <= n:\n        product *= term(i)\n        i += 1\n    return product","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Skip(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":208,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        result *= term(n) =>           \r\n        result *= n       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    result = 1\n    while n > 0:\n        result *= n\n        n -= 1\n    return result","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    result = 1\n    while n > 0:\n        result *= term(n)\n        n -= 1\n    return result","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Skip(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":479,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        product *= term(counter) =>           \r\n        product *= counter       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    counter, product = 1, 1\n    while counter <= n:\n        product *= counter\n        counter += 1\n    return product","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    counter, product = 1, 1\n    while counter <= n:\n        product *= term(counter)\n        counter += 1\n    return product","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Skip(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":72,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    counter=n                           =>           \r\n    z=1                                 =>           \r\n    while 2<=counter:                   =>           \r\n        x=term(n)                       =>           \r\n        y=term(n-1)                     =>           \r\n        counter-=2                      =>           \r\n        n-=2                            =>           \r\n        z*=x*y                          =>           \r\n    return z                            =>           \r\n    if term==identity:                  <=           \r\n        n*n-1                           <=           \r\n        n**2*(n-1)**2                   <=           \r\n    if n==0:                            <=           \r\n        return 1                        <=           \r\n    else:                               <=           \r\n        return product(n-1,lambda n: x) <=           \r\n    else:                               <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if term==identity:\n        n*n-1\n    else:\n        n**2*(n-1)**2\n    if n==0:\n        return 1\n    else:\n        return product(n-1,lambda n: x)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    counter=n\n    z=1\n    while 2<=counter:\n        x=term(n)\n        y=term(n-1)\n        counter-=2\n        n-=2\n        z*=x*y\n    return z","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-counter)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-counter), SingleChild(LeafConstNode(NameExpressionNode-n))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-z)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-z), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-2)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Power, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-counter)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(ParenthesisExpressionNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)))), Selected(\\x => Match(x, Node(ParenthesisExpressionNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0))))))), Selected(\\x => Match(x, Node(BinaryExpressionNode-Power, TChildren(Target(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Power, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(BinaryExpressionNode-Power, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(BinaryExpressionNode-Power, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(LambdaExpressionNode, TChild(Node(FunctionDefinitionNode-<lambda$675>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(BinaryExpressionNode-Power, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(LambdaExpressionNode, TChild(Node(FunctionDefinitionNode-<lambda$675>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), 0), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(BinaryExpressionNode-Power, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(LambdaExpressionNode, TChild(Node(FunctionDefinitionNode-<lambda$675>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(BinaryExpressionNode-Power, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(LambdaExpressionNode, TChild(Node(FunctionDefinitionNode-<lambda$675>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-y)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(LambdaExpressionNode, TChild(Node(FunctionDefinitionNode-<lambda$675>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(LambdaExpressionNode, TChild(Node(FunctionDefinitionNode-<lambda$675>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(LambdaExpressionNode, TChild(Node(FunctionDefinitionNode-<lambda$675>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-2)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-z)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-<lambda$675>, TChildren(Target(LeafWildcard(\"ParameterNode\")), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(NameExpressionNode-y))))), Selected(\\x => Match(x, Node(FunctionDefinitionNode-<lambda$675>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(ConstantExpressionNode-2), SingleChild(LeafConstNode(NameExpressionNode-counter)))), SingleChild(ConstNode(SuiteStatementNode, Children(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-x), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0))))))))), Children(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-y), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0)))))))))))), Children(ConstNode(AugmentedAssignStatementNode-Subtract, Children(LeafConstNode(NameExpressionNode-counter), SingleChild(LeafConstNode(ConstantExpressionNode-2)))), Children(ConstNode(AugmentedAssignStatementNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-2)))), SingleChild(ConstNode(AugmentedAssignStatementNode-Multiply, Children(LeafConstNode(NameExpressionNode-z), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(NameExpressionNode-y)))))))))))))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(BinaryExpressionNode-Power, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(LambdaExpressionNode, TChild(Node(FunctionDefinitionNode-<lambda$675>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-z))), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(BinaryExpressionNode-Power, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(LambdaExpressionNode, TChild(Node(FunctionDefinitionNode-<lambda$675>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(BinaryExpressionNode-Power, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(LambdaExpressionNode, TChild(Node(FunctionDefinitionNode-<lambda$675>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(BinaryExpressionNode-Power, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(LambdaExpressionNode, TChild(Node(FunctionDefinitionNode-<lambda$675>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))), InOrderSort(ast)))))))))))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":74,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    return result   =>           \r\n    return resultcd <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    result=1\n    while n>0:\n        result= result*term(n)\n        n-=1\n    return resultcd","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    result=1\n    while n>0:\n        result= result*term(n)\n        n-=1\n    return result","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-result)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product","    return resultcd","NameError: name 'resultcd' is not defined","","# Error: expected","#     6","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":76,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    while counter<n:                   =>           \r\n        if term==identity:             =>           \r\n            total*=tracker             =>           \r\n            total*=(tracker**2)        =>           \r\n            tracker+=1                 =>           \r\n    return total                       =>           \r\n                                       =>           \r\n                                       =>           \r\n    while(counter>n):                  <=           \r\n        if term == identity:           <=           \r\n            total*=tracker*(tracker+1) <=           \r\n            n*=(n+1)**2                <=           \r\n        return total                   <=           \r\n                                       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    counter=0\n    tracker=1\n    total=1\n    while(counter>n):\n        if term == identity:\n            total*=tracker*(tracker+1)\n            counter+=1\n            tracker+=1\n        elif term==square:\n            n*=(n+1)**2\n            counter+=1\n            \n        return total\n    ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    counter=0\n    tracker=1\n    total=1\n    while counter<n:\n        if term==identity:\n            total*=tracker\n            tracker+=1\n            counter+=1\n            \n        elif term==square:\n            total*=(tracker**2)\n            tracker+=1\n            counter+=1\n\n    return total\n            \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-tracker)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-counter)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(BinaryExpressionNode-Power, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-tracker)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-2)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Power, Children(LeafConstNode(NameExpressionNode-tracker), SingleChild(LeafConstNode(ConstantExpressionNode-2))))), Selected(\\x => Match(x, Node(ParenthesisExpressionNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Power, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Power, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Power, TChildren(Target(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Power, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-tracker), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Power, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-LessThan, Children(LeafConstNode(NameExpressionNode-counter), SingleChild(LeafConstNode(NameExpressionNode-n)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Power, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), 0)))))), 5), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Power, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Power, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Power, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Power, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), 6), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Power, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":81,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    product = 1       =>           \r\n    product = term(n) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    product = term(n)\n    while n>0:\n    \tn = n-1\n    \tproduct = product * term(n)\n    return product","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    product = 1\n    while n>0:\n    \tproduct = product * term(n)\n    \tn = n-1\n    return product","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-n), SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":82,"diff":"\r\nInputObject                                           SideIndicator\r\n-----------                                           -------------\r\n        return mul(term(n), product(n-1, term))       =>           \r\n        return combiner(term(n), combiner(n-1, term)) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    if n == 1:\n\n        return term(1)\n    else:\n        \n        return combiner(term(n), combiner(n-1, term))\n    \n\n\n    \"*** YOUR CODE HERE ***\"","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    if n == 1:\n\n        return term(1)\n    else:\n        \n        return mul(term(n), product(n-1, term))\n    \n\n\n    \"*** YOUR CODE HERE ***\"","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-mul)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 36, in product","    return combiner(term(n), combiner(n-1, term))","NameError: name 'combiner' is not defined","","# Error: expected","#     6","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":83,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    while x<n+1: =>           \r\n    while x<n:   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x=1\n    total=1\n    while x<n:\n        total=total*term(x)\n        x+=1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x=1\n    total=1\n    while x<n+1:\n        total=total*term(x)\n        x+=1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":382,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    while x < n+1:                      =>           \r\n    x = 1                               =>           \r\n        return product(n, increment(x)) =>           \r\n    return _______                      <=           \r\n    \"*** YOUR CODE HERE ***\"            <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = 1\n    total = 1\n    while x < n:\n        total = total*term(x)\n        x += 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = 1\n    total = 1\n    while x < n+1:\n        total = total*term(x)\n        x += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":85,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    while n >0:  =>           \r\n    while n < 0: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    total = 1\n    while n < 0:\n        total = total * term(n)\n        n = n -1 \n\n    return total\n    \n    \n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    total = 1\n    while n >0:\n        total = total * term(n)\n        n = n -1 \n\n    return total\n    \n    \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":87,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    def helper(n):                        =>           \r\n        if n > 0:                         =>           \r\n            return term(n) * helper(n-1)  =>           \r\n        else:                             =>           \r\n            return 1                      =>           \r\n    return helper(n)                      =>           \r\n    total = 0                             <=           \r\n    if n > 0:                             <=           \r\n        def helper(n):                    <=           \r\n            total = term(n) * helper(n-1) <=           \r\n    else:                                 <=           \r\n        return total                      <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    if n > 0:\n        def helper(n):\n            total = term(n) * helper(n-1)\n    else:\n        return total\n\n\n\n    # a = 1\n    # total = 0\n    # def helper(a):\n    #     if a < n:\n    #         b = term(a)\n    #         a = a + 1\n    #     return b * helper(a)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper(n):\n        if n > 0:\n            return term(n) * helper(n-1)\n        else:\n            return 1\n    return helper(n)\n\n\n\n    # a = 1\n    # total = 0\n    # def helper(a):\n    #     if a < n:\n    #         b = term(a)\n    #         a = a + 1\n    #     return b * helper(a)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), 0)))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))), 0), 1), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(FunctionDefinitionNode-helper, Children(LeafConstNode(ParameterNode-n), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-GreaterThan, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), 0)))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-helper), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast)))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":88,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    return total =>           \r\n    return x     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    for x in range(1, n + 1):\n        total *= term(x)\n    return x","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    for x in range(1, n + 1):\n        total *= term(x)\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","3","","# Error: expected","#     6","# but got","#     3","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":306,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    a, total = n, 1 =>           \r\n    a, b = n, 1     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    a, b = n, 1\n    while a > 1:\n        total *= term(a)\n        a -= 1\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    a, total = n, 1\n    while a > 1:\n        total *= term(a)\n        a -= 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    total *= term(a)","UnboundLocalError: local variable 'total' referenced before assignment","","# Error: expected","#     6","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":525,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    return total        =>           \r\n    return totalproduct <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, i = 1, 1\n    while i <= n:\n        total = total * term(i)\n        i = i + 1\n    return totalproduct","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, i = 1, 1\n    while i <= n:\n        total = total * term(i)\n        i = i + 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in product","    return totalproduct","NameError: name 'totalproduct' is not defined","","# Error: expected","#     6","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":93,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    if n == 1:   =>           \r\n        return 1 =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    return term(n) * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return 1\n    return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    return term(n) * product(n-1, term)","RecursionError: maximum recursion depth exceeded","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":97,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    #total, i = 1, 1                        =>           \r\n    #while i <= n:                          =>           \r\n    #    total *= term(i)                   =>           \r\n    #    i += 1                             =>           \r\n    #return total                           =>           \r\n    #OR RECURSIVELY                         =>           \r\n    if n == 1:                              =>           \r\n        return term(n)                      =>           \r\n        return term(n) * product(n-1, term) =>           \r\n    return product(n, identity)             =>           \r\n    else:                                   =>           \r\n                                            =>           \r\n    total, i = 1, 0                         <=           \r\n    while i <= n:                           <=           \r\n        total *= term(i)                    <=           \r\n        i += 1                              <=           \r\n    return total                            <=           \r\n    return _______                          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, i = 1, 0\n    while i <= n:\n        total *= term(i)\n        i += 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    #total, i = 1, 1\n    #while i <= n:\n    #    total *= term(i)\n    #    i += 1\n    #return total\n\n    #OR RECURSIVELY\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"ConstantExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term)))))))))))), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))))))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast)))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":100,"diff":"\r\nInputObject                    SideIndicator\r\n-----------                    -------------\r\n    total = 1                  =>           \r\n    while n > 1:               =>           \r\n        total = total *term(n) =>           \r\n    return total               =>           \r\n    while n > 0:               <=           \r\n        n = k                  <=           \r\n        k = term(k)* term(n)   <=           \r\n    return k                   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n < 1:\n        return 0\n    while n > 0:\n        n = k\n        k = term(k)* term(n)\n        n = n-1\n    return k","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n < 1:\n        return 0\n    total = 1\n    while n > 1:\n        total = total *term(n)\n        n = n-1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    n = k","UnboundLocalError: local variable 'k' referenced before assignment","","# Error: expected","#     6","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":101,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n    k, product = 1, 1               =>           \r\n        product = product * term(k) =>           \r\n    return product                  =>           \r\n    k, sum = 1, 0                   <=           \r\n        sum += term(k)              <=           \r\n    return sum                      <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, sum = 1, 0\n    while k <= n:\n        sum += term(k)\n        k += 1\n    return sum","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, product = 1, 1\n    while k <= n:\n        product = product * term(k)\n        k += 1\n    return product","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-product), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-product), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-k)))))))))))), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":102,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        total, x = total * term(x), x + 1 =>           \r\n    return total                          =>           \r\n    while n >= 0:                         =>           \r\n        return n * product(n-1)           =>           \r\n        total, x = total * x, x + 1       <=           \r\n    return total                          <=           \r\n    \"*** YOUR CODE HERE ***\"              <=           \r\n    return _______                        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, x = 1, 1\n\n    while x <= n:\n        total, x = total * x, x + 1\n\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, x = 1, 1\n\n    while x <= n:\n        total, x = total * term(x), x + 1\n\n    return total    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":116,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        total = (total*term(m)) =>           \r\n    return product(n, identity) =>           \r\n        total = (total*m)       <=           \r\n    return _______              <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    m = 1\n    while m <= n:\n        total = (total*m)\n        m += 1\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    m = 1\n    while m <= n:\n        total = (total*term(m))\n        m += 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":163,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        total = total * term(k) =>           \r\n        total = total * k       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total = total * k\n        k = increment(k)\n        \n    return total\n\n        \n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total = total * term(k)\n        k = increment(k)\n        \n    return total\n\n        \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":164,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n            return start(m, accum*term(m)) =>           \r\n            return start(m, accum*m)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def start(m, accum):\n        if m==n:\n            return accum\n        else:\n            m+=1\n            return start(m, accum*m)\n    return start(1,1)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def start(m, accum):\n        if m==n:\n            return accum\n        else:\n            m+=1\n            return start(m, accum*term(m))\n    return start(1,1)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":187,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n        prod = prod * term(i) =>           \r\n        prod = prod * i       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    prod = 1\n    for i in range (1,n+1):\n        prod = prod * i\n    return prod","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    prod = 1\n    for i in range (1,n+1):\n        prod = prod * term(i)\n    return prod","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":188,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n        prod = prod * term(i) =>           \r\n        prod = prod * i       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    prod = 1\n    for i in range (1,n+1):\n        prod = prod * i\n    return prod","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    prod = 1\n    for i in range (1,n+1):\n        prod = prod * term(i)\n    return prod","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":219,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        total = total * term(x) =>           \r\n        total = total * x       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = 1\n    total = 1\n    while x <= n:\n        total = total * x\n        x += 1\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = 1\n    total = 1\n    while x <= n:\n        total = total * term(x)\n        x += 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":228,"diff":"\r\nInputObject                    SideIndicator\r\n-----------                    -------------\r\n        total = total*term(i)  =>           \r\n        total = total*i        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, i = 1, 1\n    while i<=n:\n        total = total*i \n        i+=1\n    return total \n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, i = 1, 1\n    while i<=n:\n        total = total*term(i) \n        i+=1\n    return total \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":271,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        total = total * term(i) =>           \r\n        total = total * i       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    i = n\n    total = 1\n    while i > 0:\n        total = total * i\n        i -= 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    i = n\n    total = 1\n    while i > 0:\n        total = total * term(i)\n        i -= 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":279,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n            total = total * term(i) =>           \r\n            total = total * i       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i, total):\n        if i > n:\n            return total\n        else:\n            total = total * i\n            return helper(i + 1, total)\n    return helper(1, 1)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i, total):\n        if i > n:\n            return total\n        else:\n            total = total * term(i)\n            return helper(i + 1, total)\n    return helper(1, 1)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":329,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n        result = result * term(trial) =>           \r\n        result = result * trial       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    trial, result = 1, 1\n    while trial <= n:\n        result = result * trial\n        trial = trial + 1\n    return result","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    trial, result = 1, 1\n    while trial <= n:\n        result = result * term(trial)\n        trial = trial + 1\n    return result","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":433,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n        total = total*term(n)       =>           \r\n    total = 1                       =>           \r\n    while n != 0:                   =>           \r\n        return product(n, identity) =>           \r\n        total = total*n             <=           \r\n    while n == 0:                   <=           \r\n        return 1                    <=           \r\n        return product (n)          <=           \r\n    else:                           <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while n != 0:\n        total = total*n\n        n -= 1\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while n != 0:\n        total = total*term(n)\n        n -= 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":467,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n        v = v * term(x) =>           \r\n        v = v * x       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = 1\n    v = x\n    while n > 0:\n        v = v * x\n        x = x + 1\n        n = n - 1\n    return v \n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = 1\n    v = x\n    while n > 0:\n        v = v * term(x)\n        x = x + 1\n        n = n - 1\n    return v \n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":105,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        k += 1       =>           \r\n        increment(k) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    summed = 1\n    k = 1\n    while k <= n:\n        summed *= term(k)\n        increment(k)\n    return summed","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    summed = 1\n    k = 1\n    while k <= n:\n        summed *= term(k)\n        k += 1\n    return summed","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatementNode-Add, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1))))), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Target(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":106,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n)                      =>           \r\n        return term(n) * product(n-1, term) =>           \r\n        return                              <=           \r\n        term(n) * product(n-1, term)        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return\n    else:\n        term(n) * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(LeafWildcard(\"ReturnStatementNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    term(n) * product(n-1, term)","TypeError: unsupported operand type(s) for *: 'int' and 'NoneType'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":107,"diff":"\r\nInputObject                                     SideIndicator\r\n-----------                                     -------------\r\n    if n > 0:                                   =>           \r\n        return term(n) * product(n - 1, term)   =>           \r\n                                                =>           \r\n                                                =>           \r\n    if n < 1:                                   <=           \r\n        return term(n) * product((n - 1), term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n < 1:\n        return term(n) * product((n - 1), term)\n    else:\n        return term(1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n > 0:\n        return term(n) * product(n - 1, term)\n    else:\n        return term(1)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ParenthesisExpressionNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":108,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n        total = total * term(i)   =>           \r\n    x = lambda anything: identity =>           \r\n    x = lambda term: term         <=           \r\n        total = total * x(i)      <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = lambda term: term \n    total = 1\n    for i in range (1, n + 1):\n        total = total * x(i)\n    return total \n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    for i in range (1, n + 1):\n        total = total * term(i)\n    return total \n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(LambdaExpressionNode, TChild(Node(FunctionDefinitionNode-<lambda$1020>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(LambdaExpressionNode, TChild(Node(FunctionDefinitionNode-<lambda$1020>, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":111,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n    return term(n) * product(n - 1, term)          =>           \r\n    return product(n, term) * product(n - 1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    return product(n, term) * product(n - 1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    return term(n) * product(n - 1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    return product(n, term) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    return product(n, term) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    return product(n, term) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    return product(n, term) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    return product(n, term) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    return product(n, term) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    if n == 0:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":113,"diff":"\r\nInputObject                                            SideIndicator\r\n-----------                                            -------------\r\n        return term(n) * product(n - 1, term)          =>           \r\n        return product(n, term) * product(n - 1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return product(n, term) * product(n - 1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n - 1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n, term) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n, term) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n, term) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n, term) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n, term) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n, term) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":153,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n        return term(n)* product(n-1, term)           =>           \r\n        return product(n, term) * product(n-1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1: \n        return term(1)\n    else:\n        return product(n, term) * product(n-1, term)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1: \n        return term(1)\n    else:\n        return term(n)* product(n-1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n, term) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n, term) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n, term) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n, term) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n, term) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n, term) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":209,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n        return term(n) * product(n-1,term)         =>           \r\n        return product(n,term) * product(n-1,term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n<=1:\n        return term(1)\n    else:\n        return product(n,term) * product(n-1,term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n<=1:\n        return term(1)\n    else:\n        return term(n) * product(n-1,term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n,term) * product(n-1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n,term) * product(n-1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n,term) * product(n-1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n,term) * product(n-1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n,term) * product(n-1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n,term) * product(n-1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    if n<=1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":417,"diff":"\r\nInputObject                                           SideIndicator\r\n-----------                                           -------------\r\n        return term(n) * product (n-1, term)          =>           \r\n        return product(n, term) * product (n-1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n    \treturn n\n    else:\n    \treturn product(n, term) * product (n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n    \treturn n\n    else:\n    \treturn term(n) * product (n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n, term) * product (n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n, term) * product (n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n, term) * product (n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n, term) * product (n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n, term) * product (n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n, term) * product (n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    if n == 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":115,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while k <= n: =>           \r\n    while k < n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k < n:\n        total, k = total * term(k), k + 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(LeafWildcard(\"SuiteStatementNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":122,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while i <= n: =>           \r\n    while i < n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i < n:\n        total = total * term(i)\n        i += 1\n    return total \n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i <= n:\n        total = total * term(i)\n        i += 1\n    return total \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(LeafWildcard(\"SuiteStatementNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":132,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while i <= n: =>           \r\n    while i < n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    sum = 1\n    while i < n:\n        sum = sum * term(i)\n        i += 1\n    return sum\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    sum = 1\n    while i <= n:\n        sum = sum * term(i)\n        i += 1\n    return sum\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(LeafWildcard(\"SuiteStatementNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":191,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    while k <= n:               =>           \r\n    fact = product(n, identity) =>           \r\n    return fact                 =>           \r\n    while k < n:                <=           \r\n    \"*** YOUR CODE HERE ***\"    <=           \r\n    return _______              <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 1\n    product = 1\n    while k < n:\n        num = term(k)\n        product *= num\n        k += 1\n    return product","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 1\n    product = 1\n    while k <= n:\n        num = term(k)\n        product *= num\n        k += 1\n    return product","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(LeafWildcard(\"SuiteStatementNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":247,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while i <= n: =>           \r\n    while i < n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, total = 1, 1\n    while i < n:\n        total = total * term(i)\n        i += 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, total = 1, 1\n    while i <= n:\n        total = total * term(i)\n        i += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(LeafWildcard(\"SuiteStatementNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":249,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while i <= n: =>           \r\n    while i < n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i < n:\n        total = total * term(i)\n        i += 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i <= n:\n        total = total * term(i)\n        i += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(LeafWildcard(\"SuiteStatementNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":267,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while i <= n: =>           \r\n    while i < n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = i\n    while i < n:\n        total = total * term(i)\n        i = increment(i)\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = i\n    while i <= n:\n        total = total * term(i)\n        i = increment(i)\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(LeafWildcard(\"SuiteStatementNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":332,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    while k<=n: =>           \r\n    while k<n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k,mul = 1,1\n    while k<n:\n        k, mul = k+1, mul*term(k)\n    return mul\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k,mul = 1,1\n    while k<=n:\n        k, mul = k+1, mul*term(k)\n    return mul\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(LeafWildcard(\"SuiteStatementNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":338,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while a <= n: =>           \r\n    while a < n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total,a = 1,1\n    while a < n:\n        a, total = a+1 , term(a) * total\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total,a = 1,1\n    while a <= n:\n        a, total = a+1 , term(a) * total\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(LeafWildcard(\"SuiteStatementNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":368,"diff":"\r\nInputObject           SideIndicator\r\n-----------           -------------\r\n    while count <= n: =>           \r\n    while count < n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    product = 1\n    count = 1\n    while count < n:\n        product = product * term(count)\n        count += 1\n    return product","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    product = 1\n    count = 1\n    while count <= n:\n        product = product * term(count)\n        count += 1\n    return product","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(LeafWildcard(\"SuiteStatementNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":402,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n    while counter <= n: =>           \r\n    while counter < n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n  #  if n == 1:\n   #     return term(1)\n    #else:\n     #   return term(n) * product(n - 1, term)\n    counter = 1\n    total = 1\n    while counter < n:\n        total = total * term(counter) \n        counter += 1\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n  #  if n == 1:\n   #     return term(1)\n    #else:\n     #   return term(n) * product(n - 1, term)\n    counter = 1\n    total = 1\n    while counter <= n:\n        total = total * term(counter) \n        counter += 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(LeafWildcard(\"SuiteStatementNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":526,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while i <= n: =>           \r\n    while i < n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i < n:\n        i, total = i + 1, total * term(i)\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i <= n:\n        i, total = i + 1, total * term(i)\n    return total\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(LeafWildcard(\"SuiteStatementNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":118,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        return term(n)*product(n-1, term) =>           \r\n    if n==0 or n==1:                      =>           \r\n        return n                          =>           \r\n        return n*factorial(n-1)           =>           \r\n    else:                                 =>           \r\n        return product(n-1, term(n))      <=           \r\n    return _______                        <=           \r\n    \"*** YOUR CODE HERE ***\"              <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==0 or n==1:\n        return term(n)\n    else:\n        return product(n-1, term(n))\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==0 or n==1:\n        return term(n)\n    else:\n        return term(n)*product(n-1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n-1, term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n-1, term(n))","TypeError: 'int' object is not callable","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":119,"diff":"\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n        if n>0:                                     =>           \r\n            return total                            =>           \r\n    total=1                                         =>           \r\n    def multiply(n,total,term):                     =>           \r\n        else:                                       =>           \r\n            return multiply(n-1,total*term(n),term) =>           \r\n    return multiply(n,total,term)\"\"\"                =>           \r\n    \"\"\"                                             =>           \r\n                                                    =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total=1\n    def multiply(n,total,term):\n        if n==0:\n            return 0\n        elif n<1:\n            return 1\n        else:\n            return multiply(n-1,total*term(n),term)\n    return multiply(n,total,term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total=1\n    def multiply(n,total,term):\n        if n>0:\n            return multiply(n-1,total*term(n),term)\n        else:\n            return total\n    return multiply(n,total,term)\n\n    \"\"\"\n    total=1\n    def multiply(n,total,term):\n        if n==0:\n            return 0\n        elif n<1:\n            return 1\n        else:\n            return multiply(n-1,total*term(n),term)\n    return multiply(n,total,term)\"\"\"","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-GreaterThan, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0)))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-total))))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ExpressionStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-\n    total=1\n    def multiply(n,total,term):\n        if n==0:\n            return 0\n        elif n<1:\n            return 1\n        else:\n            return multiply(n-1,total*term(n),term)\n    return multiply(n,total,term)))), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(FunctionDefinitionNode-multiply, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":120,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        return term(n)*product(n-1, term) =>           \r\n        return term(n-1)                  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n-1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n)*product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0)))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":123,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    if n==1:           =>           \r\n        return term(1) =>           \r\n    if n==0:           <=           \r\n        return 0       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==0:\n        return 0\n    return term(n)*product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return term(1)\n    return term(n)*product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":193,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    if n == 1:         =>           \r\n        return term(1) =>           \r\n    if n == 0:         <=           \r\n        return 0       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return term(n) * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":124,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n                                    =>           \r\n        total = total * term(count) =>           \r\n    count = 1                       =>           \r\n    while count <= n:               =>           \r\n        count += 1                  =>           \r\n                                    =>           \r\n                                    =>           \r\nfrom functools import reduce        <=           \r\n    list1 = []                      <=           \r\n    theList = list(range(1, n+1))   <=           \r\n    for i in theList:               <=           \r\n        list1 = [term(i)]           <=           \r\n    total = reduce(mul, list1, 1)   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    list1 = []\n    total = 1\n    theList = list(range(1, n+1))\n    for i in theList:\n        list1 = [term(i)]\n    total = reduce(mul, list1, 1)\n    return tota","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    total = 1\n    count = 1\n    while count <= n:\n        total = total * term(count)\n        count += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ListExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ListExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-count)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-count)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ListExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ListExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ListExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ListExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ListExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-count)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(ListExpressionNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0))))), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ListExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ListExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChildren(Target(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ListExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ListExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ListExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-count)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-count), SingleChild(LeafConstNode(NameExpressionNode-n)))), SingleChild(ConstNode(SuiteStatementNode, Children(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(ListExpressionNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0))))))), SingleChild(ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-count), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ListExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ListExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ListExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ListExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ListExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ListExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))))))))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","3","","# Error: expected","#     6","# but got","#     3","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":125,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    if n==1:           =>           \r\n        return term(1) =>           \r\n    if n==0:           <=           \r\n        return term(0) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==0:\n        return term(0)\n    return term(n) * product(n-1,term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return term(1)\n    return term(n) * product(n-1,term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":309,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    i, b = 1, 1 =>           \r\n    i, b = 0, 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, b = 0, 0\n    while i <= n:\n        b *= term(i)\n        i += 1\n    return b\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, b = 1, 1\n    while i <= n:\n        b *= term(i)\n        i += 1\n    return b\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":475,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    if n == 1:         =>           \r\n        return term(1) =>           \r\n    if n == 0:         <=           \r\n        return term(0) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return term(0)\n    else:\n        return term(n) * product((n - 1), term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product((n - 1), term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":502,"diff":"\r\nInputObject                                    SideIndicator\r\n-----------                                    -------------\r\n    def better_product(n, term, i=1, total=1): =>           \r\n    return better_product(n, term, 1, 1)       =>           \r\n    def better_product(n, term, i=1, total=0): <=           \r\n    return better_product(n, term, 1, 0)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def better_product(n, term, i=1, total=0):\n        if i > n:\n            return total\n        else:\n            return better_product(n, term, i + 1, total * term(i))\n    return better_product(n, term, 1, 0)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def better_product(n, term, i=1, total=1):\n        if i > n:\n            return total\n        else:\n            return better_product(n, term, i + 1, total * term(i))\n    return better_product(n, term, 1, 1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":126,"diff":"\r\nInputObject                        SideIndicator\r\n-----------                        -------------\r\n    total = 1                      =>           \r\n        total = total * term(x)    =>           \r\n    return total                   =>           \r\n        return term(n*(n+1)*(n+2)) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    x = 1\n    while x<=n:\n        return term(n*(n+1)*(n+2))\n        x+=1\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    x = 1\n    total = 1 \n    while x<=n:\n        total = total * term(x)\n        x+=1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-x))))))), Selected(\\x => Match(x, Node(ParenthesisExpressionNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ParenthesisExpressionNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0), 1), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), 0), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 5), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))), InOrderSort(ast)))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","60","","# Error: expected","#     6","# but got","#     60","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":129,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n        i = increment(i) =>           \r\n        k = increment(k) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    prod, i = 1, 1\n    while i <=n:\n        prod = prod * term(i)\n        k = increment(k)\n    return prod","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    prod, i = 1, 1\n    while i <=n:\n        prod = prod * term(i)\n        i = increment(i)\n    return prod","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    k = increment(k)","UnboundLocalError: local variable 'k' referenced before assignment","","# Error: expected","#     6","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":133,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n                                =>           \r\n    count = term(1)             =>           \r\n    for i in range(2, n+1):     =>           \r\n        num = term(i)           =>           \r\n        count = count * num     =>           \r\n    count = 1                   <=           \r\n    i = 1                       <=           \r\n    while i <= n:               <=           \r\n        count = count * term(i) <=           \r\n                                <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    count = 1\n    i = 1\n    while i <= n:\n        count = count * term(i)\n        increment(i)\n    return count\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    count = term(1)\n    for i in range(2, n+1):\n        num = term(i)\n        count = count * num\n        increment(i)\n    return count","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-num)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-count), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-count), SingleChild(LeafConstNode(NameExpressionNode-num))))))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ForStatementNode, Children(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-range), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-2))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))), SingleChild(ReferenceNode(node, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast)))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":134,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    k, product = 1, 1                       =>           \r\n        product, k = product*term(k), k+1   =>           \r\n    k, product = 1, 0                       <=           \r\n        product, k = (product*term(k)), k+1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, product = 1, 0\n    while k <= n:\n        product, k = (product*term(k)), k+1\n    return product","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, product = 1, 1\n    while k <= n:\n        product, k = product*term(k), k+1\n    return product","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(TupleExpressionNode-False, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ParenthesisExpressionNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0), 0), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(TupleExpressionNode-False, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":384,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    total, k = 1, 1                         =>           \r\n        total, k = total * term(k), k + 1   =>           \r\n    total, k = 0, 1                         <=           \r\n        total, k = (total * term(k)), k + 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    total, k = 0, 1\n    while k <= n:\n        total, k = (total * term(k)), k + 1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(TupleExpressionNode-False, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ParenthesisExpressionNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0), 0), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(TupleExpressionNode-False, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":135,"diff":"","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return total\n    total = term(n)\n    return product(n-1, term) * total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = term(n)\n    if n == 1:\n        return total\n    return product(n-1, term) * total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n-1, term) * total","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(n-1, term) * total","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    return total","UnboundLocalError: local variable 'total' referenced before assignment","","# Error: expected","#     6","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":136,"diff":"\r\nInputObject                                     SideIndicator\r\n-----------                                     -------------\r\n    total, k = 1, 1                             =>           \r\n        total, k = (total) * term(k), k + 1     =>           \r\n    total, k = 0, 0                             <=           \r\n        total, k = (total + 1) * term(k), k + 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 0\n    while k <= n:\n        total, k = (total + 1) * term(k), k + 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = (total) * term(k), k + 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"ConstantExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ParenthesisExpressionNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","15","","# Error: expected","#     6","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":137,"diff":"\r\nInputObject                                                  SideIndicator\r\n-----------                                                  -------------\r\n    return reduce(lambda x, y: x * y, (map(term, new_list))) =>           \r\n    return reduce(mul (map(term, new_list)))                 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def list(a):\n        if a==n:\n            return [a]\n        else:\n            return [a] + list(a+1)\n    new_list= list(1)\n    return reduce(mul (map(term, new_list)))\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def list(a):\n        if a==n:\n            return [a]\n        else:\n            return [a] + list(a+1)\n    new_list= list(1)\n    return reduce(lambda x, y: x * y, (map(term, new_list)))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(LambdaExpressionNode, SingleChild(ConstNode(FunctionDefinitionNode-<lambda$1303>, Children(LeafConstNode(ParameterNode-x), Children(LeafConstNode(ParameterNode-y), SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-x), SingleChild(LeafConstNode(NameExpressionNode-y)))))))))))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ParenthesisExpressionNode, SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)))), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    return reduce(mul (map(term, new_list)))","TypeError: op_mul expected 2 arguments, got 1","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":139,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    i = 1                   =>           \r\n    while i <= n:           =>           \r\n            i += 1          =>           \r\n    for i in range(1, n+1): <=           \r\n        while i <= n:       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    for i in range(1, n+1):\n        while i <= n:\n            total = total * term(i)\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    i = 1\n    while i <= n:\n            total = total * term(i)\n            i += 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-i), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), 0), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":144,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    k = 1         =>           \r\n    while k < n:  =>           \r\n    k = 0         <=           \r\n    while k <= n: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 0\n    product = term(k)\n    while k <= n:\n        k += 1\n        product = product * term(k)\n    return product","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 1\n    product = term(k)\n    while k < n:\n        k += 1\n        product = product * term(k)\n    return product","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":145,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while k <= n: =>           \r\n    while k <= 1: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    k = 1\n    while k <= 1:\n        total = total * term(k)\n        k = k + 1\n    return total\n\n    ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    k = 1\n    while k <= n:\n        total = total * term(k)\n        k = k + 1\n    return total\n\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":289,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while k <= n: =>           \r\n    while k <= 1: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k,multi=1,1\n    while k <= 1:\n        multi=term(k)*multi\n        k=k+1\n    return multi ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k,multi=1,1\n    while k <= n:\n        multi=term(k)*multi\n        k=k+1\n    return multi ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":146,"diff":"\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n            total = total * term(i)  =>           \r\n        return total                 =>           \r\n            total == total * term(i) <=           \r\n            return total             <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    if n == 0 or n == 1:\n        return n\n    if n > 0:\n        while i <= n:\n            total == total * term(i)\n            i += 1\n            return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    if n == 0 or n == 1:\n        return n\n    if n > 0:\n        while i <= n:\n            total = total * term(i)\n            i += 1\n        return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ReferenceNode(node, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), SingleChild(ConstNode(SuiteStatementNode, Children(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i)))))))))))), SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0))))))), 0), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0), 1), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":147,"diff":"\r\nInputObject                                      SideIndicator\r\n-----------                                      -------------\r\n    new_list = list(map(term, range(1, n + 1)))  =>           \r\n    return reduce(mul, new_list)                 =>           \r\n    new_list = list(map(term, range(1, n + 1)))  =>           \r\ndef new_list(x):                                 <=           \r\n    return list(map(term, range(1, n + 1)))      <=           \r\n    #new_list = list(map(term, range(1, n + 1))) <=           \r\n    return reduce(mul, new_list(n))              <=           \r\n    #new_list = list(map(term, range(1, n + 1))) <=           \r\n                                                 <=           \r\n                                                 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    #new_list = list(map(term, range(1, n + 1)))\n\n    return reduce(mul, new_list(n))","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    new_list = list(map(term, range(1, n + 1)))\n    return reduce(mul, new_list)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-map)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-range), 0), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))), 1), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-new_list), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-list), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-map), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-range), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))))))))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-reduce), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-mul))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-new_list))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    return reduce(mul, new_list(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 18, in new_list","    return list(map(term, range(1, n + 1)))","NameError: name 'term' is not defined","","# Error: expected","#     6","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":149,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return term(n) * product(n-1, term) =>           \r\n    return n * term(n-1)                <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    return n * term(n-1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":457,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return n * term(n-1)                <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return term(n)\n    else:\n        return n * term(n-1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":150,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return term(n, product(n-1, term))  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return 1\n    else:\n        return term(n, product(n-1, term))\n   ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return 1\n    else:\n        return term(n) * product(n-1, term)\n   ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)))), SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product","    return term(n, product(n-1, term))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product","    return term(n, product(n-1, term))","TypeError: identity() takes 1 positional argument but 2 were given","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":152,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    if n == 1:         =>           \r\n        return term(n) =>           \r\n    if n == 0:         <=           \r\n        return 0       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return term(n) * product(n - 1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n - 1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":155,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        a  = a * term(n)         =>           \r\n        n -= 1                   =>           \r\n        a  = a * product(n,term) <=           \r\n        n = n - 1                <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    a = 1\n    while n > 1:\n        a  = a * product(n,term)\n        n = n - 1\n    if n == 1:\n        return a\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    a = 1\n    while n > 1:\n        a  = a * term(n) \n        n -= 1 \n    if n == 1:\n        return a\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatementNode-Subtract, Children(ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    a  = a * product(n,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    a  = a * product(n,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    a  = a * product(n,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    a  = a * product(n,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    a  = a * product(n,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    a  = a * product(n,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    while n > 1:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":156,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        product, k = product*term(k), k+1 =>           \r\n        product, k = product+term(k), k+1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k, product = 1, 1\n    while k <= n:\n        product, k = product+term(k), k+1\n    return product\n\n    ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k, product = 1, 1\n    while k <= n:\n        product, k = product*term(k), k+1\n    return product\n\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))))), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","7","","# Error: expected","#     6","# but got","#     7","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":520,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        total = total * term(n) =>           \r\n        total = total + term(n) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while n > 0:\n        total = total + term(n)\n        n -= 1\n    return total ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while n > 0:\n        total = total * term(n)\n        n -= 1\n    return total ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))))), Selected(\\x => Match(x, Skip(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","7","","# Error: expected","#     6","# but got","#     7","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":159,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    while n + 1 > x: =>           \r\n    while n > x:     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x , total = 1 , 1\n    while n > x:\n        total = total * term(x) \n        x += 1\n    return total ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x , total = 1 , 1\n    while n + 1 > x:\n        total = total * term(x) \n        x += 1\n    return total ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-GreaterThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":160,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    t,i = 1,1 =>           \r\n    i = 1     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    while i <= n:\n        t *= term(i)\n        i+=1\n    return t","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    t,i = 1,1\n    while i <= n:\n        t *= term(i)\n        i+=1\n    return t","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-t), SingleChild(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(TupleExpressionNode-False, Children(LeafConstNode(ConstantExpressionNode-1), SingleChild(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    t *= term(i)","UnboundLocalError: local variable 't' referenced before assignment","","# Error: expected","#     6","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":165,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        return term(n) * product((n-1),term) =>           \r\n        return term(n) * product(term(n-1))  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return term(n) * product(term(n-1))","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return term(n) * product((n-1),term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(ParenthesisExpressionNode, SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)))), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n) * product(term(n-1))","TypeError: product() missing 1 required positional argument: 'term'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":168,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    total = 1                   =>           \r\n    k = 1                       =>           \r\n    while k <= n:               =>           \r\n        total = total * term(k) =>           \r\n        k = k + 1               =>           \r\n    return total                =>           \r\n    product = 1                 <=           \r\n    count = n                   <=           \r\n    while count>0:              <=           \r\n        product *= term(n)      <=           \r\n        n -= 1                  <=           \r\n    return product              <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    product = 1\n    count = n\n    while count>0:\n        product *= term(n)\n        n -= 1\n    return product\n    \"*** YOUR CODE HERE ***\"","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    k = 1\n    while k <= n:\n        total = total * term(k)\n        k = k + 1\n    return total\n    \"*** YOUR CODE HERE ***\"","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(BinaryExpressionNode-GreaterThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(NameExpressionNode-n))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-k)))))))))))), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-k), SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Target(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":172,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n    def helper(k, term):                             =>           \r\n        if k == n:                                   =>           \r\n            return term(k)                           =>           \r\n        else:                                        =>           \r\n            return term(k) * helper(k + 1, term)     =>           \r\n    return helper(1, term)                           =>           \r\n    def helper(k):                                   <=           \r\n        if k >= n:                                   <=           \r\n            return term(1) * product(k + 1, term(k)) <=           \r\n    helper(1)                                        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    def helper(k):\n        if k >= n: \n            return term(1) * product(k + 1, term(k))\n    helper(1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    def helper(k, term):\n        if k == n: \n            return term(k)\n        else: \n            return term(k) * helper(k + 1, term)\n    return helper(1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(ParameterNode-term), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(NameExpressionNode-n)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-k))))))))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-helper)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))), TChild(Target(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":179,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        nextnumber =term(a+1)             =>           \r\n        result=term(a)*nextnumber         =>           \r\n        return term(a)*final_product(a+1) =>           \r\n    a=n                                   =>           \r\n    def final_factorial(a):               =>           \r\n        nextnumber=a                      =>           \r\n        result=a*nextnumber               =>           \r\n        if a==1:                          =>           \r\n            return result                 =>           \r\n        return a*final_factorial(a-1)     =>           \r\n    return final_factorial(a)             =>           \r\n        result=term(a) * term(a+1)        <=           \r\n        return final_product(a+1)         <=           \r\n    return _______                        <=           \r\n    \"*** YOUR CODE HERE ***\"              <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    a=1\n    def final_product(a):\n        result=term(a) * term(a+1)\n        if a+1==n:\n            return result\n        return final_product(a+1)\n    return final_product(a)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    a=1\n    def final_product(a):\n        nextnumber =term(a+1)\n        result=term(a)*nextnumber\n        if a+1==n:\n            return result\n        return term(a)*final_product(a+1)\n    return final_product(a)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-nextnumber), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))))), 0), Selected(\\x => Match(x, Node(FunctionDefinitionNode-final_product, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-result), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), 0), SingleChild(LeafConstNode(NameExpressionNode-nextnumber))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-final_product, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-final_product, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-a)))))), SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0)))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast)))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":183,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        return product(n-1, term)* term(n) =>           \r\n        return product(n-1, term)*n        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    if n == 1:\n        return 1\n    else:\n        return product(n-1, term)*n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n    if n == 1:\n        return 1\n    else:\n        return product(n-1, term)* term(n)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":489,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return product(n-1, term) * term(n) =>           \r\n    return product(n-1, term) * n       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if (n == 1):\n        return 1\n    return product(n-1, term) * n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if (n == 1):\n        return 1\n    return product(n-1, term) * term(n)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":184,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n            total *= t**2         =>           \r\n    return total                  =>           \r\n            total *= total*(t**2) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i=0\n    t=1\n    total=1\n    while i < n:\n        if term == identity:\n            total *= t\n            i += 1\n            t += 1 \n        elif term == square:\n            total *= total*(t**2)\n            i += 1\n            t += 1\n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i=0\n    t=1\n    total=1\n    while i < n:\n        if term == identity:\n            total *= t\n            i += 1\n            t += 1 \n        elif term == square:\n            total *= t**2\n            i += 1\n            t += 1\n    return total\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ParenthesisExpressionNode, TChild(Target(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 5), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":186,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    if n == 1:                              =>           \r\n        return term(1)                      =>           \r\n        return term(n) * product(n-1, term) =>           \r\n    return product(n, mul)                  =>           \r\n    else:                                   =>           \r\n                                            =>           \r\n    return _______                          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":195,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        return term(n)*product(n-1, term)  =>           \r\n        return product(term(n), term(n-1)) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==0:\n        return 1\n    else:\n        return product(term(n), term(n-1))\n\n    \"*** YOUR CODE HERE ***\"","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==0:\n        return 1\n    else:\n        return term(n)*product(n-1, term)\n\n    \"*** YOUR CODE HERE ***\"","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(term(n), term(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product(term(n), term(n-1))","TypeError: 'int' object is not callable","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":196,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n            return term(n) =>           \r\n            return 1       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def counter(i):\n        if i == n:\n            return 1\n        else:\n            return term(i) * counter(i+1)\n    return counter(1)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def counter(i):\n        if i == n:\n            return term(n)\n        else:\n            return term(i) * counter(i+1)\n    return counter(1)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":197,"diff":"\r\nInputObject                                             SideIndicator\r\n-----------                                             -------------\r\n    def counter(count, term):                           =>           \r\n            return term(count) * counter(count+1, term) =>           \r\n    return counter(1, term)                             =>           \r\n    def counter(count):                                 <=           \r\n            return term(count) * product(count+1, term) <=           \r\n    return counter(1)                                   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def counter(count):\n        if count == n:\n            return term(n)\n        else:\n            return term(count) * product(count+1, term)\n    return counter(1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def counter(count, term):\n        if count == n:\n            return term(n)\n        else:\n            return term(count) * counter(count+1, term)\n    return counter(1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(ParameterNode-term), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(FunctionDefinitionNode-counter, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-counter)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in counter","    return term(count) * product(count+1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 36, in product","    return counter(1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in counter","    return term(count) * product(count+1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 36, in product","    return counter(1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in counter","    return term(count) * product(count+1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 36, in product","    return counter(1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in counter","    if count == n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":198,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n    i = 1                           =>           \r\n    total = 1                       =>           \r\n    while i <= n:                   =>           \r\n        total = total * term(i)     =>           \r\n        i += 1                      =>           \r\n    return total                    =>           \r\n    return product(n, identity)     =>           \r\n    if combiner == add:             =>           \r\n        i = 1                       =>           \r\n        total = base                =>           \r\n        while (i <= n):             =>           \r\n            total = total + term(i) =>           \r\n            i += 1                  =>           \r\n        return total                =>           \r\n        i = 1                       =>           \r\n        total = base                =>           \r\n        while (i <= n):             =>           \r\n            total = total * term(i) =>           \r\n            i += 1                  =>           \r\n        return total                =>           \r\n                                    =>           \r\n    else:                           =>           \r\nfrom math import factorial          <=           \r\n    return term(factorial(n))       <=           \r\n    return factorial(n)             <=           \r\n    \"*** YOUR CODE HERE ***\"        <=           \r\n                                    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    return term(factorial(n))","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i <= n:\n        total = total * term(i)\n        i += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0))))), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(NameExpressionNode-n)))), SingleChild(ConstNode(SuiteStatementNode, Children(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0))))))), SingleChild(ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 45, in factorial","    return factorial(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 45, in factorial","    return factorial(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 45, in factorial","    return factorial(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 45, in factorial","    return factorial(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 45, in factorial","    return factorial(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 45, in factorial","    return factorial(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 45, in factorial","    return factorial(n)","RecursionError: maximum recursion depth exceeded","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":199,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        if k == 1:                        =>           \r\n            total = 1                     =>           \r\n            k = k+1                       =>           \r\n        else:                             =>           \r\n            total, k = total*term(k), k+1 =>           \r\n        total, k = total*term(k), k+1     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        total, k = total*term(k), k+1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 0, 1\n    while k <= n:\n        if k == 1:\n            total = 1\n            k = k+1\n        else:\n            total, k = total*term(k), k+1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(SuiteStatementNode, SingleChild(ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, Children(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-k), SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))), SingleChild(ReferenceNode(node, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), 0)))))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":200,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        return term(n)                       =>           \r\n    if(n == 1):                              =>           \r\n        return 1                             =>           \r\n        return n * product(n - 1, factorial) =>           \r\n    if(n == 1):                              =>           \r\n    else:                                    =>           \r\n    n = n * factorial(n - 1)                 <=           \r\n    return product(n, factorial)             <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    return term(n) * product(n - 1, term)\n    ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if(n == 1):\n        return term(n)\n    return term(n) * product(n - 1, term)\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(ParenthesisExpressionNode, SingleChild(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))))))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n - 1, term)","RecursionError: maximum recursion depth exceeded","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":201,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n        final*=term(count) =>           \r\n        final*=term(n)     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    count = 1\n    final = 1\n    while count < n+1:\n        final*=term(n)\n        count+=1\n        \n\n    return final","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    count = 1\n    final = 1\n    while count < n+1:\n        final*=term(count)\n        count+=1\n        \n\n    return final","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-count)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","27","","# Error: expected","#     6","# but got","#     27","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":202,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        if a == n+1: =>           \r\n        if a+1 == n: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def count_mult(a):\n        if a+1 == n:\n            return 1\n        else:\n            return count_mult(a+1) * term(a)\n    return count_mult(1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def count_mult(a):\n        if a == n+1:\n            return 1\n        else:\n            return count_mult(a+1) * term(a)\n    return count_mult(1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-a), 0), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":203,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        y *= term(x) =>           \r\n        y += term(x) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x, y = 1, 1\n    while x <= n:\n        y += term(x)\n        x += 1\n    return y","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x, y = 1, 1\n    while x <= n:\n        y *= term(x)\n        x += 1\n    return y","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatementNode-Multiply, Children(ReferenceNode(node, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ReferenceNode(node, Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","7","","# Error: expected","#     6","# but got","#     7","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":204,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    total = 1                            =>           \r\n    k = 1                                =>           \r\n    while k <= n:                        =>           \r\n        total = total * term(k)          =>           \r\n        k += 1                           =>           \r\n    return total                         =>           \r\n    if n <= 2:                           <=           \r\n        return n                         <=           \r\n    else:                                <=           \r\n        return n * product(n-1, term(n)) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n <= 2:  \n        return n \n    else: \n        return n * product(n-1, term(n))\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    k = 1 \n    while k <= n:  \n        total = total * term(k)\n        k += 1 \n    return total \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), 1), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0))))), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), 0), 0), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(NameExpressionNode-n)))), SingleChild(ConstNode(SuiteStatementNode, Children(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0))))))), SingleChild(ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))))))), InOrderSort(ast)))))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return n * product(n-1, term(n))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return n * product(n-1, term(n))","TypeError: 'int' object is not callable","","# Error: expected","#     120","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":210,"diff":"\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n        return term(n) * product(n-1, term)         =>           \r\n        return identity(n) * product(n-1, identity) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n<2:\n        return 1\n    else:\n        return identity(n) * product(n-1, identity)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n<2:\n        return 1\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":213,"diff":"\r\nInputObject                                                  SideIndicator\r\n-----------                                                  -------------\r\n            return term(i) * helper_function(i + 1, n, term) =>           \r\n    return helper_function(1, n, term)                       =>           \r\n            return term(i) * term(i + 1)                     <=           \r\n    return term(1)                                           <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper_function(i, n, term):\n        if i > n:\n            return 1\n        else:\n            return term(i) * term(i + 1)\n    return term(1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper_function(i, n, term):\n        if i > n:\n            return 1\n        else:\n            return term(i) * helper_function(i + 1, n, term)\n    return helper_function(1, n, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-helper_function)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))), 2), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 3), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-helper_function)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))), 2), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 3), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":217,"diff":"\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n        counter = increment(counter) =>           \r\n        increment(counter)           <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    counter = 1\n    result = 1\n    while counter <= n:\n        num = term(counter)\n        result *= num\n        increment(counter)\n    return result\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    counter = 1\n    result = 1\n    while counter <= n:\n        num = term(counter)\n        result *= num\n        counter = increment(counter)\n    return result\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-counter), SingleChild(ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":218,"diff":"\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n    if(n==0):                        =>           \r\n        return 1                     =>           \r\n    return product(n-1,term)*term(n) =>           \r\n    count=1                          <=           \r\n    num=1                            <=           \r\n    if(count<n):                     <=           \r\n        val=term(num)                <=           \r\n    num+=1                           <=           \r\n    count+=1                         <=           \r\n    return product(n,val)            <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    count=1\n    num=1\n    if(count<n):\n        val=term(num)\n    num+=1\n    count+=1\n    return product(n,val)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if(n==0):\n        return 1\n    return product(n-1,term)*term(n)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0))))), Selected(\\x => Match(x, Node(ParenthesisExpressionNode, TChild(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), 0), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 36, in product","    return product(n,val)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    val=term(num)","TypeError: 'int' object is not callable","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":220,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while n > 1:  =>           \r\n    while n >= 1: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = term(n)\n    while n >= 1:\n        n -= 1\n        x *= term(n)\n    return x\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = term(n)\n    while n > 1:\n        n -= 1\n        x *= term(n)\n    return x\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(LeafWildcard(\"SuiteStatementNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":388,"diff":"\r\nInputObject     SideIndicator\r\n-----------     -------------\r\n    while n>1:  =>           \r\n    while n>=1: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    result = term(n)\n    while n>=1:\n        result, n = result*term(n-1), n-1\n    return result","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    result = term(n)\n    while n>1:\n        result, n = result*term(n-1), n-1\n    return result","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(LeafWildcard(\"SuiteStatementNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":223,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n            return term(i) * the_count(i + 1) =>           \r\n            return i * the_count(i + 1)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def the_count(i):\n        if i == n:\n            return term(n)\n        else:\n            return i * the_count(i + 1)\n    return the_count(1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def the_count(i):\n        if i == n:\n            return term(n)\n        else:\n            return term(i) * the_count(i + 1)\n    return the_count(1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","18","","# Error: expected","#     36","# but got","#     18","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":292,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n            return term(k) * counter(k + 1) =>           \r\n            return k * counter(k + 1)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    def counter(k):\n        if k == n:\n            return term(k)\n        else:\n            return k * counter(k + 1)\n    return counter(1)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    def counter(k):\n        if k == n:\n            return term(k)\n        else:\n            return term(k) * counter(k + 1)\n    return counter(1)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","18","","# Error: expected","#     36","# but got","#     18","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":308,"diff":"\r\nInputObject                                                  SideIndicator\r\n-----------                                                  -------------\r\n            return term(k) * product_bodyguard(n, term, k+1) =>           \r\n            return k * product_bodyguard(n, term, k+1)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def product_bodyguard(n, term, k):\n        if k == n:\n            return term(n)\n        else:\n            return k * product_bodyguard(n, term, k+1)\n    return product_bodyguard(n, term, 1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def product_bodyguard(n, term, k):\n        if k == n:\n            return term(n)\n        else:\n            return term(k) * product_bodyguard(n, term, k+1)\n    return product_bodyguard(n, term, 1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","18","","# Error: expected","#     36","# but got","#     18","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":394,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        return term(x)*product(x-1, term)  =>           \r\n        return x*product(x-1, term)        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x=n\n    if x==1:\n        return 1\n    else:\n        return x*product(x-1, term) \n        \n    \n\n ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x=n\n    if x==1:\n        return 1\n    else:\n        return term(x)*product(x-1, term) \n        \n    \n\n ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"CallExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"CallExpressionNode\")))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":226,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    if n == 1:                              =>           \r\n        return term(1)                      =>           \r\n    else:                                   =>           \r\n        return term(n) * product(n-1, term) =>           \r\n    i == 1                                  <=           \r\n                                            <=           \r\n    while i < n:                            <=           \r\n        return term(i) * product(i+1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i == 1\n    \n    while i < n:\n        return term(i) * product(i+1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    i == 1","NameError: name 'i' is not defined","","# Error: expected","#     6","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":231,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        else:                            =>           \r\n            return total                 =>           \r\n    return product_maker(n, term, total) =>           \r\n    return total                         <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    def product_maker(n, term, total):\n        if n > 0:\n            total = total * (term(n))\n            return product_maker(n-1, term, total)\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    def product_maker(n, term, total):\n        if n > 0:\n            total = total * (term(n))\n            return product_maker(n-1, term, total)\n        else:\n            return total\n    return product_maker(n, term, total)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-total))))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product_maker), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(FunctionDefinitionNode-product_maker, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(FunctionDefinitionNode-product_maker, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ParenthesisExpressionNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":233,"diff":"\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n        k+=1 =>           \r\n        k+1  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k=1\n    total=1\n    while k<n+1:\n        total=total*term(k)\n        k+1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k=1\n    total=1\n    while k<n+1:\n        total=total*term(k)\n        k+=1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatementNode-Add, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Target(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":234,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    if n == 1:                              =>           \r\n        return term(n)                      =>           \r\n        p = term(n) * product(n-1, term)    =>           \r\n        return p                            =>           \r\n    else:                                   =>           \r\n    i = 1                                   <=           \r\n    if i < n:                               <=           \r\n        return term(i) * product(i+1, term) <=           \r\n                                            <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    if i < n:\n        return term(i) * product(i+1, term)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    else:\n        p = term(n) * product(n-1, term)\n        return p\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-p), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term)))))))))))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-p))), 1), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))))))))))))), SingleChild(ConstNode(SuiteStatementNode, Children(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-p), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))), SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-p))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))))))), InOrderSort(ast))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(i) * product(i+1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(i) * product(i+1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(i) * product(i+1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(i) * product(i+1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(i) * product(i+1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(i) * product(i+1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    if i < n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":238,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n        result = result * term(x) =>           \r\n        result = term(x)          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = 1\n    for x in range(1,n+1):\n        result = term(x)\n    return result","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = 1\n    for x in range(1,n+1):\n        result = result * term(x)\n    return result","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-result), SingleChild(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","3","","# Error: expected","#     6","# but got","#     3","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":241,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        total = total * term(c) =>           \r\n        total = total * term(k) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    total = 1\n    c = 1\n    while c <= n:\n        total = total * term(k)\n        c = c + 1\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    total = 1\n    c = 1\n    while c <= n:\n        total = total * term(c)\n        c = c + 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-c)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product","    total = total * term(k)","NameError: name 'k' is not defined","","# Error: expected","#     6","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":243,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    while k <= n:               =>           \r\n    if k <= n:                  <=           \r\n        return product(n, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 1\n    answer = 1\n    if k <= n:\n        answer = answer * term(k)\n        k += 1\n        return product(n, term)\n    return answer","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = 1\n    answer = 1\n    while k <= n:\n        answer = answer * term(k)\n        k += 1\n    return answer","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(WhileStatementNode, Children(ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0), SingleChild(ReferenceNode(node, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0))))), Selected(\\x => Match(x, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), 0), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in product","    return product(n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in product","    return product(n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in product","    return product(n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in product","    return product(n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in product","    return product(n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in product","    return product(n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    if k <= n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":246,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n        if k < n:                          =>           \r\n            return term(k) * helper(k + 1) =>           \r\n        elif k == n:                       =>           \r\n        if k <= n:                         <=           \r\n            return term(k) * term(k + 1)   <=           \r\n        else:                              <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper(k):\n        if k <= n:\n            return term(k) * term(k + 1)\n        else: \n            return term(k) \n    return helper(1) ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper(k):\n        if k < n:\n            return term(k) * helper(k + 1)\n        elif k == n: \n            return term(k) \n    return helper(1) ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-helper)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(NameExpressionNode-n)))), SingleChild(ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0)))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":248,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    if n==1:                               =>           \r\n        return 1                           =>           \r\n        return term(n) * product(n-1,term) =>           \r\n    return product(n,product)              =>           \r\n    if n==0 or n==1:                       =>           \r\n        return 1                           =>           \r\n    else:                                  =>           \r\n        n=1                                =>           \r\n        return n*factorial(n-1)            =>           \r\n    else:                                  =>           \r\n                                           =>           \r\n                                           =>           \r\n                                           =>           \r\n    \"*** YOUR CODE HERE ***\"               <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n    \treturn 1\n    else:\n    \treturn term(n) * product(n-1,term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":251,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    result = 1                             =>           \r\n            result = result * term(n)      =>           \r\n    return result                          =>           \r\n            product = term(n) * term (n-1) <=           \r\n            return product                 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        while n > 1:\n            product = term(n) * term (n-1)\n            n -= 1\n            return product\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    result = 1\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        while n > 1:\n            result = result * term(n)\n            n -= 1\n    return result\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-result), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-result)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-result)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-result))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast)))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":253,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n    counter = n - 1                   <=           \r\n    while counter > 0:                <=           \r\n        total = total * term(counter) <=           \r\n        counter -= 1                  <=           \r\n    total = 1                         <=           \r\n    return total                      <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    counter = n - 1\n    while counter > 0:\n        total = total * term(counter)\n        counter -= 1\n    return total\n\n    total = 1\n    for i in range(1, n+1, 1):\n        total = total * term(i)\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    total = 1\n    for i in range(1, n+1, 1):\n        total = total * term(i)\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":254,"diff":"\r\nInputObject                                                                                         SideIndicator\r\n-----------                                                                                         -------------\r\n    total=1                                                                                         =>           \r\n    i=1                                                                                             =>           \r\n    while i <= n:                                                                                   =>           \r\n        total=total*term(i)                                                                         =>           \r\n        i+=1                                                                                        =>           \r\n    return total                                                                                    =>           \r\n                                                                                                    =>           \r\n    return accumulate(base if not pred(term) else lambda term,base:combiner(term,base),base,n,term) =>           \r\n    # total=1                                                                                       <=           \r\n    # i=1                                                                                           <=           \r\n    # while i <= n:                                                                                 <=           \r\n    #     total=total*term(i)                                                                       <=           \r\n    #     i+=1                                                                                      <=           \r\n    # return total                                                                                  <=           \r\n    return term(n)*product(n-1,term)                                                                <=           \r\n    return accumulate(lambda term,base:combiner(term,base) if pred(term) else base,base,n,term)     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    # total=1\n    # i=1\n    # while i <= n:\n    #     total=total*term(i)\n    #     i+=1\n    # return total\n    return term(n)*product(n-1,term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total=1\n    i=1\n    while i <= n:\n        total=total*term(i)\n        i+=1\n    return total\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(NameExpressionNode-n)))), SingleChild(ConstNode(SuiteStatementNode, Children(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))))))), SingleChild(ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-total)))), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0), 5), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast)))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    return term(n)*product(n-1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    return term(n)*product(n-1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    return term(n)*product(n-1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    return term(n)*product(n-1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    return term(n)*product(n-1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    return term(n)*product(n-1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    return term(n)*product(n-1,term)","RecursionError: maximum recursion depth exceeded","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":256,"diff":"\r\nInputObject                                         SideIndicator\r\n-----------                                         -------------\r\n            return helper(n - 1, term, x * term(n)) =>           \r\n    return helper(n, term, 1)                       =>           \r\n            return x * term(n)                      <=           \r\n    return (n - 1, term, x)                         <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper(n, term, x):\n        if n == 0:\n            return x\n        else:\n            return x * term(n)\n    return (n - 1, term, x)\n\n\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper(n, term, x):\n        if n == 0:\n            return x\n        else:\n            return helper(n - 1, term, x * term(n))\n    return helper(n, term, 1)\n\n\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-helper), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)))), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-helper), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0))), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in product","    return (n - 1, term, x)","NameError: name 'x' is not defined","","# Error: expected","#     6","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":257,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    if n==1:     =>           \r\n        return 1 =>           \r\n    if n == 1:   <=           \r\n        return   <=           \r\n    if n==0:     <=           \r\n        return 0 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return\n    if n==0:\n        return 0\n    return term(n)*product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return 1\n    return term(n)*product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(LeafWildcard(\"ReturnStatementNode\"))))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(LeafWildcard(\"ReturnStatementNode\")))))))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product","    return term(n)*product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product","    return term(n)*product(n-1, term)","TypeError: unsupported operand type(s) for *: 'int' and 'NoneType'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":258,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    if n == 1:   =>           \r\n        return 1 =>           \r\n    elif n > 0:  =>           \r\n                 =>           \r\n    if n != 0:   <=           \r\n                 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n != 0:\n        return term(n) * product(n-1, term)\n    ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return 1\n    elif n > 0:\n        return term(n) * product(n-1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-NotEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n) * product(n-1, term)","TypeError: unsupported operand type(s) for *: 'int' and 'NoneType'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":259,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n    product =1                        =>           \r\n    for i in range (1,n+1):           =>           \r\n        product=product*term(i)       =>           \r\n    product, k =1,1                   <=           \r\n    while k<=n:                       <=           \r\n        product,k=product*term(n),k+1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    product, k =1,1\n    while k<=n:\n        product,k=product*term(n),k+1\n    return product","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    product =1\n    for i in range (1,n+1):\n        product=product*term(i)\n    return product","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-range), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(ForStatementNode, Children(LeafConstNode(NameExpressionNode-i), Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-range), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))), SingleChild(ReferenceNode(node, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), 0)))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast)))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","27","","# Error: expected","#     6","# but got","#     27","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":260,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n    total = 1                     =>           \r\n    while 1 <= n:                 =>           \r\n        total = total * term(n)   =>           \r\n        n = n-1                   =>           \r\n    return product(n, identity)   =>           \r\n    return combiner(base,product) =>           \r\n    total, k = 1, 1               <=           \r\n    while k <= n:                 <=           \r\n        total = total * k         <=           \r\n        k = k+1                   <=           \r\n    return _______                <=           \r\n    \"*** YOUR CODE HERE ***\"      <=           \r\n                                  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total = total * k\n        k = k+1\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while 1 <= n:\n        total = total * term(n)\n        n = n-1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 1), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":261,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n    i = 1                           =>           \r\n    result = 1                      =>           \r\n    while i <= n:                   =>           \r\n        result *= term(i)           =>           \r\n        i += 1                      =>           \r\n    return result                   =>           \r\n    if n == 1:                      <=           \r\n        return term(1)              <=           \r\n    elif n == 2:                    <=           \r\n        return term(1) * term(2)    <=           \r\n    else:                           <=           \r\n        return product(n - 1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    elif n == 2:\n        return term(1) * term(2)\n    else:\n        return product(n - 1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    result = 1\n    while i <= n:\n        result *= term(i)\n        i += 1\n    return result","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-i), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-result)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-result), SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(NameExpressionNode-n))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Multiply, Children(LeafConstNode(NameExpressionNode-result), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)))), 0), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1))))), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0), 1), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(NameExpressionNode-n)))), SingleChild(ConstNode(SuiteStatementNode, Children(ConstNode(AugmentedAssignStatementNode-Multiply, Children(LeafConstNode(NameExpressionNode-result), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)))), SingleChild(ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-result)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), 0), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), InOrderSort(ast)))))))))))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":262,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    k = n           <=           \r\n    total, k = 0, 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k = n\n    total, k = 0, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"ConstantExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":265,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n            return term(k) * inner(term, k+1) =>           \r\n            return term(k) * inner(k+1)       <=           \r\n\r\n\r\n","before":"def product(n, term, k =1):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def inner (term, k):\n        if k == n:\n            return term (n)\n        else:\n            return term(k) * inner(k+1)\n    return inner (term, k)","after":"def product(n, term, k =1):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def inner (term, k):\n        if k == n:\n            return term (n)\n        else:\n            return term(k) * inner(term, k+1)\n    return inner (term, k)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 1), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in product","    return inner (term, k)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in inner","    return term(k) * inner(k+1)","TypeError: inner() missing 1 required positional argument: 'k'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":269,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return term(n)*product((n-1), term) =>           \r\n                                        =>           \r\n    return term(n)*(product(n-1), term) <=           \r\n                                        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==1:\n        return term(1)\n    return term(n)*(product(n-1), term)\n   ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==1:\n        return term(1)\n    return term(n)*product((n-1), term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ParenthesisExpressionNode, SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0), 0), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0), 1), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0), Children(ConstNode(ArgNode, SingleChild(ConstNode(ParenthesisExpressionNode, SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0))))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))))), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n)*(product(n-1), term)","TypeError: product() missing 1 required positional argument: 'term'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":270,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return 1 * product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return 1 * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"ConstantExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":275,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    x=1     =>           \r\n            <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    result = 1\n\n    while x<=n:\n        result *= term(x)\n        x += 1\n\n    return result","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    result = 1\n    x=1\n    while x<=n:\n        result *= term(x)\n        x += 1\n\n    return result","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-x), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    while x<=n:","UnboundLocalError: local variable 'x' referenced before assignment","","# Error: expected","#     6","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":280,"diff":"\r\nInputObject                                                             SideIndicator\r\n-----------                                                             -------------\r\n    total = 1                                                           =>           \r\n    for i in range(1, n+1):                                             =>           \r\n        a = term(i)                                                     =>           \r\n        total *= a                                                      =>           \r\n    return product(n, identity)                                         =>           \r\n    total = base                                                        =>           \r\n    for i in range(1, n):                                               =>           \r\n        total = combiner(total, term(i))                                =>           \r\n    return total                                                        =>           \r\n    # def summation_using_accumulate(n, term):                          =>           \r\n    # \"\"\"Returns the sum of TERM(1) + ... + TERM(N). The implementation =>           \r\n    # uses accumulate.                                                  =>           \r\n    # >>> summation_using_accumulate(5, square)                         =>           \r\n    # 55                                                                =>           \r\n    # >>> summation_using_accumulate(5, triple)                         =>           \r\n    # 45                                                                =>           \r\n    # >>> from construct_check import check                             =>           \r\n    # >>> check(HW_SOURCE_FILE, 'summation_using_accumulate',           =>           \r\n    # ...       ['Recursion', 'For', 'While'])                          =>           \r\n    # True                                                              =>           \r\n    # \"\"\"                                                               =>           \r\n    # \"*** YOUR CODE HERE ***\"                                          =>           \r\n    # return _______                                                    =>           \r\n                                                                        =>           \r\n    total = 0                                                           <=           \r\n    for i in range(0, n+1):                                             <=           \r\n        total += map(term,i)                                            <=           \r\ndef summation_using_accumulate(n, term):                                <=           \r\n    \"\"\"Returns the sum of TERM(1) + ... + TERM(N). The implementation   <=           \r\n    uses accumulate.                                                    <=           \r\n    >>> summation_using_accumulate(5, square)                           <=           \r\n    55                                                                  <=           \r\n    >>> summation_using_accumulate(5, triple)                           <=           \r\n    45                                                                  <=           \r\n    >>> check(HW_SOURCE_FILE, 'summation_using_accumulate',             <=           \r\n    ...       ['Recursion', 'For', 'While'])                            <=           \r\n    return _______                                                      <=           \r\n    return _______                                                      <=           \r\n    >>> from construct_check import check                               <=           \r\n    True                                                                <=           \r\n    \"*** YOUR CODE HERE ***\"                                            <=           \r\n    \"*** YOUR CODE HERE ***\"                                            <=           \r\n    \"\"\"                                                                 <=           \r\n    \"*** YOUR CODE HERE ***\"                                            <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    for i in range(0, n+1):\n        total += map(term,i)\n    return total\n        \n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    for i in range(1, n+1):\n        a = term(i)\n        total *= a\n    return total\n        \n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-a)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-a), SingleChild(ReferenceNode(node, Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Multiply, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(NameExpressionNode-a)))), 1), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    total += map(term,i)","TypeError: 'int' object is not iterable","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":282,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n        if i > n:  =>           \r\n        if i == n: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i=1):\n        if i == n:\n            return 1\n        return term(i) * helper(i + 1)\n    return helper()\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i=1):\n        if i > n:\n            return 1\n        return term(i) * helper(i + 1)\n    return helper()\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":283,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return 1                            =>           \r\n        return term(n) * product(n-1, term) =>           \r\n        return 0                            <=           \r\n        return term(n) + product(n-1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n < 1:\n        return 0\n    else:\n        return term(n) + product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n < 1:\n        return 1\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":284,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n    total, i = 1,1 =>           \r\n    while i<=n:    =>           \r\n    total, i = 1,0 <=           \r\n    while i<n:     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, i = 1,0\n    while i<n:\n        total *= term(i)\n        i+=1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, i = 1,1\n    while i<=n:\n        total *= term(i)\n        i+=1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(LeafWildcard(\"any\"), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":524,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    i = 1         =>           \r\n    while i <= n: =>           \r\n    i = 0         <=           \r\n    while i < n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 0\n    product = 1\n    while i < n:\n        product = product * term(i)\n        i += 1\n    return product","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    product = 1\n    while i <= n:\n        product = product * term(i)\n        i += 1\n    return product","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"ConstantExpressionNode\")))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(LeafWildcard(\"any\"), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":285,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        return (term(n)*product((n-1),term)) =>           \r\n        return (term(n)*product(n-1))        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    if n==1:\n        return term(n)\n    else:\n        return (term(n)*product(n-1))\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    if n==1:\n        return term(n)\n    else:\n        return (term(n)*product((n-1),term))\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ParenthesisExpressionNode, SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product","    return (term(n)*product(n-1))","TypeError: product() missing 1 required positional argument: 'term'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":286,"diff":"\r\nInputObject                                    SideIndicator\r\n-----------                                    -------------\r\n        return term(n) * product(n-1, term)    =>           \r\n        return term(n) * product(n, term(n-1)) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return term(n) \n    else:\n        return term(n) * product(n, term(n-1))\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return term(n) \n    else:\n        return term(n) * product(n-1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n) * product(n, term(n-1))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n) * product(n, term(n-1))","TypeError: 'int' object is not callable","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":287,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    if n == 0:                            =>           \r\n        return 1                          =>           \r\n        return term(n)*product(n-1, term) =>           \r\n                                          =>           \r\n    else:                                 =>           \r\n    def count(k):                         <=           \r\n        if k == 0:                        <=           \r\n            return                        <=           \r\n        else:                             <=           \r\n            return term(k)*count(k-1)     <=           \r\n    return count(n)                       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def count(k):\n        if k == 0:\n            return \n        else:\n            return term(k)*count(k-1)\n    return count(n)\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return term(n)*product(n-1, term)\n    \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, LeafConstNode(ConstantExpressionNode-1), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(LeafWildcard(\"ReturnStatementNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(FunctionDefinitionNode-count, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(LeafWildcard(\"ReturnStatementNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-count, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(LeafWildcard(\"ReturnStatementNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(LeafWildcard(\"ReturnStatementNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))), 0), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-count, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(LeafWildcard(\"ReturnStatementNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-count, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(LeafWildcard(\"ReturnStatementNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-count, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(LeafWildcard(\"ReturnStatementNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast)))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in product","    return count(n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in count","    return term(k)*count(k-1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in count","    return term(k)*count(k-1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in count","    return term(k)*count(k-1)","TypeError: unsupported operand type(s) for *: 'int' and 'NoneType'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":288,"diff":"\r\nInputObject   SideIndicator\r\n-----------   -------------\r\n    prod = 1; =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    while i <= n:\n    \tprod *= term(i)\n    \ti += 1\n    return prod","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    prod = 1;\n    while i <= n:\n    \tprod *= term(i)\n    \ti += 1\n    return prod","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-prod), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    prod *= term(i)","UnboundLocalError: local variable 'prod' referenced before assignment","","# Error: expected","#     6","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":293,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return product(n - 1, term) * term(n) =>           \r\n        return n * product(n - 1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0: \n        return 1 \n    else: \n        return n * product(n - 1, term)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0: \n        return 1 \n    else: \n        return product(n - 1, term) * term(n)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":294,"diff":"\r\nInputObject                                                          SideIndicator\r\n-----------                                                          -------------\r\n            return f(counter) * product_counter((counter + 1), n, f) =>           \r\n            return f(n) * product_counter((counter + 1), n, f)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def product_counter(counter, n, f):\n        if counter == n:\n            return f(n)\n        else: \n            return f(n) * product_counter((counter + 1), n, f)\n\n    return product_counter(1, n, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def product_counter(counter, n, f):\n        if counter == n:\n            return f(n)\n        else: \n            return f(counter) * product_counter((counter + 1), n, f)\n\n    return product_counter(1, n, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-counter)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","27","","# Error: expected","#     6","# but got","#     27","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":295,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n                                            =>           \r\n        return term(1)                      =>           \r\n        return term(n) * product(n-1, term) =>           \r\n                                            =>           \r\n        return 1                            <=           \r\n        return n * product(n-1, term)       <=           \r\n                                            <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return 1\n    else:\n        return n * product(n-1, term)\n       ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    \n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0)))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":296,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    x = 1                       =>           \r\n    func = lambda y: term(y)    =>           \r\n    track = 1                   =>           \r\n    while x <= n:               =>           \r\n        track = track * func(x) =>           \r\n        x += 1                  =>           \r\n    return track                =>           \r\n                                =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = 1\n    func = lambda y: term(y)\n    track = 1\n    while x <= n:\n    \ttrack = track * func(x)\n    \tx += 1\n    return track\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-x), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-func), SingleChild(ConstNode(LambdaExpressionNode, SingleChild(ConstNode(FunctionDefinitionNode-<lambda$1720>, Children(LeafConstNode(ParameterNode-y), SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-y)))))))))))))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-track), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-x), SingleChild(LeafConstNode(NameExpressionNode-n)))), SingleChild(ConstNode(SuiteStatementNode, Children(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-track), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-track), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-func), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-x)))))))))))), SingleChild(ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-x), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))), 5), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-track))), 6), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":303,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    if n==1:                             =>           \r\n        return term(n)*product(n-1,term) =>           \r\n    if n==0:                             <=           \r\n        return term(n)*term(n-1)         <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==0:\n        return term(n)\n    else:\n        return term(n)*term(n-1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return term(n)\n    else:\n        return term(n)*product(n-1,term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":305,"diff":"\r\nInputObject        SideIndicator\r\n-----------        -------------\r\n    while i < n+1: =>           \r\n    while i != n:  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i != n:\n        total = total * term(i)\n        i +=1\n    return total\n    \"\"\"def helper(i, total):\n        if i<n:\n            return helper(i+1, total*term(i))\n        else:\n            return total\n    helper(1,0)\"\"\"","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i < n+1:\n        total = total * term(i)\n        i +=1\n    return total\n    \"\"\"def helper(i, total):\n        if i<n:\n            return helper(i+1, total*term(i))\n        else:\n            return total\n    helper(1,0)\"\"\"","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThan, Children(ReferenceNode(node, Node(BinaryExpressionNode-NotEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":310,"diff":"\r\nInputObject                                                         SideIndicator\r\n-----------                                                         -------------\r\n    if n == 1:                                                      =>           \r\n        return term(1)                                              =>           \r\n    return term(n)*product(n-1, term)                               =>           \r\n    if n == 0:                                                      =>           \r\n        return 1                                                    =>           \r\n    return product(n, identity)                                     =>           \r\n    if n == 0:                                                      =>           \r\n        return base                                                 =>           \r\n    return combiner(accumulate(combiner, base, n-1, term), term(n)) =>           \r\n    return accumulate(add, 0, n, term)                              =>           \r\n                                                                    =>           \r\n    x = 1                                                           <=           \r\n    def helper_fxn(x, term):                                        <=           \r\n        if x <= n:                                                  <=           \r\n            return term(x) * helper_fxn(x+1, term)                  <=           \r\n        else:                                                       <=           \r\n            return 0                                                <=           \r\n    return _______                                                  <=           \r\n    return _______                                                  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = 1\n    def helper_fxn(x, term):\n        if x <= n:\n            return term(x) * helper_fxn(x+1, term)\n        else:\n            return 0","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(1)\n    return term(n)*product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(FunctionDefinitionNode-helper_fxn, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(FunctionDefinitionNode-helper_fxn, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(FunctionDefinitionNode-helper_fxn, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(FunctionDefinitionNode-helper_fxn, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(FunctionDefinitionNode-helper_fxn, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(FunctionDefinitionNode-helper_fxn, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":311,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    k, total = 1, 1                       =>           \r\n    while k <= n:                         =>           \r\n        total, k = total * term(k), k + 1 =>           \r\n    return total                          =>           \r\n    return n * product(n - 1, identity)   =>           \r\n    return Y(________)  # Replace         =>           \r\n    return _______                        <=           \r\n    return Y(________)  # Replace         <=           \r\n    \"*** YOUR CODE HERE ***\"              <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, total = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(NameExpressionNode-total)))), SingleChild(ConstNode(TupleExpressionNode-False, Children(LeafConstNode(ConstantExpressionNode-1), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(NameExpressionNode-n)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(NameExpressionNode-k)))), SingleChild(ConstNode(TupleExpressionNode-False, Children(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-k))))))))), SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-total)))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":312,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n        product=product*term(k) =>           \r\n        product=product*term(n) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, product = 1, 1\n    while k<=n:\n        product=product*term(n)\n        k+=1\n    return product\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, product = 1, 1\n    while k<=n:\n        product=product*term(k)\n        k+=1\n    return product\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","27","","# Error: expected","#     6","# but got","#     27","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":406,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    return k                    =>           \r\n    return product(n, identity) =>           \r\n    return x                    <=           \r\n    return _______              <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, x = 1, 1\n    while x <= n:\n        k, x = k * term(x), x + 1\n    return x\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, x = 1, 1\n    while x <= n:\n        k, x = k * term(x), x + 1\n    return k\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Skip(Target(LeafWildcard(\"NameExpressionNode\")))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","4","","# Error: expected","#     6","# but got","#     4","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":314,"diff":"\r\nInputObject                        SideIndicator\r\n-----------                        -------------\r\n            return term(k) * total =>           \r\n            return k * total       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper(k,total):\n        if k == n:\n            return k * total\n        else:\n            total = total * term(k)\n        return helper(k+1,total)\n    return helper(1,1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper(k,total):\n        if k == n:\n            return term(k) * total\n        else:\n            total = total * term(k)\n        return helper(k+1,total)\n    return helper(1,1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","12","","# Error: expected","#     36","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":315,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n        return term(n) * product((n-1), term) =>           \r\n        return term(n) * term(n-1)            <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * term(n-1)\n\n\n    \"\"\" without recursion\n    i = 1\n    total = 1\n    while i <= n:\n        total = total * term(i)\n        i = i+1\n    return total\n    \"\"\"","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product((n-1), term)\n\n\n    \"\"\" without recursion\n    i = 1\n    total = 1\n    while i <= n:\n        total = total * term(i)\n        i = i+1\n    return total\n    \"\"\"","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ParenthesisExpressionNode, SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":316,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n    if n==1:                             =>           \r\n        return term(1)                   =>           \r\n        return product(n-1,term)*term(n) =>           \r\n    else:                                =>           \r\n    product=1                            <=           \r\n    while n>=1:                          <=           \r\n        a=term(n)                        <=           \r\n        product=product*a                <=           \r\n    return product                       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    product=1\n    while n>=1:\n        a=term(n)\n        product=product*a\n    return product","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==1:\n        return term(1)\n    else:\n        return product(n-1,term)*term(n)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))))))))))), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast)))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":318,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    if term == identity:         =>           \r\n        while n > 0:             =>           \r\n            total = total * n    =>           \r\n            n -= 1               =>           \r\n        return total             =>           \r\n    if term == square:           =>           \r\n        while n > 0:             =>           \r\n            total = total * n**2 =>           \r\n            n -= 1               =>           \r\n        return total             =>           \r\n                                 =>           \r\n                                 =>           \r\n    while n > 0:                 <=           \r\n        total = total * n        <=           \r\n        n -= 1                   <=           \r\n    return total                 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while n > 0:\n        total = total * n\n        n -= 1\n\n    return total \n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    if term == identity:\n        while n > 0:\n            total = total * n\n            n -= 1\n\n        return total \n\n    if term == square:\n        while n > 0:\n            total = total * n**2\n            n -= 1\n\n        return total \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-term), SingleChild(LeafConstNode(NameExpressionNode-identity)))), SingleChild(ConstNode(SuiteStatementNode, Children(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0), SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-total))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-term), SingleChild(LeafConstNode(NameExpressionNode-square)))), SingleChild(ConstNode(SuiteStatementNode, Children(ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-GreaterThan, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, Children(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(BinaryExpressionNode-Power, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-2)))))))))), SingleChild(ConstNode(AugmentedAssignStatementNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))), SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0))))))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":320,"diff":"\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n        i+=1 =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i=1;s=1\n    while i<=n:\n        s=s*term(i)\n    return s","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i=1;s=1\n    while i<=n:\n        s=s*term(i)\n        i+=1\n    return s","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":444,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n        i += 1 =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    final = 1\n    i = 1\n    while i <= n:\n        final = final * term(i)\n    return final","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    final = 1\n    i = 1\n    while i <= n:\n        final = final * term(i)\n        i += 1\n    return final","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":323,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n            total = total * term(i)   =>           \r\n            result = result * term(i) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else: \n        total = 1\n        for i in range(1, n+1):\n            result = result * term(i)\n        return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else: \n        total = 1\n        for i in range(1, n+1):\n            total = total * term(i)\n        return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 38, in product","    result = result * term(i)","UnboundLocalError: local variable 'result' referenced before assignment","","# Error: expected","#     6","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":324,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n    a = 1      =>           \r\n        a += 1 =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if a == n:\n        return term(n)\n    else:\n        return term(n) * product(n - 1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    a = 1\n    if a == n:\n        return term(n)\n    else:\n        a += 1\n        return term(n) * product(n - 1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-a), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-a), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    if a == n:","NameError: name 'a' is not defined","","# Error: expected","#     6","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":330,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    if n == 1:                              =>           \r\n        return term(1)                      =>           \r\n    else:                                   =>           \r\n        return term(n) * product(n-1, term) =>           \r\n    return term(n) * product(n-1, term)     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    return term(n) * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n    \treturn term(1)\n    else: \n    \treturn term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n-1, term)","RecursionError: maximum recursion depth exceeded","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":331,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    for i in range(1, n+1): =>           \r\n    for i in range(0, n):   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    for i in range(0, n):\n        total = total * term(i)\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    for i in range(1, n+1):\n        total = total * term(i)\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":423,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    for i in range(1, n + 1): =>           \r\n    for i in range(0, n):     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    x = 1\n    for i in range(0, n):\n        x = x * term(i)\n    return x\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n\n    x = 1\n    for i in range(1, n + 1):\n        x = x * term(i)\n    return x\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":494,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    for i in range(1,n+1): =>           \r\n    for i in range(0,n):   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    product=1\n    for i in range(0,n):\n        product=product*term(i)\n    return product","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    product=1\n    for i in range(1,n+1):\n        product=product*term(i)\n    return product","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":333,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        i = term (k)      =>           \r\n        total = total * i =>           \r\n    k = term(k)           <=           \r\n        total = total * k <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 1\n    k = term(k)\n    total = 1\n    while k <= n:\n        total = total * k\n        k += 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 1\n    total = 1\n    while k <= n:\n        i = term (k)\n        total = total * i\n        k += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-i), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-k))))))))), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":334,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n            return term(i)*helper(i-1) =>           \r\n    current = term(n)                  <=           \r\n            return current*term(i-1)   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    current = term(n)\n    def helper(i):\n        if i == 1:\n            return term(1)\n        else:\n            return current*term(i-1)\n    return helper(n)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(i):\n        if i == 1:\n            return term(1)\n        else:\n            return term(i)*helper(i-1)\n    return helper(n)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(FunctionDefinitionNode-helper, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-helper)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":335,"diff":"\r\nInputObject                                            SideIndicator\r\n-----------                                            -------------\r\n            return term(k) * helper_product(k+1, term) =>           \r\n    if n==1:                                           =>           \r\n        return 1                                       =>           \r\n        return helper_product(1, term)                 =>           \r\n    else:                                              =>           \r\n                                                       =>           \r\n            return term(1) * helper_product(k+1, term) <=           \r\n    return helper_product(1, term)                     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper_product(k, term):\n        if k>n:\n            return 1\n        else:\n            return term(1) * helper_product(k+1, term)\n    return helper_product(1, term)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper_product(k, term):\n        if k>n:\n            return 1\n        else:\n            return term(k) * helper_product(k+1, term)\n    if n==1:\n        return 1\n\n    else:\n        return helper_product(1, term)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-helper_product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0)))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-helper_product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-helper_product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-helper_product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":336,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        return 1                          =>           \r\n        return term(n)*product(n-1, term) =>           \r\n        return 0                          <=           \r\n    elif n==1:                            <=           \r\n        return n                          <=           \r\n        return n*product(n-1, term)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==0:\n        return 0\n    elif n==1:\n        return n\n    else:\n        return n*product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==0:\n        return 1\n    else:\n        return term(n)*product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":339,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    if n == 1:         =>           \r\n        return term(1) =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def product_term(x, num):\n        if num == 1:\n            return x\n        else:\n            return product_term(x*term(num), num-1)\n    #return product_term(1, n)\n    return product(n-1, term) * term (n)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def product_term(x, num):\n        if num == 1:\n            return x\n        else:\n            return product_term(x*term(num), num-1)\n    #return product_term(1, n)\n    if n == 1:\n        return term(1)\n    return product(n-1, term) * term (n)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-product_term, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    return product(n-1, term) * term (n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    return product(n-1, term) * term (n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    return product(n-1, term) * term (n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    return product(n-1, term) * term (n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    return product(n-1, term) * term (n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    return product(n-1, term) * term (n)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    return product(n-1, term) * term (n)","RecursionError: maximum recursion depth exceeded","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":340,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    if n == 1:                            =>           \r\n        return term(n)                    =>           \r\n        return term(n)*product(n-1, term) =>           \r\n    else:                                 =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n)*product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))))))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":349,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    if n == 1:                             =>           \r\n        return term(n)                     =>           \r\n    else:                                  =>           \r\n        return term(n)*product(n-1, term)  =>           \r\n    #if n == 1:                            <=           \r\n    #    return term(n)                    <=           \r\n    #else:                                 <=           \r\n    #    return term(n)*product(n-1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    #i, total = 1, 1\n    #while i <= n:\n    #    total = total * term(i)\n    #    i += 1\n    #return total\n    #if n == 1:\n    #    return term(n)\n    #else: \n    #    return term(n)*product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    #i, total = 1, 1\n    #while i <= n:\n    #    total = total * term(i)\n    #    i += 1\n    #return total\n    if n == 1:\n        return term(n)\n    else: \n        return term(n)*product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))))))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":341,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    if n > 0:                               =>           \r\n        return term(n) * product(n-1, term) =>           \r\n        return 1                            =>           \r\n    else:                                   =>           \r\n    return term(n) * product(n-1, term)     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    return term(n) * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n > 0:\n        return term(n) * product(n-1, term)\n    else:\n        return 1 ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-GreaterThan, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n-1, term)","RecursionError: maximum recursion depth exceeded","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":347,"diff":"\r\nInputObject              SideIndicator\r\n-----------              -------------\r\n    i = 1                =>           \r\n    while i<=n:          =>           \r\n    for i in range(1,n): <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1;\n    for i in range(1,n):\n        total = total*term(i)\n        i+=1\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1;\n    i = 1\n    while i<=n:\n        total = total*term(i)\n        i+=1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(ReferenceNode(node, Node(ForStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), 0), SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0)))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(NameExpressionNode-n)))), SingleChild(ReferenceNode(node, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0)))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Target(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":352,"diff":"\r\nInputObject               SideIndicator\r\n-----------               -------------\r\n        x = term(counter) =>           \r\n        x = term(n)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    counter=n\n    listen = []\n    while counter>0:\n        counter-=1\n        x = term(n)\n        listen.append(x)\n    product = 1\n    for x in listen:\n        product *= x\n    return product","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    counter=n\n    listen = []\n    while counter>0:\n        x = term(counter)\n        listen.append(x)\n        counter-=1\n    product = 1\n    for x in listen:\n        product *= x\n    return product","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(Node(MemberExpressionNode-append, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(Node(MemberExpressionNode-append, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-counter)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Subtract, Children(LeafConstNode(NameExpressionNode-counter), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 2), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(Node(MemberExpressionNode-append, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","27","","# Error: expected","#     6","# but got","#     27","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":355,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n    if term == identity:                     =>           \r\n        if n == 1:                           =>           \r\n            return 1                         =>           \r\n        else:                                =>           \r\n            return n * product(n-1, term)    =>           \r\n    elif term == square:                     =>           \r\n        if n == 1:                           =>           \r\n            return 1                         =>           \r\n        else:                                =>           \r\n            return n**2 * product(n-1, term) =>           \r\n                                             =>           \r\n    if n == 1:                               <=           \r\n        return 1                             <=           \r\n        return n * product(n-1, term)        <=           \r\n    else:                                    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return 1\n    else:\n        return n * product(n-1, term)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if term == identity:\n        if n == 1:\n            return 1\n        else:\n            return n * product(n-1, term)\n    elif term == square:\n        if n == 1:\n            return 1\n        else:\n            return n**2 * product(n-1, term)\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Power, Children(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-2)))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-term), SingleChild(LeafConstNode(NameExpressionNode-identity)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-n), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term)))))))))))))))))))))), SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-term), SingleChild(LeafConstNode(NameExpressionNode-square)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(BinaryExpressionNode-Power, Children(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-2)))), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":356,"diff":"\r\nInputObject                                       SideIndicator\r\n-----------                                       -------------\r\n        return mul(term(n), product(n - 1, term)) =>           \r\n        return mul(n, product(n - 1, term))       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return 1\n    else:\n        return mul(n, product(n - 1, term))","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return 1\n    else:\n        return mul(term(n), product(n - 1, term))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":362,"diff":"\r\nInputObject                        SideIndicator\r\n-----------                        -------------\r\n    return t                       =>           \r\n    return _______                 =>           \r\n    \"*** YOUR CODE HERE ***\"       =>           \r\n        return t                   <=           \r\n    return product(n, lambda x: x) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    t, i = 1, 1\n    while i <= n:\n        t *= term(i)\n        i += 1\n        return t","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    t, i = 1, 1\n    while i <= n:\n        t *= term(i)\n        i += 1\n    return t","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ReferenceNode(node, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), SingleChild(ConstNode(SuiteStatementNode, Children(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":366,"diff":"\r\nInputObject                                      SideIndicator\r\n-----------                                      -------------\r\n            return term(count)*count_up(count-1) =>           \r\n            return term(count)*term(count-1)     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    def count_up(count):\n        if count == 1:\n            return 1\n        else:\n            return term(count)*term(count-1)\n    return count_up(n)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    def count_up(count):\n        if count == 1:\n            return 1\n        else:\n            return term(count)*count_up(count-1)\n    return count_up(n)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-count_up)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":369,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n        p *= term(i) =>           \r\n                     =>           \r\n        p *= term(p) <=           \r\n                     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    p = 1\n    for i in range(1, n + 1):\n        p *= term(p)\n    return p\n   ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    p = 1\n    for i in range(1, n + 1):\n        p *= term(i)\n    return p","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":371,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    total, k = 1, 1 =>           \r\n    total, k = 1    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1\n    while k <= n:\n    \ttotal = total * term (k)\n    \tk += 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n    \ttotal = total * term (k)\n    \tk += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(TupleExpressionNode-False, Children(LeafConstNode(ConstantExpressionNode-1), SingleChild(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    total, k = 1","TypeError: 'int' object is not iterable","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":373,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n    if n == 1:                              =>           \r\n        return term(n)                      =>           \r\n        return term(n) * product(n-1, term) =>           \r\n    if n == 1:                              =>           \r\n        return 1                            =>           \r\n    else:                                   =>           \r\n        return n * factorial(n-1)           =>           \r\n    else:                                   =>           \r\n    return _______                          <=           \r\n    \"*** YOUR CODE HERE ***\"                <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))))))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":375,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    elif n == 0: =>           \r\n        return 1 =>           \r\n                 =>           \r\n                 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n >= 1:\n        return term(n) * product(n-1, term)\n        \n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n >= 1:\n        return term(n) * product(n-1, term)\n    elif n == 0:\n        return 1\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-0)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    return term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    return term(n) * product(n-1, term)","TypeError: unsupported operand type(s) for *: 'int' and 'NoneType'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":376,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n        _sum_ = _sum_ * term(x)  =>           \r\n        _sum_, = _sum_ * term(x) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = 1\n    _sum_ = 1\n    while x<=n:\n        _sum_, = _sum_ * term(x)\n        x += 1\n    return _sum_\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = 1\n    _sum_ = 1\n    while x<=n:\n        _sum_ = _sum_ * term(x)\n        x += 1\n    return _sum_\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(Node(TupleExpressionNode-False, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    _sum_, = _sum_ * term(x)","TypeError: 'int' object is not iterable","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":379,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        times, k = times * term(k), k - 1 =>           \r\n    return product(n, identity)           =>           \r\n        times, k = times(k), k - 1        <=           \r\n    return _______                        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    # k, times = 1, 1\n    # while k <= n:\n    #     times, k = times * term(k), k + 1\n    # return times\n\n    k, times = n, 1\n    while k > 0:\n        times, k = times(k), k - 1\n    return times","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    # k, times = 1, 1\n    # while k <= n:\n    #     times, k = times * term(k), k + 1\n    # return times\n\n    k, times = n, 1\n    while k > 0:\n        times, k = times * term(k), k - 1\n    return times","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-times), SingleChild(ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)))), 0), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    times, k = times(k), k - 1","TypeError: 'int' object is not callable","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":380,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n    def product_helper(i):            =>           \r\n    return product_helper(1)          =>           \r\n        return term(n)                <=           \r\n        return term(n) * product(n-1) <=           \r\n    \"\"\"def product_helper(i):         <=           \r\n    return product_helper(1)\"\"\"       <=           \r\n    if n==0:                          <=           \r\n    else:                             <=           \r\n                                      <=           \r\n                                      <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n==0:\n        return term(n)\n    else:\n        return term(n) * product(n-1)\n\n\n    \"\"\"def product_helper(i):\n        if i==n:\n            return term(i)\n        else:\n            return term(i) * product_helper(i+1)\n    return product_helper(1)\"\"\"","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def product_helper(i):\n        if i==n:\n            return term(i)\n        else:\n            return term(i) * product_helper(i+1)\n    return product_helper(1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product_helper)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-i), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(FunctionDefinitionNode-product_helper, Children(LeafConstNode(ParameterNode-i), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(NameExpressionNode-n)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i))))))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i)))))), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product_helper), SingleChild(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-i), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)))))))))))))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product_helper), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product","    return term(n) * product(n-1)","TypeError: product() missing 1 required positional argument: 'term'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":385,"diff":"\r\nInputObject                         SideIndicator\r\n-----------                         -------------\r\n    prod = 1                        =>           \r\n        prod = term(i) * prod       =>           \r\n    return prod                     =>           \r\n    return x                        =>           \r\n    product = 1                     <=           \r\n        product = term(i) * product <=           \r\n    return product                  <=           \r\n    return                          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    product = 1\n\n    while i <= n:\n        product = term(i) * product\n        i += 1\n\n    return product\n\ndef identity(x):\n    return\n\ndef square(x):\n    return x * x","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    prod = 1\n\n    while i <= n:\n        prod = term(i) * prod\n        i += 1\n\n    return prod\n\ndef identity(x):\n    return x\n\ndef square(x):\n    return x * x","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-prod)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-prod)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-prod)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-prod)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, LeafConstNode(NameExpressionNode-x), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(LeafWildcard(\"ReturnStatementNode\"))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product","    product = term(i) * product","TypeError: unsupported operand type(s) for *: 'NoneType' and 'int'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":386,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n    while x <= n: =>           \r\n    while x != n: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = 1\n    total = 1    \n    while x != n:\n        total = term(x) * total \n        x = x + 1  \n    return total  ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    x = 1\n    total = 1    \n    while x <= n:\n        total = term(x) * total \n        x = x + 1  \n    return total  ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-NotEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":387,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    if n <= 1:                          =>           \r\n        return term(n)                  =>           \r\n    return term(n) * product(n-1, term) =>           \r\n                                        =>           \r\n    return Y(________)  # Replace       =>           \r\n    return Y(________)  # Replace       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n <= 1:\n        return term(n)\n\n    return term(n) * product(n-1, term)\n   ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term)))))))))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":389,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    total, k = 1, 1                       =>           \r\n        total, k = total * term(k), k + 1 =>           \r\ndef identity(k):                          <=           \r\n    total, k = 0, 1                       <=           \r\n        total, k = total + term(k), k + 1 <=           \r\ndef square(x):                            <=           \r\n    total, k = 0, 1                       <=           \r\n    while k<= n:                          <=           \r\n        total, k = total + k**2, k + 1    <=           \r\n    return total                          <=           \r\n                                          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\ndef identity(k):\n    total, k = 0, 1\n    while k <= n:\n        total, k = total + term(k), k + 1\n    return total\n\ndef square(x):\n    total, k = 0, 1\n    while k<= n:\n        total, k = total + k**2, k + 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(FunctionDefinitionNode-identity, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(FunctionDefinitionNode-square, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0)), Selected(\\x => Match(x, Node(PythonAstNode, TChild(Target(Node(SuiteStatementNode, TChildren(Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChildren(Node(FunctionDefinitionNode-identity, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(FunctionDefinitionNode-square, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"ConstantExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))))), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(FunctionDefinitionNode-product, Children(ReferenceNode(node, Node(FunctionDefinitionNode-product, TChildren(Target(LeafWildcard(\"ParameterNode\")), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0), Children(ReferenceNode(node, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(Target(LeafWildcard(\"ParameterNode\")), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0), SingleChild(ConstNode(SuiteStatementNode, Children(ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), 0), Children(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), Children(ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(NameExpressionNode-n)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(NameExpressionNode-k)))), SingleChild(ConstNode(TupleExpressionNode-False, Children(ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)))), SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))))), SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)))))))))), 0), Selected(\\x => Match(x, Node(PythonAstNode, TChild(Target(Node(SuiteStatementNode, TChildren(Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChildren(Node(FunctionDefinitionNode-identity, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(FunctionDefinitionNode-square, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChildren(Target(Node(FunctionDefinitionNode-identity, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(FunctionDefinitionNode-square, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0)), Selected(\\x => Match(x, Node(PythonAstNode, TChild(Target(Node(SuiteStatementNode, TChildren(Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChildren(Node(FunctionDefinitionNode-identity, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(FunctionDefinitionNode-square, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChildren(Node(FunctionDefinitionNode-identity, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Target(Node(FunctionDefinitionNode-square, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(PythonAstNode, TChild(Target(Node(SuiteStatementNode, TChildren(Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChildren(Node(FunctionDefinitionNode-identity, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(FunctionDefinitionNode-square, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Power, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":390,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    if (n == 1):                          =>           \r\n        return term(n)                    =>           \r\n        return term(n)*product(n-1, term) =>           \r\n                                          =>           \r\n    else:                                 =>           \r\n    x = 1                                 <=           \r\n    product = 1                           <=           \r\n    x = term(x)                           <=           \r\n    while n > 0:                          <=           \r\n        product = product*x               <=           \r\n        x += 1                            <=           \r\n        n -= 1                            <=           \r\n    if n == 0:                            <=           \r\n        return product                    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x = 1\n    product = 1 \n    x = term(x) \n    while n > 0: \n        product = product*x \n        x += 1 \n        n -= 1 \n    if n == 0: \n        return product    \n            \n            \n        \n        \n         \n         ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if (n == 1):\n        return term(n)\n    else:\n        return term(n)*product(n-1, term)\n              \n            \n            \n        \n        \n         \n         ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AugmentedAssignStatementNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term)))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term)))))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(ParenthesisExpressionNode, SingleChild(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))))))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), SingleChild(ConstNode(CallExpressionNode, Children(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast)))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":391,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    if n == 1:                            =>           \r\n        return term(1)                    =>           \r\n    else:                                 =>           \r\n        return term(n)*product(n-1, term) =>           \r\n    n > 0                                 <=           \r\n    x = product(n-1, term)                <=           \r\n    return term(n)*x                      <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    n > 0\n    x = product(n-1, term)\n    return term(n)*x","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:    \n        return term(n)*product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    x = product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    x = product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    x = product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    x = product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    x = product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    x = product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    n > 0","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":393,"diff":"\r\nInputObject                      SideIndicator\r\n-----------                      -------------\r\n    result = 1                   =>           \r\n    for i in range(1, n + 1):    =>           \r\n        result *= term(i)        =>           \r\n    return result                =>           \r\n    re = 1                       <=           \r\n    for i in range(1, n + 1, 1): <=           \r\n        ret *= term(i)           <=           \r\n    return ret                   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    re = 1\n    for i in range(1, n + 1, 1):\n        ret *= term(i)\n    return ret","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    result = 1\n    for i in range(1, n + 1):\n        result *= term(i)\n    return result","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-result)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-result)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-result)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    ret *= term(i)","UnboundLocalError: local variable 'ret' referenced before assignment","","# Error: expected","#     6","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":395,"diff":"\r\nInputObject SideIndicator\r\n----------- -------------\r\n    acc = 1 =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    for i in range(n):\n        acc = acc*term(i+1)\n    return acc\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    acc = 1\n    for i in range(n):\n        acc = acc*term(i+1)\n    return acc\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-acc), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    acc = acc*term(i+1)","UnboundLocalError: local variable 'acc' referenced before assignment","","# Error: expected","#     6","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":397,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    total, k = 1, 1                     =>           \r\n    while k<=n:                         =>           \r\n        total, k = total * term(k), k+1 =>           \r\n    return total                        =>           \r\n    # x = identity(n-1)                 =>           \r\n    # k = n * x                         =>           \r\n    # x -= 1                            =>           \r\n    # if x == 0:                        =>           \r\n    #     return                        =>           \r\n    identity(n)                         <=           \r\n    x = n                               <=           \r\n    x -= 1                              <=           \r\n    return n*x                          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    identity(n)\n    x = n\n    x -= 1\n    return n*x\n   ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k<=n:\n        total, k = total * term(k), k+1\n    return total\n    # x = identity(n-1)\n    # k = n * x\n    # x -= 1\n    # if x == 0:\n    #     return\n   ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(TupleExpressionNode-False, Children(LeafConstNode(ConstantExpressionNode-1), SingleChild(LeafConstNode(ConstantExpressionNode-1))))), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(NameExpressionNode-k)))), SingleChild(ConstNode(TupleExpressionNode-False, Children(LeafConstNode(ConstantExpressionNode-1), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-k)))))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(NameExpressionNode-n)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(NameExpressionNode-k)))), SingleChild(ConstNode(TupleExpressionNode-False, Children(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-k))))))))), SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Target(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":399,"diff":"\r\nInputObject                                      SideIndicator\r\n-----------                                      -------------\r\n        return product(n-1,term) * term(n)       =>           \r\n                                                 =>           \r\n                                                 =>           \r\n    return                                       =>           \r\n    else:                                        =>           \r\n                                                 =>           \r\n    return product(term(increment(n-2)))*term(n) <=           \r\n    return _______                               <=           \r\n    \"*** YOUR CODE HERE ***\"                     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    return product(term(increment(n-2)))*term(n)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return product(n-1,term) * term(n)\n\n    ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0), 1), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ReferenceNode(node, Node(IfStatementNode, TChild(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast)))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    return product(term(increment(n-2)))*term(n)","TypeError: product() missing 1 required positional argument: 'term'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":400,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    if n == 1:   =>           \r\n        return 1 =>           \r\n    if n == 0:   <=           \r\n        return   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 0:\n        return\n    return term(n) * product(n - 1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return 1\n    return term(n) * product(n - 1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, LeafConstNode(ConstantExpressionNode-1), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(LeafWildcard(\"ReturnStatementNode\"))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n) * product(n - 1, term)","TypeError: unsupported operand type(s) for *: 'int' and 'NoneType'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":403,"diff":"\r\nInputObject                  SideIndicator\r\n-----------                  -------------\r\n                             =>           \r\ndef product(n,term):         <=           \r\n    \"*** YOUR CODE HERE ***\" <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\ndef product(n,term):\n    k,total = 1, 1\n    while k<=n:\n        total,k = total * term (k), k+1\n    return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k,total = 1, 1\n    while k<=n:\n        total,k = total * term (k), k+1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0)), Selected(\\x => Match(x, Node(PythonAstNode, TChild(Target(Node(SuiteStatementNode, TChildren(Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ExpressionStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    ))), 0), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","","-- No doctests found for product --","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":404,"diff":"\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n        n-=1 =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while n>0:\n        total *= term(n)\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    while n>0:\n        total *= term(n)\n        n-=1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":405,"diff":"\r\nInputObject                                                    SideIndicator\r\n-----------                                                    -------------\r\n    while n >= 1:                                              =>           \r\n        total = term_output(n) * total                         =>           \r\n        n-=1                                                   =>           \r\n                                                               =>           \r\n        return product(n-1, term_output(n-1)) * term_output()  =>           \r\n    total = 1                                                  =>           \r\n    return total                                               =>           \r\n                                                               =>           \r\n        return product(n-1, term_output(n-1)) * term_output(n) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def term_output(n):\n        return term(n)\n\n\n    if n > 1:\n        return\n    else:\n        return product(n-1, term_output(n-1)) * term_output(n)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def term_output(n):\n        return term(n)\n\n    total = 1\n    while n >= 1:\n        total = term_output(n) * total\n        n-=1\n    \n    return total\n\n\n    if n > 1:\n        return\n    else:\n        return product(n-1, term_output(n-1)) * term_output()\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-term_output, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(LeafWildcard(\"ReturnStatementNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, Children(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term_output), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), SingleChild(LeafConstNode(NameExpressionNode-total))))))), SingleChild(ConstNode(AugmentedAssignStatementNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-term_output, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(LeafWildcard(\"ReturnStatementNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(FunctionDefinitionNode-term_output, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(LeafWildcard(\"ReturnStatementNode\")))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":408,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    for i in range(1, n+1): =>           \r\n    for i in range(n):      <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    p = 1\n    for i in range(n):\n        p = p * term(i)\n    return p        ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    p = 1\n    for i in range(1, n+1):\n        p = p * term(i)\n    return p        ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))), 1), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":410,"diff":"\r\nInputObject                                           SideIndicator\r\n-----------                                           -------------\r\n        product_value = product_value * term(term_no) =>           \r\n        product_value = product_value * term(n)       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    term_no = 1\n    product_value = 1\n    while term_no <= n:\n        product_value = product_value * term(n)\n        term_no += 1\n    return product_value","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    term_no = 1\n    product_value = 1\n    while term_no <= n:\n        product_value = product_value * term(term_no)\n        term_no += 1\n    return product_value","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term_no)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","27","","# Error: expected","#     6","# but got","#     27","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":411,"diff":"\r\nInputObject                                    SideIndicator\r\n-----------                                    -------------\r\n            i+=1                               =>           \r\n            return result * product_counter(i) =>           \r\n            return result * product_counter()  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    def product_counter(i):\n        result = 0\n        if i == n:\n            return term(n)\n        else:\n            result += term(i)\n            return result * product_counter()\n    return product_counter(i)\n    # i = 1\n    # while i < n:\n    #     term(i)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    def product_counter(i):\n        result = 0\n        if i == n:\n            return term(n)\n        else:\n            result += term(i)\n            i+=1\n            return result * product_counter(i)\n    return product_counter(i)\n    # i = 1\n    # while i < n:\n    #     term(i)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i))), 1), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 38, in product","    return product_counter(i)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product_counter","    return result * product_counter()","TypeError: product_counter() missing 1 required positional argument: 'i'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":412,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    while n >= i:                      =>           \r\n    # return ________                  =>           \r\n    while n > 0:                       =>           \r\n        return (product(n -  1, term)) =>           \r\n    while n > i:                       <=           \r\n    return _______                     <=           \r\n                                       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    i = 1\n    while n > i:\n        total *= term(i)\n        #n = n - 1\n        i = i + 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total = 1\n    i = 1\n    while n >= i:\n        total *= term(i)\n        #n = n - 1\n        i = i + 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":413,"diff":"","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    a = 1\n    final = 1\n    while a <= n:\n        a += 1\n        final *= term(a)\n    return final","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    a = 1\n    final = 1\n    while a <= n:\n        final *= term(a)\n        a += 1\n    return final","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-a), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","24","","# Error: expected","#     6","# but got","#     24","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":414,"diff":"\r\nInputObject                            SideIndicator\r\n-----------                            -------------\r\n    k, product=1,1                     =>           \r\n        product,k=product*term(k), k+1 =>           \r\n    k, product=1,0                     <=           \r\n        product,k=product*term(n), k+1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k, product=1,0\n    while k<=n:\n        product,k=product*term(n), k+1\n    return product","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k, product=1,1\n    while k<=n:\n        product,k=product*term(k), k+1\n    return product","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":416,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    return term(n) * product(n-1, term) =>           \r\n    product = term(n)                   <=           \r\n    return product * product(n-1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    product = term(n)\n    return product * product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 1\n    return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0)))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return product * product(n-1, term)","TypeError: 'int' object is not callable","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":418,"diff":"\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n        if x>n:                      =>           \r\n            return 1                 =>           \r\n        return term(x)*function(x+1) =>           \r\n    return product(n,identity)       =>           \r\n    n+=1                             =>           \r\n    def function(x):                 =>           \r\n        def function_2(n):           =>           \r\n            if n==0:                 =>           \r\n                return               =>           \r\n            term(n)                  =>           \r\n            return function_2(n-1)   =>           \r\n        return function_2            =>           \r\n    return function                  =>           \r\n                                     =>           \r\n        if x<=n:                     <=           \r\n            term(x)*term(x+1)        <=           \r\n    return _______                   <=           \r\n    \"*** YOUR CODE HERE ***\"         <=           \r\n    \"*** YOUR CODE HERE ***\"         <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def function(x):\n        if x<=n:\n            term(x)*term(x+1)\n    return function(1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def function(x):\n        if x>n:\n            return 1\n        return term(x)*function(x+1)\n    return function(1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-GreaterThan, Children(LeafConstNode(NameExpressionNode-x), SingleChild(LeafConstNode(NameExpressionNode-n)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))), 0), Selected(\\x => Match(x, Node(FunctionDefinitionNode-function, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-function)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), 0)))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-function, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), 0), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-function, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":419,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n    if n == 1:                          =>           \r\n        return term(n)                  =>           \r\n    return term(n) * product(n-1, term) =>           \r\n    return product(n, term)             =>           \r\n    if n == term:                       <=           \r\n        return term                     <=           \r\n    return term * product(n, term+1)    <=           \r\n    return product(n, 2)                <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == term:\n        return term\n    return term * product(n, term+1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), 0), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Subtract, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term * product(n, term+1)","TypeError: unsupported operand type(s) for +: 'function' and 'int'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":420,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        total = total * function(index)     =>           \r\n    return product(n, identity)             =>           \r\n    index = 1                               =>           \r\n    while index <= n:                       =>           \r\n        total = combiner(base, term(index)) =>           \r\n        index += 1                          =>           \r\n    return total                            =>           \r\n        total = total * function(n)         <=           \r\n    return _______                          <=           \r\n    \"*** YOUR CODE HERE ***\"                <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def function(n):\n        return term(n)\n    index, total = 1, 1\n    while index <= n:\n        total = total * function(n)\n        index += 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def function(n):\n        return term(n)\n    index, total = 1, 1\n    while index <= n:\n        total = total * function(index)\n        index += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-index)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","27","","# Error: expected","#     6","# but got","#     27","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":421,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    total, k = 1,1                        =>           \r\n    while k <= n:                         =>           \r\n        total, k = total * term(k), k + 1 =>           \r\n    return total                          =>           \r\n    while product(n,term):                <=           \r\n        result = 1                        <=           \r\n        for i in range(1, n + 1):         <=           \r\n            result *= term(i)             <=           \r\n    while product(n,square):              <=           \r\n        result = 1                        <=           \r\n        for i in range(1, n + 1):         <=           \r\n            result *= result * term(i)    <=           \r\n    return result                         <=           \r\n    return result                         <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    while product(n,term):\n        result = 1\n        for i in range(1, n + 1):\n            result *= term(i)\n    return result\n    while product(n,square):\n        result = 1 \n        for i in range(1, n + 1):\n            result *= result * term(i)\n    return result        ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1,1\n    while k <= n:\n        total, k = total * term(k), k + 1\n    return total         ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(NameExpressionNode-k))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), 0)), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 1), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(TupleExpressionNode-False, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(NameExpressionNode-k)))), SingleChild(ConstNode(TupleExpressionNode-False, Children(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)))))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(WhileStatementNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(WhileStatementNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(WhileStatementNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(WhileStatementNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))), 0), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(WhileStatementNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(WhileStatementNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(WhileStatementNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChildren(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(WhileStatementNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(WhileStatementNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-k), SingleChild(ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ForStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(NameExpressionNode-k))))), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(TupleExpressionNode-False, Children(ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0), SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(NameExpressionNode-k)))), SingleChild(ConstNode(TupleExpressionNode-False, Children(ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0), SingleChild(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast)))))))))))))))))))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    while product(n,term):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    while product(n,term):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    while product(n,term):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    while product(n,term):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    while product(n,term):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    while product(n,term):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    while product(n,term):","RecursionError: maximum recursion depth exceeded","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":422,"diff":"\r\nInputObject                   SideIndicator\r\n-----------                   -------------\r\n    value =  term(1)          =>           \r\n    for i in range(2, n+1):   =>           \r\n        value = value*term(i) =>           \r\n    return value              =>           \r\n    value = 1                 <=           \r\n    for i in range(1, n+1):   <=           \r\n         return 6             <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    value = 1\n    for i in range(1, n+1):\n         return 6","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    value =  term(1)\n    for i in range(2, n+1):\n        value = value*term(i)\n    return value","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)))))), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-2)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-value), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-value), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i)))))))))))), 0), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), 0)), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-value))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast)))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","6","","# Error: expected","#     120","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":426,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n        return term(1)                             =>           \r\n        return mul(term(n), (product(n-1, term)))  =>           \r\n    return product(n, identity)                    =>           \r\n        return term(n)                             <=           \r\n        return mul((term(n), product(n-1, term)))  <=           \r\n    return product(n, lambda n: n)                 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    else:\n        return mul((term(n), product(n-1, term))) ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return mul(term(n), (product(n-1, term))) ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))), 1), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(ConstNode(ParenthesisExpressionNode, SingleChild(ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), 0))))), 2), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(TupleExpressionNode-False, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return mul((term(n), product(n-1, term)))","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return mul((term(n), product(n-1, term)))","TypeError: op_mul expected 2 arguments, got 1","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":429,"diff":"\r\nInputObject          SideIndicator\r\n-----------          -------------\r\n    return total     =>           \r\n        return total <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, i = 1, 1\n    while i <= n:\n        total = total * term(i)\n        i += 1\n        return total\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    total, i = 1, 1\n    while i <= n:\n        total = total * term(i)\n        i += 1\n    return total\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ReferenceNode(node, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), SingleChild(ConstNode(SuiteStatementNode, Children(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0))))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":430,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n    if n <= 1:                            =>           \r\n        return term(1)                    =>           \r\n        return term(n)*product(n-1, term) =>           \r\n    if n < 1:                             <=           \r\n        return a                          <=           \r\n        a = n*product(n-1, term)          <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n < 1:\n        return a\n    else:\n        a = n*product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n <= 1:\n        return term(1)\n    else:\n        return term(n)*product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)))))), 0), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)))))), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), InOrderSort(ast)))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    a = n*product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    a = n*product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    a = n*product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    return a","UnboundLocalError: local variable 'a' referenced before assignment","","# Error: expected","#     6","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":432,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        return term(n)*product(n-1, term) =>           \r\n        return term(n)*prduct(n-1, term)  <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n ==1:\n        return 1\n    else:\n        return term(n)*prduct(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n ==1:\n        return 1\n    else:\n        return term(n)*product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n)*prduct(n-1, term)","NameError: name 'prduct' is not defined","","# Error: expected","#     6","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":465,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return term(n) * produce(n-1, term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return identity(n)\n    else:\n        return term(n) * produce(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return identity(n)\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n) * produce(n-1, term)","NameError: name 'produce' is not defined","","# Error: expected","#     6","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":434,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n            sum1 = sum1 * term(k) =>           \r\n        return sum1               =>           \r\n            sum1 = sum1 * term(k) =>           \r\n        return sum1               =>           \r\n        return sum1 * term(k)     <=           \r\n        return sum1 * term(k)     <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 1\n    sum1 = 1\n\n    if term == identity :\n        while k <= n :\n            k += 1\n        return sum1 * term(k)\n    if term == square :\n        while k <= n :\n            k += 1\n        return sum1 * term(k)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k = 1\n    sum1 = 1\n\n    if term == identity :\n        while k <= n :\n            sum1 = sum1 * term(k)\n            k += 1\n        return sum1\n    if term == square :\n        while k <= n :\n            sum1 = sum1 * term(k)\n            k += 1\n        return sum1\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-sum1), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-sum1), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-k)))))))))))), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-sum1), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-sum1), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-k)))))))))))), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","4","","# Error: expected","#     6","# but got","#     4","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":438,"diff":"","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    return product_helper(n,term,1)\n    def product_helper(x,termx,k):\n        if k==n:\n            return termx(x)\n        return termx(k)*product_helper(x,termx,k+1)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def product_helper(x,termx,k):\n        if k==n:\n            return termx(x)\n        return termx(k)*product_helper(x,termx,k+1)\n    return product_helper(n,term,1)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChild(Node(FunctionDefinitionNode-product_helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(FunctionDefinitionNode-product_helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product_helper), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))), Children(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(FunctionDefinitionNode-product_helper, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return product_helper(n,term,1)","UnboundLocalError: local variable 'product_helper' referenced before assignment","","# Error: expected","#     6","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":439,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    if n == 1:         =>           \r\n        return term(n) =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    return term(n)*product(n-1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    return term(n)*product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))))))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n)*product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n)*product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n)*product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n)*product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n)*product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n)*product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n)*product(n-1, term)","RecursionError: maximum recursion depth exceeded","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]},{"Id":470,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    if n == 1:         =>           \r\n        return term(n) =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    return term(n) * product(n - 1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(n)\n    return term(n) * product(n - 1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, SingleChild(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))))))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    return term(n) * product(n - 1, term)","RecursionError: maximum recursion depth exceeded","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":442,"diff":"\r\nInputObject                                                       SideIndicator\r\n-----------                                                       -------------\r\n    if n == 1:                                                    =>           \r\n        return n                                                  =>           \r\n        k = term(n)                                               =>           \r\n        return product(n-1, term) * k                             =>           \r\n    return product(n, identity)                                   =>           \r\n    if n == 0:                                                    =>           \r\n        return base                                               =>           \r\n    else:                                                         =>           \r\n        k = combiner(base, term(n))                               =>           \r\n        return combiner(accumulate(combiner, base, n-1, term), k) =>           \r\n    if n == 3:                                                    =>           \r\n        return f                                                  =>           \r\n    else:                                                         =>           \r\n        #f = compose1(f, f)                                       =>           \r\n        return repeated(compose1(f, f), n-1)                      =>           \r\n    if n <= 3:                                                    =>           \r\n        return n                                                  =>           \r\n    if n > 3:                                                     =>           \r\n        return g(n - 1) + 2 * g(n - 2) + 3 * g(n - 3)             =>           \r\n    value = 0                                                     =>           \r\n    k = 0                                                         =>           \r\n    while k < n:                                                  =>           \r\n        value += 1                                                =>           \r\n        if has_seven(value):                                      =>           \r\n            value -= 1                                            =>           \r\n        if value % 7 == 0:                                        =>           \r\n            value += 1                                            =>           \r\n        k += 1                                                    =>           \r\n    return value                                                  =>           \r\n                                                                  =>           \r\n    else:                                                         =>           \r\n                                                                  =>           \r\n    return _______                                                <=           \r\n    \"*** YOUR CODE HERE ***\"                                      <=           \r\n    \"*** YOUR CODE HERE ***\"                                      <=           \r\n    \"*** YOUR CODE HERE ***\"                                      <=           \r\n    \"*** YOUR CODE HERE ***\"                                      <=           \r\n    \"*** YOUR CODE HERE ***\"                                      <=           \r\n    \"*** YOUR CODE HERE ***\"                                      <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return n\n    else:\n        k = term(n)\n        return product(n-1, term) * k","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))), SingleChild(ConstNode(SuiteStatementNode, Children(ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-k), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n))))))))), SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))), SingleChild(LeafConstNode(NameExpressionNode-k)))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":443,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        return product(n) * product(n-1)    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return term(1)\n    else:\n        return product(n) * product(n-1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in product","    return product(n) * product(n-1)","TypeError: product() missing 1 required positional argument: 'term'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":445,"diff":"\r\nInputObject                                      SideIndicator\r\n-----------                                      -------------\r\n    total, k = 1, 1                              =>           \r\n    while k <= n:                                =>           \r\n        total, k = total * term(k), increment(k) =>           \r\n    return total                                 =>           \r\n    total = 1                                    <=           \r\n    k = 1                                        <=           \r\n    if n == 0:                                   <=           \r\n        return 0                                 <=           \r\n    elif n == 1:                                 <=           \r\n        return 1                                 <=           \r\n        return product(n, term)                  <=           \r\n    n += 1                                       <=           \r\n    '''while k <= n:                             <=           \r\n        total = total * term(k)                  <=           \r\n        k = increment(k)                         <=           \r\n    return total'''                              <=           \r\n    else:                                        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    k = 1\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return product(n, term)\n    n += 1\n    '''while k <= n:\n        total = total * term(k)\n        k = increment(k)\n    return total'''","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total, k = total * term(k), increment(k)\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(NameExpressionNode-k)))), SingleChild(ConstNode(TupleExpressionNode-False, Children(LeafConstNode(ConstantExpressionNode-1), SingleChild(LeafConstNode(ConstantExpressionNode-1))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(NameExpressionNode-n))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementTestNode, TChildren(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Target(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-k)))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-k))))))), Selected(\\x => Match(x, Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-increment)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Target(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(WhileStatementNode, Children(ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-k), SingleChild(LeafConstNode(NameExpressionNode-n)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(AssignmentStatementNode, Children(ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-total), SingleChild(LeafConstNode(NameExpressionNode-k)))), SingleChild(ConstNode(TupleExpressionNode-False, Children(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-k))))))))), SingleChild(ReferenceNode(node, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))))))))))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-total)))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))))))))))))))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    return product(n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    return product(n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    return product(n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    return product(n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    return product(n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    return product(n, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    if n == 0:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":446,"diff":"\r\nInputObject                                                 SideIndicator\r\n-----------                                                 -------------\r\n    return reduce(lambda o, e: o * term(e), range(1,n+1))   =>           \r\n    return reduce(lambda o, e: o * square(e), range(1,n+1)) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    return reduce(lambda o, e: o * square(e), range(1,n+1))","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    return reduce(lambda o, e: o * term(e), range(1,n+1))","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(FunctionDefinitionNode-<lambda$2064>, Children(ReferenceNode(node, Node(FunctionDefinitionNode-<lambda$2063>, TChildren(Target(LeafWildcard(\"ParameterNode\")), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0), Children(ReferenceNode(node, Node(FunctionDefinitionNode-<lambda$2063>, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(Target(LeafWildcard(\"ParameterNode\")), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0), SingleChild(ReferenceNode(node, Node(FunctionDefinitionNode-<lambda$2063>, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)))))), Selected(\\x => Match(x, Node(LambdaExpressionNode, TChild(Target(Node(FunctionDefinitionNode-<lambda$2063>, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","36","","# Error: expected","#     6","# but got","#     36","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":447,"diff":"\r\nInputObject                           SideIndicator\r\n-----------                           -------------\r\n    x = 1                             =>           \r\n    while x <= n:                     =>           \r\n        result = term(x) * result     =>           \r\n        x += 1                        =>           \r\n    return product(n, identity(n))    =>           \r\n                                      =>           \r\n    while(n != 0):                    <=           \r\n        result = result * n * (n - 1) <=           \r\n        n -= 2                        <=           \r\n    result = term(result)             <=           \r\n    return product (n, lambda k: k)   <=           \r\n                                      <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = 1\n    while(n != 0):\n        result = result * n * (n - 1)\n        n -= 2\n    result = term(result)\n    return result","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = 1\n    x = 1\n    while x <= n:\n        result = term(x) * result\n        x += 1\n    return result","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-x), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-x)), Selected(\\x => Match(x, Node(BinaryExpressionNode-NotEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(LeafConstNode(NameExpressionNode-x), SingleChild(LeafConstNode(NameExpressionNode-n))))), Selected(\\x => Match(x, Node(ParenthesisExpressionNode, TChild(Target(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(WhileStatementNode, TChildren(Target(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ParenthesisExpressionNode, TChild(Target(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-x))))))), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-result)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0), 1), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-x)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Subtract, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-x), SingleChild(LeafConstNode(ConstantExpressionNode-1))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Target(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ParenthesisExpressionNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast)))))))))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":449,"diff":"","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, total = 1, 1\n    while k < n:\n        n -= 1\n        total = total * term(n)\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    k, total = 1, 1\n    while k < n:\n        total = total * term(n)\n        n -= 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":453,"diff":"\r\nInputObject  SideIndicator\r\n-----------  -------------\r\n        a+=1 =>           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    a=1\n    total=1\n    while a<=n:\n        total=total*term(a)\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    a=1\n    total=1\n    while a<=n:\n        total=total*term(a)\n        a+=1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Add, Children(LeafConstNode(NameExpressionNode-a), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":455,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n                                =>           \r\n    while n  >= 1:              =>           \r\n        total = total * term(n) =>           \r\n        n -= 1                  =>           \r\n    x = 0                       <=           \r\n    while x < n:                <=           \r\n        total = total * term(x) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    x = 0\n    while x < n:\n        total = total * term(x)\n    return total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    \n    while n  >= 1:\n        total = total * term(n)\n        n -= 1\n    return total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-GreaterThanOrEqual, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(AugmentedAssignStatementNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":458,"diff":"\r\nInputObject                                          SideIndicator\r\n-----------                                          -------------\r\n            return identity_helper(x+1,func)*func(x) =>           \r\n    return identity_helper(1,term)                   =>           \r\n            return multi(x+1,func)*func(x)           <=           \r\n    return multi(1,term)                             <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def identity_helper(x,func):\n        if x==n:\n            return func(n)\n        else:\n            return multi(x+1,func)*func(x)\n    return multi(1,term)\n\n ","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def identity_helper(x,func):\n        if x==n:\n            return func(n)\n        else:\n            return identity_helper(x+1,func)*func(x)\n    return identity_helper(1,term)\n\n ","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-identity_helper)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-identity_helper)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in product","    return multi(1,term)","NameError: name 'multi' is not defined","","# Error: expected","#     6","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":459,"diff":"\r\nInputObject                             SideIndicator\r\n-----------                             -------------\r\n            return term(i)*counter(i+1) =>           \r\n    return counter(i)                   =>           \r\n            return term(i)+counter(i+1) <=           \r\n                                        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i=1\n    def counter(i):\n        if i==n:\n            return term(n)\n        else:\n            return term(i)+counter(i+1)\n        \n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i=1\n    def counter(i):\n        if i==n:\n            return term(n)\n        else:\n            return term(i)*counter(i+1)\n    return counter(i)\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), 0))))), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-counter), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i)))))))), 4), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(FunctionDefinitionNode-counter, TChildren(LeafWildcard(\"ParameterNode\"), TChild(Node(SuiteStatementNode, TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Add, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))))))))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":460,"diff":"\r\nInputObject                     SideIndicator\r\n-----------                     -------------\r\n    total = 1                   =>           \r\n        total *= term(x)        =>           \r\n    return product(n, identity) =>           \r\n    total = combiner(base, n)   =>           \r\n    x = 1                       =>           \r\n    while not x > n:            =>           \r\n        total (x)               =>           \r\n        x += 1                  =>           \r\n    return total                =>           \r\n    total = 0                   <=           \r\n        total += term(x)        <=           \r\n    return _______              <=           \r\n    \"*** YOUR CODE HERE ***\"    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 0\n    x = 1\n    while not x > n:\n        total += term(x)\n        x += 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    x = 1\n    while not x > n:\n        total *= term(x)\n        x += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatementNode-Multiply, Children(ReferenceNode(node, Node(AugmentedAssignStatementNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ReferenceNode(node, Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":462,"diff":"\r\nInputObject                 SideIndicator\r\n-----------                 -------------\r\n    total = 1               =>           \r\n        total=total*term(i) =>           \r\n    total = 0               <=           \r\n        total += term(i)    <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 0\n    while i<=n:\n        total += term(i)\n        i+=1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    total = 1\n    while i<=n:\n        total=total*term(i)\n        i+=1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i)))))))))))), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","15","","# Error: expected","#     120","# but got","#     15","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":463,"diff":"\r\nInputObject                                  SideIndicator\r\n-----------                                  -------------\r\n        total = term(n) * product(n-1, term) =>           \r\n        return total                         =>           \r\n        total = term(n)                      <=           \r\n        return term(n-1) * total             <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    else:\n        total = term(n)\n        return term(n-1) * total \n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if n == 1:\n        return term(n)\n    else:\n        total = term(n) * product(n-1, term)\n        return total \n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-product)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))), 2), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(LeafWildcard(\"NameExpressionNode\")))), 0))))))), 0), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))), 1), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Target(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","20","","# Error: expected","#     120","# but got","#     20","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":466,"diff":"\r\nInputObject         SideIndicator\r\n-----------         -------------\r\n    while i != n+1: =>           \r\n    while i != n:   <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    thing = 1\n    while i != n:\n        thing *= term(i)\n        i += 1\n    return thing","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i = 1\n    thing = 1\n    while i != n+1:\n        thing *= term(i)\n        i += 1\n    return thing","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(BinaryExpressionNode-Add, Children(ReferenceNode(node, Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 1), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-NotEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","2","","# Error: expected","#     6","# but got","#     2","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":468,"diff":"\r\nInputObject                                                                              SideIndicator\r\n-----------                                                                              -------------\r\n    if n == 1:                                                                           =>           \r\n        return term(1)                                                                   =>           \r\n        return term(n)*product(n-1, term)                                                =>           \r\n    if n == 0:                                                                           =>           \r\n        return 1                                                                         =>           \r\n    return product(n, identity)                                                          =>           \r\n    if n == 0:                                                                           =>           \r\n        return base                                                                      =>           \r\n    else:                                                                                =>           \r\n        return combiner(term(n), accumulate(combiner, base, n-1, term))                  =>           \r\n    return accumulate(add, 0, n, term)                                                   =>           \r\n    return accumulate(mul, 1, n, term)                                                   =>           \r\n    return accumulate(lambda x,y: combiner(x, y) if pred(term(x)) else y, base, n, term) =>           \r\n    curr_f = identity                                                                    =>           \r\n    while n > 0:                                                                         =>           \r\n        curr_f = compose1(f, curr_f)                                                     =>           \r\n        n -= 1                                                                           =>           \r\n    return curr_f                                                                        =>           \r\n    else:                                                                                =>           \r\n    return _______                                                                       <=           \r\n    return _______                                                                       <=           \r\n    return _______                                                                       <=           \r\n    return _______                                                                       <=           \r\n    \"*** YOUR CODE HERE ***\"                                                             <=           \r\n    \"*** YOUR CODE HERE ***\"                                                             <=           \r\n    \"*** YOUR CODE HERE ***\"                                                             <=           \r\n    \"*** YOUR CODE HERE ***\"                                                             <=           \r\n    \"*** YOUR CODE HERE ***\"                                                             <=           \r\n    \"*** YOUR CODE HERE ***\"                                                             <=           \r\n    \"*** YOUR CODE HERE ***\"                                                             <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n)*product(n-1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-term)), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1))))))))))))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ConstNode(ArgNode, SingleChild(ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))))))), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":469,"diff":"\r\nInputObject                                SideIndicator\r\n-----------                                -------------\r\n    if n==1:                               =>           \r\n        return term(1)                     =>           \r\n        return term(n) * product(n-1,term) =>           \r\n    x=1                                    <=           \r\n    if x==n:                               <=           \r\n        return term(x)                     <=           \r\n        return term(x) * product(x+1,term) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    x=1\n    if x==n:\n        return term(x)\n    else:\n        return term(x) * product(x+1,term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return term(1)\n    else:\n        return term(n) * product(n-1,term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Subtract, Children(LeafConstNode(NameExpressionNode-n), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast)))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product","    return term(x) * product(x+1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product","    return term(x) * product(x+1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product","    return term(x) * product(x+1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product","    return term(x) * product(x+1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product","    return term(x) * product(x+1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product","    return term(x) * product(x+1,term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    if x==n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":471,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    return total =>           \r\n                 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total *= term(k)\n        k = increment(k)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total, k = 1, 1\n    while k <= n:\n        total *= term(k)\n        k = increment(k)\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":474,"diff":"\r\nInputObject                       SideIndicator\r\n-----------                       -------------\r\n        result *= term(i)         =>           \r\n        result = term(result) * i <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, result = 1, 1\n    while i <= n:\n        result = term(result) * i\n        i += 1\n    return result","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, result = 1, 1\n    while i <= n:\n        result *= term(i)\n        i += 1\n    return result","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatementNode-Multiply, Children(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(LeafWildcard(\"NameExpressionNode\")))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","12","","# Error: expected","#     36","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":477,"diff":"\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n        return term(x)*helper(x+1)   =>           \r\n    return helper(1)                 =>           \r\n                                     =>           \r\n        return term(x+1)*helper(x+1) <=           \r\n    return helper(0)                 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(x):\n        if(n == x):\n            return term(x)\n        return term(x+1)*helper(x+1)\n    return helper(0)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    def helper(x):\n        if(n == x):\n            return term(x)\n        return term(x)*helper(x+1)\n\n    return helper(1)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","18","","# Error: expected","#     6","# but got","#     18","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":478,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return 1                            =>           \r\n        return term(n) * product(n-1, term) =>           \r\n                                            =>           \r\n        return prod                         <=           \r\n        prod = term(n) * product(n-1, term) <=           \r\n        return prod                         <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n  \n    if n == 0:\n        return prod\n    else:\n        prod = term(n) * product(n-1, term)\n        return prod\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n  \n    if n == 0:\n        return 1\n    else:\n        return term(n) * product(n-1, term)\n        \n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0)))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 36, in product","    prod = term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 36, in product","    prod = term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 36, in product","    prod = term(n) * product(n-1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in product","    return prod","UnboundLocalError: local variable 'prod' referenced before assignment","","# Error: expected","#     6","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":482,"diff":"\r\nInputObject                                   SideIndicator\r\n-----------                                   -------------\r\n            return helper(n - 1, term, total) =>           \r\n            return helper(n - 1, term)        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper(n, term, total):\n        if n == 1: \n            return total\n        else:\n            total *= term(n)\n            return helper(n - 1, term)\n\n    return helper(n, term, 1)\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def helper(n, term, total):\n        if n == 1: \n            return total\n        else:\n            total *= term(n)\n            return helper(n - 1, term, total)\n\n    return helper(n, term, 1)\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Insert(node, ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-total))), 3), Selected(\\x => Match(x, Node(ReturnStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 37, in product","    return helper(n, term, 1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 35, in helper","    return helper(n - 1, term)","TypeError: helper() missing 1 required positional argument: 'total'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":483,"diff":"\r\nInputObject                                            SideIndicator\r\n-----------                                            -------------\r\n    def combiner(i):                                   =>           \r\n        if i <= n:                                     =>           \r\n            return result * term(i) * combiner(i + 1)  =>           \r\n        else:                                          =>           \r\n            return result                              =>           \r\n    return combiner(1)                                 =>           \r\n    i = 1                                              <=           \r\n    if i <= n:                                         <=           \r\n        return result * term(i) * product(i + 1, term) <=           \r\n        return result                                  <=           \r\n    else:                                              <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    result = 1\n    i = 1\n    if i <= n:\n    \treturn result * term(i) * product(i + 1, term)\n    else:\n    \treturn result","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    result = 1\n    def combiner(i):\n    \tif i <= n:\n    \t\treturn result * term(i) * combiner(i + 1)\n    \telse:\n    \t\treturn result\n    return combiner(1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-combiner)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(FunctionDefinitionNode-combiner, Children(LeafConstNode(ParameterNode-i), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0)))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-combiner), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(IfStatementNode, TChildren(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChild(Node(SuiteStatementNode, TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return result * term(i) * product(i + 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return result * term(i) * product(i + 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return result * term(i) * product(i + 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return result * term(i) * product(i + 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return result * term(i) * product(i + 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return result * term(i) * product(i + 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    if i <= n:","RecursionError: maximum recursion depth exceeded in comparison","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":486,"diff":"\r\nInputObject                    SideIndicator\r\n-----------                    -------------\r\n    total = 1                  =>           \r\n    for i in range(1, n+1):    =>           \r\n        total *= term(i)       =>           \r\n                               =>           \r\n                               <=           \r\n    step == 1                  <=           \r\n    for step in range(1, n+1): <=           \r\n        total *= term(step)    <=           \r\n    return total               <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    step == 1\n    for step in range(1, n+1):\n        total *= term(step)\n    return total\n\n    return tota","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total = 1\n    for i in range(1, n+1):\n        total *= term(i)\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0), 1), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ForStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChildren(Node(ForStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(SuiteStatementNode, TChild(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChildren(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast)))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 30, in product","    step == 1","UnboundLocalError: local variable 'step' referenced before assignment","","# Error: expected","#     6","# but got","#     UnboundLocalError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":487,"diff":"\r\nInputObject      SideIndicator\r\n-----------      -------------\r\n    i =1         =>           \r\n    total = 1    =>           \r\n    i, total = 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i, total = 1\n    while i <= n:\n        total = total * term(i)\n        i += 1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i =1 \n    total = 1\n    while i <= n:\n        total = total * term(i)\n        i += 1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChildren(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 31, in product","    i, total = 1","TypeError: 'int' object is not iterable","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":488,"diff":"\r\nInputObject                                 SideIndicator\r\n-----------                                 -------------\r\n        return term(n) * product(n-1, term) =>           \r\n        mul(n, term(n) - 1)                 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    if n < 0:\n        return \n    elif n == 1:\n        return 1\n    else:\n        mul(n, term(n) - 1)\n\n\n\n\n    \"*** YOUR CODE HERE ***\"","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \n    if n < 0:\n        return \n    elif n == 1:\n        return 1\n    else:\n        return term(n) * product(n-1, term)\n\n\n\n\n    \"*** YOUR CODE HERE ***\"","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(BinaryExpressionNode-Subtract, TChildren(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Subtract, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)))), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), 0), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Target(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))), 0)))), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ReferenceNode(node, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), 0), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-term))))))))))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","","# Error: expected","#     6","# but got","#     ","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":495,"diff":"\r\nInputObject                               SideIndicator\r\n-----------                               -------------\r\n        i, total = i + 1, total * term(i) =>           \r\n        i += 1                            <=           \r\n        total = total * term(i)           <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, total = 1, 1\n    while i <= n:\n        i += 1\n        total = total * term(i)\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, total = 1, 1\n    while i <= n:\n        i, total = i + 1, total * term(i)\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-total)), Selected(\\x => Match(x, Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(AssignmentStatementNode, Children(ConstNode(TupleExpressionNode-False, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(NameExpressionNode-total)))), SingleChild(ConstNode(TupleExpressionNode-False, Children(ConstNode(BinaryExpressionNode-Add, Children(LeafConstNode(NameExpressionNode-i), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-i))))))))))))))), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))))))), InOrderSort(ast))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","24","","# Error: expected","#     6","# but got","#     24","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":496,"diff":"\r\nInputObject       SideIndicator\r\n-----------       -------------\r\n        #f b==n:  =>           \r\n        i#f b==n: <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def count(b,a=1):\n        if b<=n:\n            a*=term(b)\n            return count(b+1,a)\n        i#f b==n:\n        return a\n    return count(1)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    def count(b,a=1):\n        if b<=n:\n            a*=term(b)\n            return count(b+1,a)\n        #f b==n:\n        return a\n    return count(1)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChildren(Target(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-count, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(Node(ParameterNode-a, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(IfStatementNode, TChild(Node(IfStatementTestNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(ReturnStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 36, in product","    return count(1)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in count","    return count(b+1,a)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in count","    return count(b+1,a)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in count","    return count(b+1,a)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 34, in count","    i#f b==n:","NameError: name 'i' is not defined","","# Error: expected","#     6","# but got","#     NameError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":500,"diff":"\r\nInputObject                SideIndicator\r\n-----------                -------------\r\n    while k <= n:          =>           \r\n        product *= term(k) =>           \r\n    while k < n:           <=           \r\n        product *= term(n) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k, product = 1, 1\n    while k < n:\n        product *= term(n)\n        k += 1\n    return product","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    k, product = 1, 1\n    while k <= n:\n        product *= term(k)\n        k += 1\n    return product","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(BinaryExpressionNode-LessThanOrEqual, Children(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-k)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","9","","# Error: expected","#     6","# but got","#     9","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":504,"diff":"\r\nInputObject                                    SideIndicator\r\n-----------                                    -------------\r\n    if n == 1:                                 =>           \r\n        return result * term(n)                =>           \r\n        result *= term(n)*product(n - 1, term) =>           \r\n        return result                          =>           \r\n    else:                                      =>           \r\n    result *= term(n)*product(n - 1, term)     <=           \r\n    return result                              <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = 1\n    result *= term(n)*product(n - 1, term)\n    return result","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    result = 1\n    if n == 1:\n        return result * term(n)\n    else:\n        result *= term(n)*product(n - 1, term)\n        return result","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Insert(node, ConstNode(IfStatementNode, Children(ConstNode(IfStatementTestNode, Children(ConstNode(BinaryExpressionNode-Equals, Children(LeafConstNode(NameExpressionNode-n), SingleChild(LeafConstNode(ConstantExpressionNode-1)))), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ConstNode(ReturnStatementNode, SingleChild(ConstNode(BinaryExpressionNode-Multiply, Children(LeafConstNode(NameExpressionNode-result), SingleChild(ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(NameExpressionNode-n)))))))))))))))), SingleChild(ConstNode(SuiteStatementNode, Children(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0))))))), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChildren(Node(ArgNode, TChild(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  ...","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    result *= term(n)*product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    result *= term(n)*product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    result *= term(n)*product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    result *= term(n)*product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    result *= term(n)*product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    result *= term(n)*product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 32, in product","    result *= term(n)*product(n - 1, term)","RecursionError: maximum recursion depth exceeded","","# Error: expected","#     6","# but got","#     RecursionError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":507,"diff":"\r\nInputObject                                        SideIndicator\r\n-----------                                        -------------\r\n    i, Total = 1, 1                                =>           \r\n    while i<=n:                                    =>           \r\n        i, Total = i + 1, Total * term(i)          =>           \r\n    return Total                                   =>           \r\n    item, Total = 0, 1                             <=           \r\n    while item<=n:                                 <=           \r\n        item, Total = item + 1, Total * term(item) <=           \r\n        return Total                               <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    item, Total = 0, 1\n\n    while item<=n:\n        item, Total = item + 1, Total * term(item)\n        return Total\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    i, Total = 1, 1\n\n    while i<=n:\n        i, Total = i + 1, Total * term(i)\n    return Total\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"ConstantExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-LessThanOrEqual, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(TupleExpressionNode-False, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-i)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), InOrderSort(ast))), CPatch(EditMap(\\node => Insert(node, ConstNode(WhileStatementNode, Children(ReferenceNode(node, Node(WhileStatementNode, TChildren(Target(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0), SingleChild(ConstNode(SuiteStatementNode, SingleChild(ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), 0)))))), 2), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Target(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))))))))), 0)), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Target(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), 3), Selected(\\x => Match(x, Node(FunctionDefinitionNode-product, TChildren(LeafWildcard(\"ParameterNode\"), TChildren(LeafWildcard(\"ParameterNode\"), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(LeafWildcard(\"ConstantExpressionNode\"))), TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"ConstantExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), TChild(Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(SuiteStatementNode, TChildren(Node(AssignmentStatementNode, TChildren(Node(TupleExpressionNode-False, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Node(BinaryExpressionNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))), TChild(Node(ReturnStatementNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))))))))))))), InOrderSort(ast)))))))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","0","","# Error: expected","#     6","# but got","#     0","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":508,"diff":"\r\nInputObject             SideIndicator\r\n-----------             -------------\r\n                        =>           \r\n        total *=term(i) =>           \r\n        term(i)         <=           \r\n        total *=i       <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    total =1\n    while i <= n:\n        term(i)\n        total *=i\n        i+=1\n    return total","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    i = 1\n    total =1\n    while i <= n:\n\n        total *=term(i)\n        i+=1\n    return total","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatementNode-Multiply, Children(LeafConstNode(NameExpressionNode-total), SingleChild(ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Target(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\"))))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-LessThanOrEqual, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))))), TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"NameExpressionNode\")))), TChild(Node(AugmentedAssignStatementNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","6",">>> product(5, identity) # 1 * 2 * 3 * 4 * 5","120",">>> product(3, square)   # 1^2 * 2^2 * 3^2","6","","# Error: expected","#     36","# but got","#     6","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":514,"diff":"\r\nInputObject            SideIndicator\r\n-----------            -------------\r\n    if n == 1:         =>           \r\n        return term(1) =>           \r\n    if n == 0:         <=           \r\n        return         <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 0:\n        return\n    else:\n        return term(n) * product(n - 1, term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n == 1:\n        return term(1)\n    else:\n        return term(n) * product(n - 1, term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(ConstantExpressionNode-1)), Selected(\\x => Match(x, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\")))))), InOrderSort(ast))), Patch(EditMap(\\node => Insert(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-term), SingleChild(ConstNode(ArgNode, SingleChild(LeafConstNode(ConstantExpressionNode-1)))))), 0), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(LeafWildcard(\"ReturnStatementNode\"))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","Traceback (most recent call last):","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n) * product(n - 1, term)","  File \"C:\\Users\\Gustavo\\Box Sync\\pesquisa\\tutor\\hw02-sp16\\hw02.py\", line 33, in product","    return term(n) * product(n - 1, term)","TypeError: unsupported operand type(s) for *: 'int' and 'NoneType'","","# Error: expected","#     6","# but got","#     TypeError","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":515,"diff":"\r\nInputObject    SideIndicator\r\n-----------    -------------\r\n        i += 1 =>           \r\n        i *= 1 <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    t, i = 1, 1\n    while i <= n:\n        t *= term(i)\n        i *= 1\n    return t","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    t, i = 1, 1\n    while i <= n:\n        t *= term(i)\n        i += 1\n    return t","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, Patch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatementNode-Add, Children(ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), SingleChild(ReferenceNode(node, Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChildren(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Target(Node(AugmentedAssignStatementNode-Multiply, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))), InOrderSort(ast)))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","# Error: evaluation exceeded 10 seconds.","","# Error: expected","#     6","# but got","#     Timeout","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":518,"diff":"\r\nInputObject                          SideIndicator\r\n-----------                          -------------\r\n        result *= term(x)            =>           \r\n        result = term(x) * term(x+1) <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    result = 1\n    for x in range(1, n+1):\n        result = term(x) * term(x+1)\n    return result","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    result = 1\n    for x in range(1, n+1):\n        result *= term(x)\n    return result","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(ArgNode, TChild(Target(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Add, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(LeafWildcard(\"ConstantExpressionNode\")))), 0), 0), Selected(\\x => Match(x, Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))))))), 0)), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Move(node, ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), 0), 1), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(AugmentedAssignStatementNode-Multiply, Children(ReferenceNode(node, Node(AssignmentStatementNode, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Target(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))), 0))))), Selected(\\x => Match(x, Node(SuiteStatementNode, TChild(Target(Node(AssignmentStatementNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(Node(BinaryExpressionNode-Add, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))))))))))))))), InOrderSort(ast)))))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","12","","# Error: expected","#     6","# but got","#     12","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":522,"diff":"\r\nInputObject                              SideIndicator\r\n-----------                              -------------\r\n        return term(n)*product(n-1,term) =>           \r\n        return term(1)*(n-1,term)        <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return term(n)\n    else:\n        return term(1)*(n-1,term)","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    if n==1:\n        return term(n)\n    else:\n        return term(n)*product(n-1,term)","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, LeafConstNode(NameExpressionNode-n)), Selected(\\x => Match(x, Node(ArgNode, TChild(Target(LeafWildcard(\"ConstantExpressionNode\"))))), InOrderSort(ast))), Patch(EditMap(\\node => Update(node, ConstNode(CallExpressionNode, Children(LeafConstNode(NameExpressionNode-product), Children(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Target(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))), TChild(LeafWildcard(\"NameExpressionNode\")))), 0))), SingleChild(ConstNode(ArgNode, SingleChild(ReferenceNode(node, Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(LeafWildcard(\"NameExpressionNode\"))))), 0)))))))), Selected(\\x => Match(x, Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"ConstantExpressionNode\")))))), TChild(Target(Node(TupleExpressionNode-False, TChildren(Node(BinaryExpressionNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), InOrderSort(ast))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","(2, <function identity at 0x000001FB155E5EA0>)","","# Error: expected","#     6","# but got","#     (2, <function identity at 0x000001FB155E5EA0>)","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}],[{"Id":527,"diff":"\r\nInputObject                  SideIndicator\r\n-----------                  -------------\r\n        total=term(n)*total  =>           \r\n        total==term(n)*total <=           \r\n\r\n\r\n","before":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total=1\n    while n>0:\n        total==term(n)*total\n        n-=1\n    return total\n\n\n","after":"def product(n, term):\n    \"\"\"Return the product of the first n terms in a sequence.\n\n    n    -- a positive integer\n    term -- a function that takes one argument\n\n    >>> product(3, identity) # 1 * 2 * 3\n    6\n    >>> product(5, identity) # 1 * 2 * 3 * 4 * 5\n    120\n    >>> product(3, square)   # 1^2 * 2^2 * 3^2\n    36\n    >>> product(5, square)   # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\n    14400\n    \"\"\"\n    total=1\n    while n>0:\n        total=term(n)*total\n        n-=1\n    return total\n\n\n","Time":0,"SynthesizedAfter":null,"IsFixed":false,"GeneratedFix":"Apply(ast, CPatch(EditMap(\\node => Update(node, ConstNode(AssignmentStatementNode, Children(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(Target(LeafWildcard(\"NameExpressionNode\")), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))), 0), SingleChild(ReferenceNode(node, Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Target(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))), 0))))), Selected(\\x => Match(x, Node(ExpressionStatementNode, TChild(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))))), InOrderSort(ast))), CPatch(EditMap(\\node => Delete(node, ReferenceNode(node, Node(SuiteStatementNode, TChildren(Target(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\"))))))), 0)), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast))), Patch(EditMap(\\node => Move(node, ReferenceNode(node, Node(ExpressionStatementNode, TChild(Target(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\")))))))))), 0), 0), Selected(\\x => Match(x, Node(WhileStatementNode, TChildren(Node(BinaryExpressionNode-GreaterThan, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))), TChild(Target(Node(SuiteStatementNode, TChildren(Node(ExpressionStatementNode, TChild(Node(BinaryExpressionNode-Equals, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(BinaryExpressionNode-Multiply, TChildren(Node(CallExpressionNode, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(Node(ArgNode, TChild(LeafWildcard(\"NameExpressionNode\")))))), TChild(LeafWildcard(\"NameExpressionNode\"))))))))), TChild(Node(AugmentedAssignStatementNode-Subtract, TChildren(LeafWildcard(\"NameExpressionNode\"), TChild(LeafWildcard(\"ConstantExpressionNode\")))))))))))), InOrderSort(ast)))))))","UsedFix":null,"failed":["=====================================================================","Assignment: Homework 2","OK, version v1.5.3","=====================================================================","","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","Running tests","","---------------------------------------------------------------------","Doctests for product","",">>> from hw02 import *",">>> product(3, identity) # 1 * 2 * 3","1","","# Error: expected","#     6","# but got","#     1","","---------------------------------------------------------------------","Test summary","    0 test cases passed before encountering first failed test case",""]}]]